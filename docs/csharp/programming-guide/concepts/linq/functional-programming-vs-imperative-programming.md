---
title: "Comparaison de la programmation fonctionnelle et de la programmation impérative (C#)"
ms.custom: 
ms.date: 07/20/2015
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: devlang-csharp
ms.topic: article
ms.assetid: 5e35c5a0-c949-422a-873b-fca6b2254f57
caps.latest.revision: "3"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: 2c57d89120eee8c7f84d6e87b14f038378a0b3d1
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/21/2017
---
# <a name="functional-programming-vs-imperative-programming-c"></a><span data-ttu-id="22e49-102">Comparaison de la programmation fonctionnelle et de la programmation impérative (C#)</span><span class="sxs-lookup"><span data-stu-id="22e49-102">Functional Programming vs. Imperative Programming (C#)</span></span>
<span data-ttu-id="22e49-103">Cette rubrique compare et contraste la programmation fonctionnelle avec la programmation impérative (procédurale) plus traditionnelle.</span><span class="sxs-lookup"><span data-stu-id="22e49-103">This topic compares and contrasts functional programming with more traditional imperative (procedural) programming.</span></span>  
  
## <a name="functional-programming-vs-imperative-programming"></a><span data-ttu-id="22e49-104">Comparaison de la programmation fonctionnelle et de la Programmation impérative</span><span class="sxs-lookup"><span data-stu-id="22e49-104">Functional Programming vs. Imperative Programming</span></span>  
 <span data-ttu-id="22e49-105">Le paradigme *programmation fonctionnelle* a été créé explicitement afin de prendre en charge une approche fonctionnelle pure de la résolution des problèmes.</span><span class="sxs-lookup"><span data-stu-id="22e49-105">The *functional programming* paradigm was explicitly created to support a pure functional approach to problem solving.</span></span> <span data-ttu-id="22e49-106">La programmation fonctionnelle est une forme de *programmation déclarative*.</span><span class="sxs-lookup"><span data-stu-id="22e49-106">Functional programming is a form of *declarative programming*.</span></span> <span data-ttu-id="22e49-107">Par contraste, la plupart des langages courants, y compris des langages de programmation orientés objets tels que C#, Visual Basic, C++ et Java, ont été conçus principalement pour prendre en charge la programmation *impérative* (procédurale).</span><span class="sxs-lookup"><span data-stu-id="22e49-107">In contrast, most mainstream languages, including object-oriented programming (OOP) languages such as C#, Visual Basic, C++, and Java, were designed to primarily support *imperative* (procedural) programming.</span></span>  
  
 <span data-ttu-id="22e49-108">Avec une approche impérative, un développeur écrit du code qui décrit exactement et en détail les étapes que l'ordinateur doit effectuer pour atteindre l'objectif.</span><span class="sxs-lookup"><span data-stu-id="22e49-108">With an imperative approach, a developer writes code that describes in exacting detail the steps that the computer must take to accomplish the goal.</span></span> <span data-ttu-id="22e49-109">On appelle parfois cela la programmation *algorithmique*.</span><span class="sxs-lookup"><span data-stu-id="22e49-109">This is sometimes referred to as *algorithmic* programming.</span></span> <span data-ttu-id="22e49-110">Par contraste, une approche fonctionnelle suppose la composition du problème sous la forme d'un ensemble de fonctions à exécuter.</span><span class="sxs-lookup"><span data-stu-id="22e49-110">In contrast, a functional approach involves composing the problem as a set of functions to be executed.</span></span> <span data-ttu-id="22e49-111">Vous définissez soigneusement l'entrée de chaque fonction et ce que chaque fonction retourne.</span><span class="sxs-lookup"><span data-stu-id="22e49-111">You define carefully the input to each function, and what each function returns.</span></span> <span data-ttu-id="22e49-112">Le tableau suivant décrit quelques-unes des différences générales entre ces deux approches.</span><span class="sxs-lookup"><span data-stu-id="22e49-112">The following table describes some of the general differences between these two approaches.</span></span>  
  
|<span data-ttu-id="22e49-113">Caractéristique</span><span class="sxs-lookup"><span data-stu-id="22e49-113">Characteristic</span></span>|<span data-ttu-id="22e49-114">Approche impérative</span><span class="sxs-lookup"><span data-stu-id="22e49-114">Imperative approach</span></span>|<span data-ttu-id="22e49-115">Approche fonctionnelle</span><span class="sxs-lookup"><span data-stu-id="22e49-115">Functional approach</span></span>|  
|--------------------|-------------------------|-------------------------|  
|<span data-ttu-id="22e49-116">Focus du programmeur</span><span class="sxs-lookup"><span data-stu-id="22e49-116">Programmer focus</span></span>|<span data-ttu-id="22e49-117">Comment effectuer des tâches (algorithmes) et comment assurer le suivi des modifications d'état.</span><span class="sxs-lookup"><span data-stu-id="22e49-117">How to perform tasks (algorithms) and how to track changes in state.</span></span>|<span data-ttu-id="22e49-118">Les informations souhaitées et les transformations requises.</span><span class="sxs-lookup"><span data-stu-id="22e49-118">What information is desired and what transformations are required.</span></span>|  
|<span data-ttu-id="22e49-119">Modification de l'état</span><span class="sxs-lookup"><span data-stu-id="22e49-119">State changes</span></span>|<span data-ttu-id="22e49-120">Important.</span><span class="sxs-lookup"><span data-stu-id="22e49-120">Important.</span></span>|<span data-ttu-id="22e49-121">Non-existantes.</span><span class="sxs-lookup"><span data-stu-id="22e49-121">Non-existent.</span></span>|  
|<span data-ttu-id="22e49-122">Ordre d'exécution</span><span class="sxs-lookup"><span data-stu-id="22e49-122">Order of execution</span></span>|<span data-ttu-id="22e49-123">Important.</span><span class="sxs-lookup"><span data-stu-id="22e49-123">Important.</span></span>|<span data-ttu-id="22e49-124">Peu important.</span><span class="sxs-lookup"><span data-stu-id="22e49-124">Low importance.</span></span>|  
|<span data-ttu-id="22e49-125">Contrôle de flux principal</span><span class="sxs-lookup"><span data-stu-id="22e49-125">Primary flow control</span></span>|<span data-ttu-id="22e49-126">Boucles, conditions et appels de fonctions (méthodes).</span><span class="sxs-lookup"><span data-stu-id="22e49-126">Loops, conditionals, and function (method) calls.</span></span>|<span data-ttu-id="22e49-127">Appels de fonctions, y compris la récursivité.</span><span class="sxs-lookup"><span data-stu-id="22e49-127">Function calls, including recursion.</span></span>|  
|<span data-ttu-id="22e49-128">Unité de manipulation principale</span><span class="sxs-lookup"><span data-stu-id="22e49-128">Primary manipulation unit</span></span>|<span data-ttu-id="22e49-129">Instances de structures ou classes.</span><span class="sxs-lookup"><span data-stu-id="22e49-129">Instances of structures or classes.</span></span>|<span data-ttu-id="22e49-130">Fonctions en tant que collectes de données et objets de première classe.</span><span class="sxs-lookup"><span data-stu-id="22e49-130">Functions as first-class objects and data collections.</span></span>|  
  
 <span data-ttu-id="22e49-131">Bien que la plupart des langages aient été conçus pour prendre en charge un paradigme de programmation spécifique, de nombreux langages généraux sont suffisamment flexibles pour prendre en charge plusieurs paradigmes.</span><span class="sxs-lookup"><span data-stu-id="22e49-131">Although most languages were designed to support a specific programming paradigm, many general languages are flexible enough to support multiple paradigms.</span></span> <span data-ttu-id="22e49-132">Par exemple, la plupart des langages qui contiennent des pointeurs fonction peuvent être utilisés pour prendre en charge de manière crédible la programmation fonctionnelle.</span><span class="sxs-lookup"><span data-stu-id="22e49-132">For example, most languages that contain function pointers can be used to credibly support functional programming.</span></span> <span data-ttu-id="22e49-133">En outre, C# inclut des extensions de langage explicites qui prennent en charge la programmation fonctionnelle, y compris les expressions lambda et l’inférence de type.</span><span class="sxs-lookup"><span data-stu-id="22e49-133">Furthermore, C# includes explicit language extensions to support functional programming, including lambda expressions and type inference.</span></span> <span data-ttu-id="22e49-134">La technologie LINQ est une forme de programmation déclarative fonctionnelle.</span><span class="sxs-lookup"><span data-stu-id="22e49-134">LINQ technology is a form of declarative, functional programming.</span></span>  
  
## <a name="functional-programming-using-xslt"></a><span data-ttu-id="22e49-135">Programmation fonctionnelle à l'aide de XSLT</span><span class="sxs-lookup"><span data-stu-id="22e49-135">Functional Programming Using XSLT</span></span>  
 <span data-ttu-id="22e49-136">De nombreux développeurs XSLT connaissent l'approche fonctionnelle pure.</span><span class="sxs-lookup"><span data-stu-id="22e49-136">Many XSLT developers are familiar with the pure functional approach.</span></span> <span data-ttu-id="22e49-137">La manière la plus efficace de développer une feuille de style XSLT consiste à traiter chaque modèle comme une transformation composable et isolée.</span><span class="sxs-lookup"><span data-stu-id="22e49-137">The most effective way to develop an XSLT style sheet is to treat each template as an isolated, composable transformation.</span></span> <span data-ttu-id="22e49-138">L'ordre d'exécution n'est pas du tout mis en évidence.</span><span class="sxs-lookup"><span data-stu-id="22e49-138">The order of execution is completely de-emphasized.</span></span> <span data-ttu-id="22e49-139">XSLT n'autorise pas les effets secondaires (hormis le fait que les mécanismes d'échappement pour l'exécution de procédures de code peuvent introduire des effets secondaires qui entraînent une impureté fonctionnelle).</span><span class="sxs-lookup"><span data-stu-id="22e49-139">XSLT does not allow side effects (with the exception that escaping mechanisms for executing procedural code can introduce side effects that result in functional impurity).</span></span> <span data-ttu-id="22e49-140">Toutefois, même si XSLT est un outil efficace, certaines de ses caractéristiques ne sont pas optimales.</span><span class="sxs-lookup"><span data-stu-id="22e49-140">However, although XSLT is an effective tool, some of its characteristics are not optimal.</span></span> <span data-ttu-id="22e49-141">Par exemple, l'expression de constructions de programmation en XML rend le code relativement détaillé, et par conséquent difficile à maintenir.</span><span class="sxs-lookup"><span data-stu-id="22e49-141">For example, expressing programming constructs in XML makes code relatively verbose, and therefore difficult to maintain.</span></span> <span data-ttu-id="22e49-142">De plus, la forte dépendance envers la récursivité pour le contrôle de flux peut nuire à la lisibilité du code.</span><span class="sxs-lookup"><span data-stu-id="22e49-142">Also, the heavy reliance on recursion for flow control can result in code that is hard to read.</span></span> <span data-ttu-id="22e49-143">Pour plus d’informations sur XSLT, consultez [Transformations XSLT](../../../../standard/data/xml/xslt-transformations.md).</span><span class="sxs-lookup"><span data-stu-id="22e49-143">For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).</span></span>  
  
 <span data-ttu-id="22e49-144">Toutefois, le langage XSLT a prouvé la valeur de l'utilisation d'une approche fonctionnelle pure pour la transformation de code XML d'une forme en une autre.</span><span class="sxs-lookup"><span data-stu-id="22e49-144">However, XSLT has proved the value of using a pure functional approach for transforming XML from one shape to another.</span></span> <span data-ttu-id="22e49-145">La programmation fonctionnelle pure à l'aide de LINQ to XML est semblable en de nombreux points au langage XSLT.</span><span class="sxs-lookup"><span data-stu-id="22e49-145">Pure functional programming with LINQ to XML is similar in many ways to XSLT.</span></span> <span data-ttu-id="22e49-146">Cependant, les constructions de programmation introduites par LINQ to XML et le langage C# vous permettent d’écrire des transformations fonctionnelles pures plus lisibles et gérables que XSLT.</span><span class="sxs-lookup"><span data-stu-id="22e49-146">However, the programming constructs introduced by LINQ to XML and C#  allow you to write pure functional transformations that are more readable and maintainable than XSLT.</span></span>  
  
## <a name="advantages-of-pure-functions"></a><span data-ttu-id="22e49-147">Avantages des fonctions pures</span><span class="sxs-lookup"><span data-stu-id="22e49-147">Advantages of Pure Functions</span></span>  
 <span data-ttu-id="22e49-148">La raison principale pour implémenter des transformations fonctionnelles en tant que fonctions pures est que celles-ci sont composables, autrement dit autonomes et sans état.</span><span class="sxs-lookup"><span data-stu-id="22e49-148">The primary reason to implement functional transformations as pure functions is that pure functions are composable: that is, self-contained and stateless.</span></span> <span data-ttu-id="22e49-149">Ces caractéristiques apportent un certain nombre d'avantages, notamment les suivants :</span><span class="sxs-lookup"><span data-stu-id="22e49-149">These characteristics bring a number of benefits, including the following:</span></span>  
  
-   <span data-ttu-id="22e49-150">Une meilleure lisibilité et facilité de maintenance.</span><span class="sxs-lookup"><span data-stu-id="22e49-150">Increased readability and maintainability.</span></span> <span data-ttu-id="22e49-151">Cela est dû au fait que chaque fonction est conçue pour accomplir une tâche spécifique étant donné ses arguments.</span><span class="sxs-lookup"><span data-stu-id="22e49-151">This is because each function is designed to accomplish a specific task given its arguments.</span></span> <span data-ttu-id="22e49-152">La fonction ne repose pas sur un état externe.</span><span class="sxs-lookup"><span data-stu-id="22e49-152">The function does not rely on any external state.</span></span>  
  
-   <span data-ttu-id="22e49-153">Un développement réitératif plus simple.</span><span class="sxs-lookup"><span data-stu-id="22e49-153">Easier reiterative development.</span></span> <span data-ttu-id="22e49-154">Le code étant plus facile à refactoriser, les modifications de conception sont souvent plus faciles à implémenter.</span><span class="sxs-lookup"><span data-stu-id="22e49-154">Because the code is easier to refactor, changes to design are often easier to implement.</span></span> <span data-ttu-id="22e49-155">Par exemple, supposez que vous écrivez une transformation compliquée et que vous vous rendez compte par la suite que du code est répété à plusieurs reprises dans la transformation.</span><span class="sxs-lookup"><span data-stu-id="22e49-155">For example, suppose you write a complicated transformation, and then realize that some code is repeated several times in the transformation.</span></span> <span data-ttu-id="22e49-156">Si vous refactorisez par le biais d'une méthode pure, vous pouvez appeler votre méthode pure comme bon vous semble sans vous soucier des effets secondaires.</span><span class="sxs-lookup"><span data-stu-id="22e49-156">If you refactor through a pure method, you can call your pure method at will without worrying about side effects.</span></span>  
  
-   <span data-ttu-id="22e49-157">Une plus grande facilité de test et de débogage.</span><span class="sxs-lookup"><span data-stu-id="22e49-157">Easier testing and debugging.</span></span> <span data-ttu-id="22e49-158">Les fonctions pures étant plus faciles à tester de manière isolée, vous pouvez écrire du code test qui appelle la fonction pure avec des valeurs typiques, des cases de bord valides et des cases de bord non valides.</span><span class="sxs-lookup"><span data-stu-id="22e49-158">Because pure functions can more easily be tested in isolation, you can write test code that calls the pure function with typical values, valid edge cases, and invalid edge cases.</span></span>  
  
## <a name="transitioning-for-oop-developers"></a><span data-ttu-id="22e49-159">Transition pour les développeurs OOP</span><span class="sxs-lookup"><span data-stu-id="22e49-159">Transitioning for OOP Developers</span></span>  
 <span data-ttu-id="22e49-160">Dans la programmation traditionnelle orientée objets (OOP), la plupart des développeurs sont habitués à programmer dans le style impératif/procédural.</span><span class="sxs-lookup"><span data-stu-id="22e49-160">In traditional object-oriented programming (OOP), most developers are accustomed to programming in the imperative/procedural style.</span></span> <span data-ttu-id="22e49-161">Pour passer au développement de style fonctionnel pur, ils doivent modifier leur manière de pensée et leur approche du développement.</span><span class="sxs-lookup"><span data-stu-id="22e49-161">To switch to developing in a pure functional style, they have to make a transition in their thinking and their approach to development.</span></span>  
  
 <span data-ttu-id="22e49-162">Pour résoudre les problèmes, les développeurs OOP conçoivent des hiérarchies de classes, se concentrent sur l'encapsulation correcte et pensent en termes de contrats de classes.</span><span class="sxs-lookup"><span data-stu-id="22e49-162">To solve problems, OOP developers design class hierarchies, focus on proper encapsulation, and think in terms of class contracts.</span></span> <span data-ttu-id="22e49-163">Le comportement et l'état des types d'objets sont essentiels et les caractéristiques de langage, telles que les classes, les interfaces, l'héritage et le polymorphisme, sont fournies pour mieux gérer ces problèmes.</span><span class="sxs-lookup"><span data-stu-id="22e49-163">The behavior and state of object types are paramount, and language features, such as classes, interfaces, inheritance, and polymorphism, are provided to address these concerns.</span></span>  
  
 <span data-ttu-id="22e49-164">Par contraste, la programmation fonctionnelle traite les problèmes de calcul comme un exercice d'évaluation de transformations fonctionnelles pures de collectes de données.</span><span class="sxs-lookup"><span data-stu-id="22e49-164">In contrast, functional programming approaches computational problems as an exercise in the evaluation of pure functional transformations of data collections.</span></span> <span data-ttu-id="22e49-165">La programmation fonctionnelle évite l'état et les données mutables, et insiste plutôt sur l'application de fonctions.</span><span class="sxs-lookup"><span data-stu-id="22e49-165">Functional programming avoids state and mutable data, and instead emphasizes the application of functions.</span></span>  
  
 <span data-ttu-id="22e49-166">Heureusement, les langages C# et Visual Basic ne nécessitent pas de transition totale vers la programmation fonctionnelle, car ils prennent en charge les approches de programmation impératives et fonctionnelles.</span><span class="sxs-lookup"><span data-stu-id="22e49-166">Fortunately, C# doesn't require the full leap to functional programming, because it supports both imperative and functional programming approaches.</span></span> <span data-ttu-id="22e49-167">Un développeur peut choisir quelle approche convient le mieux à un scénario particulier.</span><span class="sxs-lookup"><span data-stu-id="22e49-167">A developer can choose which approach is most appropriate for a particular scenario.</span></span> <span data-ttu-id="22e49-168">En fait, les programmes combinent souvent les deux approches.</span><span class="sxs-lookup"><span data-stu-id="22e49-168">In fact, programs often combine both approaches.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="22e49-169">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="22e49-169">See Also</span></span>  
 [<span data-ttu-id="22e49-170">Introduction aux transformations fonctionnelles pures (C#)</span><span class="sxs-lookup"><span data-stu-id="22e49-170">Introduction to Pure Functional Transformations (C#)</span></span>](../../../../csharp/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md)  
 [<span data-ttu-id="22e49-171">Transformations XSLT</span><span class="sxs-lookup"><span data-stu-id="22e49-171">XSLT Transformations</span></span>](../../../../standard/data/xml/xslt-transformations.md)  
 [<span data-ttu-id="22e49-172">Refactorisation dans des fonctions pures (C#)</span><span class="sxs-lookup"><span data-stu-id="22e49-172">Refactoring Into Pure Functions (C#)</span></span>](../../../../csharp/programming-guide/concepts/linq/refactoring-into-pure-functions.md)
