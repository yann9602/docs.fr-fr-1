---
title: "Syntaxe de requête et syntaxe de méthode dans LINQ (C#)"
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-csharp
ms.topic: article
dev_langs:
- CSharp
helpviewer_keywords:
- LINQ [C#], query syntax vs. method syntax
- queries [LINQ in C#], syntax comparisons
ms.assetid: eedd6dd9-fec2-428c-9581-5b8783810ded
caps.latest.revision: 30
author: BillWagner
ms.author: wiwagn
translation.priority.ht:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- ru-ru
- zh-cn
- zh-tw
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: 35ad7e9b086f36ca92974fdea197da4c513c8a51
ms.contentlocale: fr-fr
ms.lasthandoff: 07/28/2017

---
# <a name="query-syntax-and-method-syntax-in-linq-c"></a><span data-ttu-id="28632-102">Syntaxe de requête et syntaxe de méthode dans LINQ (C#)</span><span class="sxs-lookup"><span data-stu-id="28632-102">Query Syntax and Method Syntax in LINQ (C#)</span></span>
<span data-ttu-id="28632-103">La plupart des requêtes de la documentation de présentation de Langage Integrated Query ([!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]) sont écrites à l’aide de la syntaxe de requête déclarative de LINQ.</span><span class="sxs-lookup"><span data-stu-id="28632-103">Most queries in the introductory Language Integrated Query ([!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]) documentation are written by using the LINQ declarative query syntax.</span></span> <span data-ttu-id="28632-104">Toutefois, la syntaxe de requête doit être traduite en appels de méthode pour le Common Langage Runtime (CLR) .NET lorsque le code est compilé.</span><span class="sxs-lookup"><span data-stu-id="28632-104">However, the query syntax must be translated into method calls for the .NET common language runtime (CLR) when the code is compiled.</span></span> <span data-ttu-id="28632-105">Ces appels de méthode appellent les opérateurs de requête standard, qui ont des noms tels que `Where`, `Select`, `GroupBy`, `Join`, `Max` et `Average`.</span><span class="sxs-lookup"><span data-stu-id="28632-105">These method calls invoke the standard query operators, which have names such as `Where`, `Select`, `GroupBy`, `Join`, `Max`, and `Average`.</span></span> <span data-ttu-id="28632-106">Vous pouvez les appeler directement en utilisant la syntaxe de méthode à la place de la syntaxe de requête.</span><span class="sxs-lookup"><span data-stu-id="28632-106">You can call them directly by using method syntax instead of query syntax.</span></span>  
  
 <span data-ttu-id="28632-107">La syntaxe de requête et la syntaxe de méthode sont identiques sémantiquement, mais de nombreuses personnes trouvent la syntaxe de requête plus simple et plus facile à lire.</span><span class="sxs-lookup"><span data-stu-id="28632-107">Query syntax and method syntax are semantically identical, but many people find query syntax simpler and easier to read.</span></span> <span data-ttu-id="28632-108">Certaines requêtes doivent être exprimées en tant qu’appels de méthode.</span><span class="sxs-lookup"><span data-stu-id="28632-108">Some queries must be expressed as method calls.</span></span> <span data-ttu-id="28632-109">Par exemple, vous devez utiliser un appel de méthode pour exprimer une requête qui récupère le nombre d’éléments qui correspondent à une condition spécifiée.</span><span class="sxs-lookup"><span data-stu-id="28632-109">For example, you must use a method call to express a query that retrieves the number of elements that match a specified condition.</span></span> <span data-ttu-id="28632-110">Vous devez également utiliser un appel de méthode pour une requête qui récupère dans une séquence source l’élément qui a la valeur maximale.</span><span class="sxs-lookup"><span data-stu-id="28632-110">You also must use a method call for a query that retrieves the element that has the maximum value in a source sequence.</span></span> <span data-ttu-id="28632-111">En général, la documentation de référence des opérateurs de requête standard dans l’espace de noms <xref:System.Linq> utilise la syntaxe de méthode.</span><span class="sxs-lookup"><span data-stu-id="28632-111">The reference documentation for the standard query operators in the <xref:System.Linq> namespace generally uses method syntax.</span></span> <span data-ttu-id="28632-112">Par conséquent, même lorsque vous commencez à écrire des requêtes [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], il est utile de se familiariser avec l’utilisation de la syntaxe de méthode dans les requêtes et dans les expressions de requête elles-mêmes.</span><span class="sxs-lookup"><span data-stu-id="28632-112">Therefore, even when getting started writing [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] queries, it is useful to be familiar with how to use method syntax in queries and in query expressions themselves.</span></span>  
  
## <a name="standard-query-operator-extension-methods"></a><span data-ttu-id="28632-113">Méthodes d’extension d’opérateur de requête standard</span><span class="sxs-lookup"><span data-stu-id="28632-113">Standard Query Operator Extension Methods</span></span>  
 <span data-ttu-id="28632-114">L’exemple suivant présente une *expression de requête* simple et la requête sémantiquement équivalente écrite en tant que *requête fondée sur une méthode*.</span><span class="sxs-lookup"><span data-stu-id="28632-114">The following example shows a simple *query expression* and the semantically equivalent query written as a *method-based query*.</span></span>  
  
 <span data-ttu-id="28632-115">[!code-cs[csLINQGettingStarted#22](../../../../csharp/programming-guide/concepts/linq/codesnippet/CSharp/query-syntax-and-method-syntax-in-linq_1.cs)]</span><span class="sxs-lookup"><span data-stu-id="28632-115">[!code-cs[csLINQGettingStarted#22](../../../../csharp/programming-guide/concepts/linq/codesnippet/CSharp/query-syntax-and-method-syntax-in-linq_1.cs)]</span></span>  
  
 <span data-ttu-id="28632-116">La sortie des deux exemples est identique.</span><span class="sxs-lookup"><span data-stu-id="28632-116">The output from the two examples is identical.</span></span> <span data-ttu-id="28632-117">Vous pouvez voir que le type de la variable de requête est le même dans les deux formes : <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="28632-117">You can see that the type of the query variable is the same in both forms: <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="28632-118">Pour comprendre la requête basée sur une méthode, examinons-la de plus près.</span><span class="sxs-lookup"><span data-stu-id="28632-118">To understand the method-based query, let's examine it more closely.</span></span> <span data-ttu-id="28632-119">Du côté droit de l’expression, remarquez que la clause `where` est maintenant exprimée comme une méthode d’instance sur l’objet `numbers`, qui, comme vous vous en rappelez, a un type `IEnumerable<int>`.</span><span class="sxs-lookup"><span data-stu-id="28632-119">On the right side of the expression, notice that the `where` clause is now expressed as an instance method on the `numbers` object, which as you will recall has a type of `IEnumerable<int>`.</span></span> <span data-ttu-id="28632-120">Si vous êtes connaissez bien l’interface <xref:System.Collections.Generic.IEnumerable%601> générique, vous savez qu’elle n’a pas de méthode `Where`.</span><span class="sxs-lookup"><span data-stu-id="28632-120">If you are familiar with the generic <xref:System.Collections.Generic.IEnumerable%601> interface, you know that it does not have a `Where` method.</span></span> <span data-ttu-id="28632-121">Toutefois, si vous appelez la liste de saisie semi-automatique IntelliSense dans l’IDE de Visual Studio, vous ne verrez pas seulement une méthode `Where`, mais de nombreuses autres méthodes telles que `Select`, `SelectMany`, `Join` et `Orderby`.</span><span class="sxs-lookup"><span data-stu-id="28632-121">However, if you invoke the IntelliSense completion list in the Visual Studio IDE, you will see not only a `Where` method, but many other methods such as `Select`, `SelectMany`, `Join`, and `Orderby`.</span></span> <span data-ttu-id="28632-122">Il s’agit de tous les opérateurs de requête standard.</span><span class="sxs-lookup"><span data-stu-id="28632-122">These are all the standard query operators.</span></span>  
  
 <span data-ttu-id="28632-123">![Opérateurs de requête standard dans Intellisense](../../../../csharp/programming-guide/concepts/linq/media/standardqueryops.png "StandardQueryOps")</span><span class="sxs-lookup"><span data-stu-id="28632-123">![Standard Query Operators in Intellisense](../../../../csharp/programming-guide/concepts/linq/media/standardqueryops.png "StandardQueryOps")</span></span>  
  
 <span data-ttu-id="28632-124">Même s’il semble que <xref:System.Collections.Generic.IEnumerable%601> a été redéfini pour inclure ces méthodes supplémentaires, ce n’est pas le cas, en réalité.</span><span class="sxs-lookup"><span data-stu-id="28632-124">Although it looks as if <xref:System.Collections.Generic.IEnumerable%601> has been redefined to include these additional methods, in fact this is not the case.</span></span> <span data-ttu-id="28632-125">Les opérateurs de requête standard sont implémentés comme un nouveau type de méthode, appelé *méthodes d’extension*.</span><span class="sxs-lookup"><span data-stu-id="28632-125">The standard query operators are implemented as a new kind of method called *extension methods*.</span></span> <span data-ttu-id="28632-126">Les méthodes d’extension « étendent » un type existant. Elles peuvent être appelées comme s’il s’agissait de méthodes d’instance sur le type.</span><span class="sxs-lookup"><span data-stu-id="28632-126">Extensions methods "extend" an existing type; they can be called as if they were instance methods on the type.</span></span> <span data-ttu-id="28632-127">Les opérateurs de requête standard étendent <xref:System.Collections.Generic.IEnumerable%601>, si bien que vous pouvez écrire `numbers.Where(...)`.</span><span class="sxs-lookup"><span data-stu-id="28632-127">The standard query operators extend <xref:System.Collections.Generic.IEnumerable%601> and that is why you can write `numbers.Where(...)`.</span></span>  
  
 <span data-ttu-id="28632-128">Pour commencer à utiliser [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], tout ce que vous devez savoir sur les méthodes d’extension est la façon de les mettre à portée de votre application à l’aide des directives `using` appropriées.</span><span class="sxs-lookup"><span data-stu-id="28632-128">To get started using [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], all that you really have to know about extension methods is how to bring them into scope in your application by using the correct `using` directives.</span></span> <span data-ttu-id="28632-129">Du point de vue de votre application, une méthode d’extension et une méthode d’instance normale sont identiques.</span><span class="sxs-lookup"><span data-stu-id="28632-129">From your application's point of view, an extension method and a regular instance method are the same.</span></span>  
  
 <span data-ttu-id="28632-130">Pour plus d’informations sur les méthodes d’extension, consultez [Méthodes d’extension](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="28632-130">For more information about extension methods, see [Extension Methods](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md).</span></span> <span data-ttu-id="28632-131">Pour plus d’informations sur les opérateurs de requête standard, consultez [Présentation des opérateurs de requête standard (C#)](../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md).</span><span class="sxs-lookup"><span data-stu-id="28632-131">For more information about standard query operators, see [Standard Query Operators Overview (C#)](../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md).</span></span> <span data-ttu-id="28632-132">Certains fournisseurs [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], tels que [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] et [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], implémentent leurs propres opérateurs de requête standard et des méthodes d’extension supplémentaires pour d’autres types que <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="28632-132">Some [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] providers, such as [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] and [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], implement their own standard query operators and additional extension methods for other types besides <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
## <a name="lambda-expressions"></a><span data-ttu-id="28632-133">Expressions lambda</span><span class="sxs-lookup"><span data-stu-id="28632-133">Lambda Expressions</span></span>  
 <span data-ttu-id="28632-134">Dans l’exemple précédent, notez que l’expression conditionnelle (`num % 2 == 0`) est passée comme argument de ligne à la méthode `Where` : `Where(num => num % 2 == 0).` Cette expression inline est appelée expression lambda.</span><span class="sxs-lookup"><span data-stu-id="28632-134">In the previous example, notice that the conditional expression (`num % 2 == 0`) is passed as an in-line argument to the `Where` method: `Where(num => num % 2 == 0).` This inline expression is called a lambda expression.</span></span> <span data-ttu-id="28632-135">C’est un moyen pratique d’écrire du code qui devrait autrement être écrit sous une forme plus fastidieuse, comme une méthode anonyme, un délégué générique ou une arborescence d’expressions.</span><span class="sxs-lookup"><span data-stu-id="28632-135">It is a convenient way to write code that would otherwise have to be written in more cumbersome form as an anonymous method or a generic delegate or an expression tree.</span></span> <span data-ttu-id="28632-136">En C#, `=>` est l’opérateur lambda, qui se lit « conduit à ».</span><span class="sxs-lookup"><span data-stu-id="28632-136">In C# `=>` is the lambda operator, which is read as "goes to".</span></span> <span data-ttu-id="28632-137">Le `num` situé à gauche de l’opérateur est la variable d’entrée qui correspond à `num` dans l’expression de requête.</span><span class="sxs-lookup"><span data-stu-id="28632-137">The `num` on the left of the operator is the input variable which corresponds to `num` in the query expression.</span></span> <span data-ttu-id="28632-138">Le compilateur peut déduire le type de `num`, car il sait que `numbers` est un type <xref:System.Collections.Generic.IEnumerable%601> générique.</span><span class="sxs-lookup"><span data-stu-id="28632-138">The compiler can infer the type of `num` because it knows that `numbers` is a generic <xref:System.Collections.Generic.IEnumerable%601> type.</span></span> <span data-ttu-id="28632-139">Le corps de l’expression lambda est identique à l’expression dans la syntaxe de requête ou dans toute autre expression ou instruction C#. Il peut inclure des appels de méthode et une autre logique complexe.</span><span class="sxs-lookup"><span data-stu-id="28632-139">The body of the lambda is just the same as the expression in query syntax or in any other C# expression or statement; it can include method calls and other complex logic.</span></span> <span data-ttu-id="28632-140">La « valeur de retour » est simplement le résultat de l’expression.</span><span class="sxs-lookup"><span data-stu-id="28632-140">The "return value" is just the expression result.</span></span>  
  
 <span data-ttu-id="28632-141">Vous n’avez pas besoin d’utiliser fréquemment les expressions lambda pour commencer à utiliser [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)].</span><span class="sxs-lookup"><span data-stu-id="28632-141">To get started using [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], you do not have to use lambdas extensively.</span></span> <span data-ttu-id="28632-142">Toutefois, certaines requêtes peuvent être exprimées uniquement dans la syntaxe de méthode. Parmi elles, certaines nécessitent des expressions lambda.</span><span class="sxs-lookup"><span data-stu-id="28632-142">However, certain queries can only be expressed in method syntax and some of those require lambda expressions.</span></span> <span data-ttu-id="28632-143">Une fois que vous serez plus familiarisé avec les expressions lambda, vous constaterez qu’elles sont un outil puissant et flexible dans votre boîte à outils [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)].</span><span class="sxs-lookup"><span data-stu-id="28632-143">After you become more familiar with lambdas, you will find that they are a powerful and flexible tool in your [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] toolbox.</span></span> <span data-ttu-id="28632-144">Pour plus d’informations, voir [Expressions lambda](../../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="28632-144">For more information, see [Lambda Expressions](../../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span></span>  
  
## <a name="composability-of-queries"></a><span data-ttu-id="28632-145">Composabilité des requêtes</span><span class="sxs-lookup"><span data-stu-id="28632-145">Composability of Queries</span></span>  
 <span data-ttu-id="28632-146">Dans l’exemple de code précédent, notez que la méthode `OrderBy` est appelée à l’aide de l’opérateur point sur l’appel à `Where`.</span><span class="sxs-lookup"><span data-stu-id="28632-146">In the previous code example, note that the `OrderBy` method is invoked by using the dot operator on the call to `Where`.</span></span> <span data-ttu-id="28632-147">`Where` produit une séquence filtrée, puis `Orderby` agit sur cette séquence en la triant.</span><span class="sxs-lookup"><span data-stu-id="28632-147">`Where` produces a filtered sequence, and then `Orderby` operates on that sequence by sorting it.</span></span> <span data-ttu-id="28632-148">Étant donné que les requêtes retournent un `IEnumerable`, vous les composez dans la syntaxe de méthode en chaînant les appels de méthode ensemble.</span><span class="sxs-lookup"><span data-stu-id="28632-148">Because queries return an `IEnumerable`, you compose them in method syntax by chaining the method calls together.</span></span> <span data-ttu-id="28632-149">Le compilateur effectue cette opération en arrière-plan lorsque vous écrivez des requêtes à l’aide de la syntaxe de requête.</span><span class="sxs-lookup"><span data-stu-id="28632-149">This is what the compiler does behind the scenes when you write queries by using query syntax.</span></span> <span data-ttu-id="28632-150">De plus, étant donné qu’une variable de requête ne stocke pas les résultats de la requête, vous pouvez la modifier ou l’utiliser à tout moment comme base d’une nouvelle requête, même après son exécution.</span><span class="sxs-lookup"><span data-stu-id="28632-150">And because a query variable does not store the results of the query, you can modify it or use it as the basis for a new query at any time, even after it has been executed.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="28632-151">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="28632-151">See Also</span></span>  
 [<span data-ttu-id="28632-152">Bien démarrer avec LINQ en C#</span><span class="sxs-lookup"><span data-stu-id="28632-152">Getting Started with LINQ in C#</span></span>](../../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)

