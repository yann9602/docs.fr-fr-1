---
title: "Concepts de base des expressions de requête"
description: "Présente les concepts liés aux expressions de requête"
keywords: .NET, .NET Core, C#
author: BillWagner
manager: wpickett
ms.author: wiwagn
ms.date: 11/30/2016
ms.topic: article
ms.prod: .net-core
ms.technology: .net-core-technologies
ms.devlang: dotnet
ms.assetid: 027db1f8-346f-44d2-a16e-043fcea3a4e0
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: be8e2374f89366c6a98df900674a957bd2f531cc
ms.contentlocale: fr-fr
ms.lasthandoff: 07/28/2017

---
# <a name="query-expression-basics"></a><span data-ttu-id="b1a8f-104">Concepts de base des expressions de requête</span><span class="sxs-lookup"><span data-stu-id="b1a8f-104">Query expression basics</span></span>

## <a name="what-is-a-query-and-what-does-it-do"></a><span data-ttu-id="b1a8f-105">Qu’est-ce qu’une requête et quel est son rôle ?</span><span class="sxs-lookup"><span data-stu-id="b1a8f-105">What is a query and what does it do?</span></span> 

 <span data-ttu-id="b1a8f-106">Une *requête* est un jeu d’instructions qui décrit quelles données doivent être récupérées à partir d’une source (ou de sources) de données fournie, et quelles forme et organisation les données retournées doivent avoir.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-106">A *query* is a set of instructions that describes what data to retrieve from a given data source (or sources) and what shape and organization the returned data should have.</span></span> <span data-ttu-id="b1a8f-107">Une requête est distincte des résultats qu’elle génère.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-107">A query is distinct from the results that it produces.</span></span>  
  
 <span data-ttu-id="b1a8f-108">De manière générale, les données sources sont organisées logiquement comme une séquence d’éléments du même type.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-108">Generally, the source data is organized logically as a sequence of elements of the same kind.</span></span> <span data-ttu-id="b1a8f-109">Par exemple, une table de base de données SQL contient une séquence de lignes.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-109">For example, a SQL database table contains a sequence of rows.</span></span> <span data-ttu-id="b1a8f-110">Un fichier XML contient une « séquence » d’éléments XML (bien que ceux-ci soient organisés hiérarchiquement dans une arborescence).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-110">In an XML file, there is a "sequence" of XML elements (although these are organized hierarchically in a tree structure).</span></span> <span data-ttu-id="b1a8f-111">Une collection en mémoire contient une séquence d’objets.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-111">An in-memory collection contains a sequence of objects.</span></span> 
  
 <span data-ttu-id="b1a8f-112">Du point de vue d’une application, le type et la structure spécifiques des données sources d’origine ne sont pas importants.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-112">From an application's viewpoint, the specific type and structure of the original source data is not important.</span></span> <span data-ttu-id="b1a8f-113">L’application voit toujours les données sources comme une collection <xref:System.Collections.Generic.IEnumerable%601> ou <xref:System.Linq.IQueryable%601>.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-113">The application always sees the source data as an <xref:System.Collections.Generic.IEnumerable%601> or <xref:System.Linq.IQueryable%601> collection.</span></span> <span data-ttu-id="b1a8f-114">Par exemple, dans LINQ to XML, les données sources sont rendues visibles sous la forme d’un `IEnumerable`\<<xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-114">For example, in LINQ to XML, the source data is made visible as an `IEnumerable`\<<xref:System.Xml.Linq.XElement>>.</span></span>  
  
 <span data-ttu-id="b1a8f-115">Compte tenu de cette séquence source, une requête peut effectuer l’une des trois actions suivantes :</span><span class="sxs-lookup"><span data-stu-id="b1a8f-115">Given this source sequence, a query may do one of three things:</span></span>  
  
-   <span data-ttu-id="b1a8f-116">Récupérer un sous-ensemble des éléments pour générer une nouvelle séquence sans modifier les éléments individuels.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-116">Retrieve a subset of the elements to produce a new sequence without modifying the individual elements.</span></span> <span data-ttu-id="b1a8f-117">La requête peut alors trier ou regrouper la séquence retournée de plusieurs façons, comme indiqué dans l’exemple suivant (supposons que `scores` est un `int[]`) :</span><span class="sxs-lookup"><span data-stu-id="b1a8f-117">The query may then sort or group the returned sequence in various ways, as shown in the following example (assume `scores` is an `int[]`):</span></span>  
  
     <span data-ttu-id="b1a8f-118">[!code-cs[csrefQueryExpBasics#45](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_1.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-118">[!code-cs[csrefQueryExpBasics#45](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_1.cs)]</span></span>  
  
-   <span data-ttu-id="b1a8f-119">Récupérer une séquence d’éléments comme dans l’exemple précédent, mais les transformer en un nouveau type d’objet.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-119">Retrieve a sequence of elements as in the previous example but transform them to a new type of object.</span></span> <span data-ttu-id="b1a8f-120">Par exemple, une requête peut récupérer uniquement les noms de certains enregistrements de clients dans une source de données.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-120">For example, a query may retrieve only the last names from certain customer records in a data source.</span></span> <span data-ttu-id="b1a8f-121">Elle peut aussi récupérer l’enregistrement complet, puis l’utiliser pour construire un autre type d’objet en mémoire, voire des données XML, avant de générer la séquence de résultat final.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-121">Or it may retrieve the complete record and then use it to construct another in-memory object type or even XML data before generating the final result sequence.</span></span> <span data-ttu-id="b1a8f-122">L’exemple suivant affiche une projection d’un `int` en `string`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-122">The following example shows a projection from an `int` to a `string`.</span></span> <span data-ttu-id="b1a8f-123">Notez le nouveau type de `highScoresQuery`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-123">Note the new type of `highScoresQuery`.</span></span>  
  
     <span data-ttu-id="b1a8f-124">[!code-cs[csrefQueryExpBasics#46](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_2.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-124">[!code-cs[csrefQueryExpBasics#46](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_2.cs)]</span></span>  
  
-   <span data-ttu-id="b1a8f-125">Récupérer une valeur singleton sur les données sources, par exemple :</span><span class="sxs-lookup"><span data-stu-id="b1a8f-125">Retrieve a singleton value about the source data, such as:</span></span>  
  
    -   <span data-ttu-id="b1a8f-126">Nombre d’éléments qui correspondent à une certaine condition.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-126">The number of elements that match a certain condition.</span></span>  
  
    -   <span data-ttu-id="b1a8f-127">Élément qui a la valeur la plus grande ou la plus petite.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-127">The element that has the greatest or least value.</span></span>  
  
    -   <span data-ttu-id="b1a8f-128">Premier élément qui correspond à une condition, ou somme de valeurs particulières dans un jeu d’éléments spécifié.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-128">The first element that matches a condition, or the sum of particular values in a specified set of elements.</span></span> <span data-ttu-id="b1a8f-129">Par exemple, la requête suivante retourne le nombre de notes supérieures à 80 à partir du tableau d’entiers `scores` :</span><span class="sxs-lookup"><span data-stu-id="b1a8f-129">For example, the following query returns the number of scores greater than 80 from the `scores` integer array:</span></span>  
  
     <span data-ttu-id="b1a8f-130">[!code-cs[csrefQueryExpBasics#47](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_3.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-130">[!code-cs[csrefQueryExpBasics#47](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_3.cs)]</span></span>  
  
     <span data-ttu-id="b1a8f-131">Dans l’exemple précédent, notez l’utilisation de parenthèses autour de l’expression de requête avant l’appel à la méthode `Count`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-131">In the previous example, note the use of parentheses around the query expression before the call to the `Count` method.</span></span> <span data-ttu-id="b1a8f-132">Vous pouvez également exprimer ceci en utilisant une nouvelle variable pour stocker le résultat concret.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-132">You can also express this by using a new variable to store the concrete result.</span></span> <span data-ttu-id="b1a8f-133">Cette technique est plus explicite, car elle conserve la variable qui stocke la requête à un emplacement distinct de la requête qui stocke un résultat.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-133">This technique is more readable because it keeps the variable that stores the query separate from the query that stores a result.</span></span>  
  
     <span data-ttu-id="b1a8f-134">[!code-cs[csrefQueryExpBasics#48](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_4.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-134">[!code-cs[csrefQueryExpBasics#48](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_4.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-135">Dans l’exemple précédent, la requête est exécutée dans l’appel à `Count`, car `Count` doit effectuer une itération sur les résultats afin de déterminer le nombre d’éléments retournés par `highScoresQuery`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-135">In the previous example, the query is executed in the call to `Count`, because `Count` must iterate over the results in order to determine the number of elements returned by `highScoresQuery`.</span></span>  
  
## <a name="what-is-a-query-expression"></a><span data-ttu-id="b1a8f-136">Qu’est-ce qu’une expression de requête ?</span><span class="sxs-lookup"><span data-stu-id="b1a8f-136">What is a query expression?</span></span>  

 <span data-ttu-id="b1a8f-137">Une *expression de requête* est une requête exprimée dans la syntaxe de la requête.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-137">A *query expression* is a query expressed in query syntax.</span></span> <span data-ttu-id="b1a8f-138">Une expression de requête est une construction de langage de premier ordre.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-138">A query expression is a first-class language construct.</span></span> <span data-ttu-id="b1a8f-139">Elle est similaire à toute autre expression et peut être utilisée dans tous les contextes dans lesquels une expression C# est valide.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-139">It is just like any other expression and can be used in any context in which a C# expression is valid.</span></span> <span data-ttu-id="b1a8f-140">Une expression de requête se compose d’un jeu de clauses écrit dans une syntaxe déclarative semblable à du SQL ou du XQuery.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-140">A query expression consists of a set of clauses written in a declarative syntax similar to SQL or XQuery.</span></span> <span data-ttu-id="b1a8f-141">Chaque clause contient à son tour une ou plusieurs expressions C#, et ces expressions peuvent elles-mêmes être une expression de requête ou contenir une expression de requête.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-141">Each clause in turn contains one or more C# expressions, and these expressions may themselves be either a query expression or contain a query expression.</span></span>  
  
 <span data-ttu-id="b1a8f-142">Une expression de requête doit commencer par une clause [from](../language-reference/keywords/from-clause.md) et doit se terminer par une clause [select](../language-reference/keywords/select-clause.md) ou [group](../language-reference/keywords/group-clause.md).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-142">A query expression must begin with a [from](../language-reference/keywords/from-clause.md) clause and must end with a [select](../language-reference/keywords/select-clause.md) or [group](../language-reference/keywords/group-clause.md) clause.</span></span> <span data-ttu-id="b1a8f-143">Entre la première clause `from` et la dernière clause `select` ou `group`, elle peut contenir une ou plusieurs clauses facultatives : [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) et même d’autres clauses [from](../language-reference/keywords/from-clause.md).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-143">Between the first `from` clause and the last `select` or `group` clause, it can contain one or more of these optional clauses: [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) and even additional [from](../language-reference/keywords/from-clause.md) clauses.</span></span> <span data-ttu-id="b1a8f-144">Vous pouvez également utiliser le mot clé [into](../language-reference/keywords/into.md) pour que le résultat d’une clause `join` ou `group` puisse servir de source pour des clauses de requête supplémentaires dans la même expression de requête.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-144">You can also use the [into](../language-reference/keywords/into.md) keyword to enable the result of a `join` or `group` clause to serve as the source for additional query clauses in the same query expression.</span></span>  
  
### <a name="query-variable"></a><span data-ttu-id="b1a8f-145">Variable de requête</span><span class="sxs-lookup"><span data-stu-id="b1a8f-145">Query variable</span></span>  
 
 <span data-ttu-id="b1a8f-146">Dans LINQ, une variable de requête correspond à n’importe quelle variable qui stocke une *requête* au lieu des *résultats* d’une requête.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-146">In LINQ, a query variable is any variable that stores a *query* instead of the *results* of a query.</span></span> <span data-ttu-id="b1a8f-147">Plus spécifiquement, une variable de requête est toujours un type énumérable qui produit une séquence d’éléments quand elle est itérée dans une instruction `foreach` ou un appel direct à sa méthode `IEnumerator.MoveNext`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-147">More specifically, a query variable is always an enumerable type that will produce a sequence of elements when it is iterated over in a `foreach` statement or a direct call to its `IEnumerator.MoveNext` method.</span></span>  
  
 <span data-ttu-id="b1a8f-148">L’exemple de code suivant montre une expression de requête simple avec une source de données, une clause de filtrage, une clause de classement et aucune transformation des éléments sources.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-148">The following code example shows a simple query expression with one data source, one filtering clause, one ordering clause, and no transformation of the source elements.</span></span> <span data-ttu-id="b1a8f-149">La clause `select` termine la requête.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-149">The `select` clause ends the query.</span></span>  
  
 <span data-ttu-id="b1a8f-150">[!code-cs[csrefQueryExpBasics#49](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_5.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-150">[!code-cs[csrefQueryExpBasics#49](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_5.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-151">Dans l’exemple précédent, `scoreQuery` est une *variable de requête* qui est parfois désignée simplement sous le nom de *requête*.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-151">In the previous example, `scoreQuery` is a *query variable,* which is sometimes referred to as just a *query*.</span></span> <span data-ttu-id="b1a8f-152">La variable de requête ne stocke aucune donnée de résultat réelle, générée dans la boucle `foreach`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-152">The query variable stores no actual result data, which is produced in the `foreach` loop.</span></span> <span data-ttu-id="b1a8f-153">De plus, quand l’instruction `foreach` s’exécute, les résultats de la requête ne sont pas retournés via la variable de requête `scoreQuery`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-153">And when the `foreach` statement executes, the query results are not returned through the query variable `scoreQuery`.</span></span> <span data-ttu-id="b1a8f-154">Au lieu de cela, ils sont retournés via la variable d’itération `testScore`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-154">Rather, they are returned through the iteration variable `testScore`.</span></span> <span data-ttu-id="b1a8f-155">La variable `scoreQuery` peut être itérée dans une deuxième boucle `foreach`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-155">The `scoreQuery` variable can be iterated in a second `foreach` loop.</span></span> <span data-ttu-id="b1a8f-156">Elle générera les mêmes résultats tant que ni elle ni la source de données ne sont modifiées.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-156">It will produce the same results as long as neither it nor the data source has been modified.</span></span>  
  
 <span data-ttu-id="b1a8f-157">Une variable de requête peut stocker une requête exprimée dans la syntaxe de requête ou dans la syntaxe de méthode, ou dans une combinaison des deux.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-157">A query variable may store a query that is expressed in query syntax or method syntax, or a combination of the two.</span></span> <span data-ttu-id="b1a8f-158">Dans les exemples suivants, `queryMajorCities` et `queryMajorCities2` sont des variables de requête :</span><span class="sxs-lookup"><span data-stu-id="b1a8f-158">In the following examples, both `queryMajorCities` and `queryMajorCities2` are query variables:</span></span>  
  
 <span data-ttu-id="b1a8f-159">[!code-cs[csrefQueryExpBasics#50](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_6.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-159">[!code-cs[csrefQueryExpBasics#50](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_6.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-160">En revanche, les deux exemples suivants affichent des variables qui ne sont pas des variables de requête, même si chacune d’entre elles est initialisée avec une requête.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-160">On the other hand, the following two examples show variables that are not query variables even through each is initialized with a query.</span></span> <span data-ttu-id="b1a8f-161">Il ne s’agit pas de variables de requête, car elles stockent des résultats :</span><span class="sxs-lookup"><span data-stu-id="b1a8f-161">They are not query variables because they store results:</span></span>  
  
 <span data-ttu-id="b1a8f-162">[!code-cs[csrefQueryExpBasics#51](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_7.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-162">[!code-cs[csrefQueryExpBasics#51](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_7.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-163">Pour plus d’informations sur les différents modes d’expression de requêtes, consultez [Syntaxe de requête et syntaxe de méthode dans LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-163">For more information about the different ways to express queries, see [Query syntax and method syntax in LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span></span>  
  
#### <a name="explicit-and-implicit-typing-of-query-variables"></a><span data-ttu-id="b1a8f-164">Types explicites et implicites de variables de requête</span><span class="sxs-lookup"><span data-stu-id="b1a8f-164">Explicit and implicit typing of query variables</span></span>  
 
 <span data-ttu-id="b1a8f-165">Cette documentation fournit généralement le type explicite de la variable de requête pour afficher la relation de type entre la variable de requête et la [clause select](../language-reference/keywords/select-clause.md).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-165">This documentation usually provides the explicit type of the query variable in order to show the type relationship between the query variable and the [select clause](../language-reference/keywords/select-clause.md).</span></span> <span data-ttu-id="b1a8f-166">Toutefois, vous pouvez également utiliser le mot clé [var](../language-reference/keywords/var.md) pour indiquer au compilateur de déduire le type d’une variable de requête (ou toute autre variable locale) au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-166">However, you can also use the [var](../language-reference/keywords/var.md) keyword to instruct the compiler to infer the type of a query variable (or any other local variable) at compile time.</span></span> <span data-ttu-id="b1a8f-167">Par exemple, l’exemple de requête expliqué précédemment dans cette rubrique peut également être exprimé à l’aide de types implicites :</span><span class="sxs-lookup"><span data-stu-id="b1a8f-167">For example, the query example that was shown previously in this topic can also be expressed by using implicit typing:</span></span>  
  
 <span data-ttu-id="b1a8f-168">[!code-cs[csrefQueryExpBasics#52](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_8.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-168">[!code-cs[csrefQueryExpBasics#52](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_8.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-169">Pour plus d’informations, consultez [Variables locales implicitement typées](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) et [Relations des types dans des opérations de requête LINQ](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-169">For more information, see [Implicitly typed local variables](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) and [Type relationships in LINQ query operations](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span></span>  
  
### <a name="starting-a-query-expression"></a><span data-ttu-id="b1a8f-170">Démarrage d’une expression de requête</span><span class="sxs-lookup"><span data-stu-id="b1a8f-170">Starting a query expression</span></span>  
 
 <span data-ttu-id="b1a8f-171">Une expression de requête doit commencer par une clause `from`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-171">A query expression must begin with a `from` clause.</span></span> <span data-ttu-id="b1a8f-172">Elle spécifie une source de données avec une variable de portée.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-172">It specifies a data source together with a range variable.</span></span> <span data-ttu-id="b1a8f-173">La variable de portée représente chaque élément consécutif dans la séquence source comme la séquence source parcourue.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-173">The range variable represents each successive element in the source sequence as the source sequence is being traversed.</span></span> <span data-ttu-id="b1a8f-174">La variable de portée est fortement typée selon le type d’éléments dans la source de données.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-174">The range variable is strongly typed based on the type of elements in the data source.</span></span> <span data-ttu-id="b1a8f-175">Dans l’exemple suivant, comme `countries` est un tableau d’objets `Country`, la variable de portée est également de type `Country`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-175">In the following example, because `countries` is an array of `Country` objects, the range variable is also typed as `Country`.</span></span> <span data-ttu-id="b1a8f-176">Étant donné que la variable de portée est fortement typée, vous pouvez utiliser l’opérateur point pour accéder à tous les membres disponibles du type.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-176">Because the range variable is strongly typed, you can use the dot operator to access any available members of the type.</span></span>  
  
 <span data-ttu-id="b1a8f-177">[!code-cs[csrefQueryExpBasics#53](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_9.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-177">[!code-cs[csrefQueryExpBasics#53](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_9.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-178">La variable de portée est dans la portée tant que la requête n’est pas quittée avec un point-virgule ou une clause *continuation*.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-178">The range variable is in scope until the query is exited either with a semicolon or with a *continuation* clause.</span></span>  
  
 <span data-ttu-id="b1a8f-179">Une expression de requête peut contenir plusieurs clauses `from`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-179">A query expression may contain multiple `from` clauses.</span></span> <span data-ttu-id="b1a8f-180">Utilisez des clauses `from` supplémentaires quand chaque élément de la séquence source est lui-même une collection ou contient une collection.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-180">Use additional `from` clauses when each element in the source sequence is itself a collection or contains a collection.</span></span> <span data-ttu-id="b1a8f-181">Par exemple, supposons que vous avez une collection d’objets `Country` et que chacun d’entre eux contient une collection d’objets `City` nommés `Cities`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-181">For example, assume that you have a collection of `Country` objects, each of which contains a collection of `City` objects named `Cities`.</span></span> <span data-ttu-id="b1a8f-182">Pour interroger les objets `City` dans chaque `Country`, utilisez deux clauses `from` comme indiqué ici :</span><span class="sxs-lookup"><span data-stu-id="b1a8f-182">To query the `City` objects in each `Country`, use two `from` clauses as shown here:</span></span>  
  
 <span data-ttu-id="b1a8f-183">[!code-cs[csrefQueryExpBasics#54](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_10.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-183">[!code-cs[csrefQueryExpBasics#54](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_10.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-184">Pour plus d’informations, consultez [from, clause](../language-reference/keywords/from-clause.md).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-184">For more information, see [from clause](../language-reference/keywords/from-clause.md).</span></span>  
  
### <a name="ending-a-query-expression"></a><span data-ttu-id="b1a8f-185">Fin d’une expression de requête</span><span class="sxs-lookup"><span data-stu-id="b1a8f-185">Ending a query expression</span></span>  
 
 <span data-ttu-id="b1a8f-186">Une expression de requête doit se terminer par une clause `group` ou une clause `select`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-186">A query expression must end with either a `group` clause or a `select` clause.</span></span>  
  
#### <a name="group-clause"></a><span data-ttu-id="b1a8f-187">group, clause</span><span class="sxs-lookup"><span data-stu-id="b1a8f-187">group clause</span></span>  
 
 <span data-ttu-id="b1a8f-188">Utilisez la clause `group` pour générer une séquence de groupes organisée par une clé que vous spécifiez.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-188">Use the `group` clause to produce a sequence of groups organized by a key that you specify.</span></span> <span data-ttu-id="b1a8f-189">La clé peut correspondre à tout type de données.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-189">The key can be any data type.</span></span> <span data-ttu-id="b1a8f-190">Par exemple, la requête suivante crée une séquence de groupes qui contient un ou plusieurs objets `Country` dont la clé est une valeur `char`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-190">For example, the following query creates a sequence of groups that contains one or more `Country` objects and whose key is a `char` value.</span></span>  
  
 <span data-ttu-id="b1a8f-191">[!code-cs[csrefQueryExpBasics#55](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_11.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-191">[!code-cs[csrefQueryExpBasics#55](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_11.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-192">Pour plus d’informations sur le regroupement, consultez [group, clause](../language-reference/keywords/group-clause.md).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-192">For more information about grouping, see [group clause](../language-reference/keywords/group-clause.md).</span></span>  
  
#### <a name="select-clause"></a><span data-ttu-id="b1a8f-193">select, clause</span><span class="sxs-lookup"><span data-stu-id="b1a8f-193">select clause</span></span>  
 <span data-ttu-id="b1a8f-194">Utilisez la clause `select` pour générer tous les autres types de séquences.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-194">Use the `select` clause to produce all other types of sequences.</span></span> <span data-ttu-id="b1a8f-195">Une clause `select` simple génère simplement une séquence du même type d’objets que les objets contenus dans la source de données.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-195">A simple `select` clause just produces a sequence of the same type of objects as the objects that are contained in the data source.</span></span> <span data-ttu-id="b1a8f-196">Dans cet exemple, la source de données contient des objets `Country`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-196">In this example, the data source contains `Country` objects.</span></span> <span data-ttu-id="b1a8f-197">La clause `orderby` trie simplement les éléments dans un nouvel ordre et la clause `select` génère une séquence des objets `Country` réorganisés.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-197">The `orderby` clause just sorts the elements into a new order and the `select` clause produces a sequence of the reordered `Country` objects.</span></span>  
  
 <span data-ttu-id="b1a8f-198">[!code-cs[csrefQueryExpBasics#56](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_12.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-198">[!code-cs[csrefQueryExpBasics#56](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_12.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-199">La clause `select` peut être utilisée pour transformer des données sources en séquences de nouveaux types.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-199">The `select` clause can be used to transform source data into sequences of new types.</span></span> <span data-ttu-id="b1a8f-200">Cette transformation est également appelée *projection*.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-200">This transformation is also named a *projection*.</span></span> <span data-ttu-id="b1a8f-201">Dans l’exemple suivant, la clause `select` *projette* une séquence de types anonymes qui contient uniquement un sous-ensemble des champs dans l’élément d’origine.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-201">In the following example, the `select` clause *projects* a sequence of anonymous types which contains only a subset of the fields in the original element.</span></span> <span data-ttu-id="b1a8f-202">Notez que les nouveaux objets sont initialisés à l’aide d’un initialiseur d’objet.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-202">Note that the new objects are initialized by using an object initializer.</span></span>  
  
 <span data-ttu-id="b1a8f-203">[!code-cs[csrefQueryExpBasics#57](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_13.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-203">[!code-cs[csrefQueryExpBasics#57](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_13.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-204">Pour plus d’informations sur toutes les façons d’utiliser une clause `select` pour transformer des données sources, consultez [select, clause](../language-reference/keywords/select-clause.md).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-204">For more information about all the ways that a `select` clause can be used to transform source data, see [select clause](../language-reference/keywords/select-clause.md).</span></span>  
  
#### <a name="continuations-with-into"></a><span data-ttu-id="b1a8f-205">Continuations avec « into »</span><span class="sxs-lookup"><span data-stu-id="b1a8f-205">Continuations with "into"</span></span>  
 
 <span data-ttu-id="b1a8f-206">Vous pouvez utiliser le mot clé `into` dans une clause `select` ou `group` pour créer un identificateur temporaire qui stocke une requête.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-206">You can use the `into` keyword in a `select` or `group` clause to create a temporary identifier that stores a query.</span></span> <span data-ttu-id="b1a8f-207">Procédez ainsi quand vous devez effectuer des opérations de requête supplémentaires sur une requête après une opération de regroupement ou de sélection.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-207">Do this when you must perform additional query operations on a query after a grouping or select operation.</span></span> <span data-ttu-id="b1a8f-208">Dans l’exemple suivant, les `countries` sont regroupés en fonction du remplissage, par plages de 10 millions.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-208">In the following example `countries` are grouped according to population in ranges of 10 million.</span></span> <span data-ttu-id="b1a8f-209">Une fois ces groupes créés, des clauses supplémentaires éliminent des groupes par filtrage, puis trient les groupes par ordre croissant.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-209">After these groups are created, additional clauses filter out some groups, and then to sort the groups in ascending order.</span></span> <span data-ttu-id="b1a8f-210">Pour effectuer ces opérations supplémentaires, la continuation représentée par `countryGroup` est requise.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-210">To perform those additional operations, the continuation represented by `countryGroup` is required.</span></span>  
  
 <span data-ttu-id="b1a8f-211">[!code-cs[csrefQueryExpBasics#58](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_14.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-211">[!code-cs[csrefQueryExpBasics#58](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_14.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-212">Pour plus d’informations, consultez [into](../language-reference/keywords/into.md).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-212">For more information, see [into](../language-reference/keywords/into.md).</span></span>  
  
### <a name="filtering-ordering-and-joining"></a><span data-ttu-id="b1a8f-213">Filtrage, classement et jointure</span><span class="sxs-lookup"><span data-stu-id="b1a8f-213">Filtering, ordering, and joining</span></span>

 <span data-ttu-id="b1a8f-214">Entre la clause `from` initiale et la clause `select` ou `group` finale, toutes les autres clauses (`where`, `join`, `orderby`, `from`, `let`) sont facultatives.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-214">Between the starting `from` clause, and the ending `select` or `group` clause, all other clauses (`where`, `join`, `orderby`, `from`, `let`) are optional.</span></span> <span data-ttu-id="b1a8f-215">Chacune des clauses facultatives peut être utilisée zéro fois ou plusieurs fois dans un corps de requête.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-215">Any of the optional clauses may be used zero times or multiple times in a query body.</span></span>  
  
#### <a name="where-clause"></a><span data-ttu-id="b1a8f-216">where, clause</span><span class="sxs-lookup"><span data-stu-id="b1a8f-216">where clause</span></span>  

 <span data-ttu-id="b1a8f-217">Utilisez la clause `where` pour éliminer par filtrage des éléments des données sources selon une ou plusieurs expressions de prédicat.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-217">Use the `where` clause to filter out elements from the source data based on one or more predicate expressions.</span></span> <span data-ttu-id="b1a8f-218">La clause `where` de l’exemple suivant a un prédicat avec deux conditions.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-218">The `where` clause in the following example has one predicate with two conditions.</span></span>  
  
 <span data-ttu-id="b1a8f-219">[!code-cs[csrefQueryExpBasics#59](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_15.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-219">[!code-cs[csrefQueryExpBasics#59](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_15.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-220">Pour plus d’informations, consultez [where, clause](../language-reference/keywords/where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-220">For more information, see [where clause](../language-reference/keywords/where-clause.md).</span></span>  
  
#### <a name="orderby-clause"></a><span data-ttu-id="b1a8f-221">orderby, clause</span><span class="sxs-lookup"><span data-stu-id="b1a8f-221">orderby clause</span></span>

 <span data-ttu-id="b1a8f-222">Utilisez la clause `orderby` pour trier les résultats par ordre croissant ou décroissant.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-222">Use the `orderby` clause to sort the results in either ascending or descending order.</span></span> <span data-ttu-id="b1a8f-223">Vous pouvez également spécifier des ordres de tri secondaires.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-223">You can also specify secondary sort orders.</span></span> <span data-ttu-id="b1a8f-224">L’exemple suivant effectue un tri principal sur les objets `country` en utilisant la propriété `Area`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-224">The following example performs a primary sort on the `country` objects by using the `Area` property.</span></span> <span data-ttu-id="b1a8f-225">Il effectue ensuite un tri secondaire en utilisant la propriété `Population`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-225">It then performs a secondary sort by using the `Population` property.</span></span>  
  
 <span data-ttu-id="b1a8f-226">[!code-cs[csrefQueryExpBasics#60](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_16.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-226">[!code-cs[csrefQueryExpBasics#60](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_16.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-227">Le mot clé `ascending` est facultatif ; il s’agit de l’ordre de tri par défaut si aucun ordre n’est spécifié.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-227">The `ascending` keyword is optional; it is the default sort order if no order is specified.</span></span> <span data-ttu-id="b1a8f-228">Pour plus d’informations, consultez [orderby, clause](../language-reference/keywords/orderby-clause.md).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-228">For more information, see [orderby clause](../language-reference/keywords/orderby-clause.md).</span></span>  
  
#### <a name="join-clause"></a><span data-ttu-id="b1a8f-229">join, clause</span><span class="sxs-lookup"><span data-stu-id="b1a8f-229">join clause</span></span>

 <span data-ttu-id="b1a8f-230">Utilisez la clause `join` pour associer et/ou combiner des éléments d’une source de données avec des éléments d’une autre source de données en fonction d’une comparaison d’égalité entre des clés spécifiées dans chaque élément.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-230">Use the `join` clause to associate and/or combine elements from one data source with elements from another data source based on an equality comparison between specified keys in each element.</span></span> <span data-ttu-id="b1a8f-231">Dans LINQ, les opérations de jointure sont effectuées sur les séquences des objets dont les éléments sont des types différents.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-231">In LINQ, join operations are performed on sequences of objects whose elements are different types.</span></span> <span data-ttu-id="b1a8f-232">Après avoir joint deux séquences, vous devez utiliser une instruction `select` ou `group` pour spécifier quel élément stocker dans la séquence de sortie.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-232">After you have joined two sequences, you must use a `select` or `group` statement to specify which element to store in the output sequence.</span></span> <span data-ttu-id="b1a8f-233">Vous pouvez également utiliser un type anonyme pour combiner des propriétés de chaque jeu d’éléments associés dans un nouveau type pour la séquence de sortie.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-233">You can also use an anonymous type to combine properties from each set of associated elements into a new type for the output sequence.</span></span> <span data-ttu-id="b1a8f-234">L’exemple suivant associe des objets `prod` dont la propriété `Category` correspond à l’une des catégories dans le tableau de chaînes `categories`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-234">The following example associates `prod` objects whose `Category` property matches one of the categories in the `categories` string array.</span></span> <span data-ttu-id="b1a8f-235">Les produits dont la propriété `Category` ne correspond pas à une chaîne quelconque dans `categories` sont éliminés par filtrage.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-235">Products whose `Category` does not match any string in `categories` are filtered out.</span></span> <span data-ttu-id="b1a8f-236">L’instruction `select` projette un nouveau type dont les propriétés sont extraites de `cat` et de `prod`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-236">The `select` statement projects a new type whose properties are taken from both `cat` and `prod`.</span></span>  
  
 <span data-ttu-id="b1a8f-237">[!code-cs[csrefQueryExpBasics#61](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_17.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-237">[!code-cs[csrefQueryExpBasics#61](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_17.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-238">Vous pouvez également effectuer une jointure groupée en stockant les résultats de l’opération `join` dans une variable temporaire à l’aide du mot clé [into](../language-reference/keywords/into.md).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-238">You can also perform a group join by storing the results of the `join` operation into a temporary variable by using the [into](../language-reference/keywords/into.md) keyword.</span></span> <span data-ttu-id="b1a8f-239">Pour plus d’informations, consultez [join, clause](../language-reference/keywords/join-clause.md).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-239">For more information, see [join clause](../language-reference/keywords/join-clause.md).</span></span>  
  
#### <a name="let-clause"></a><span data-ttu-id="b1a8f-240">let, clause</span><span class="sxs-lookup"><span data-stu-id="b1a8f-240">let clause</span></span> 

 <span data-ttu-id="b1a8f-241">Utilisez la clause `let` pour stocker le résultat d’une expression telle qu’un appel de méthode dans une nouvelle variable de portée.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-241">Use the `let` clause to store the result of an expression, such as a method call, in a new range variable.</span></span> <span data-ttu-id="b1a8f-242">Dans l’exemple suivant, la variable de portée `firstName` stocke le premier élément du tableau de chaînes retourné par `Split`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-242">In the following example, the range variable `firstName` stores the first element of the array of strings that is returned by `Split`.</span></span>  
  
 <span data-ttu-id="b1a8f-243">[!code-cs[csrefQueryExpBasics#62](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_18.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-243">[!code-cs[csrefQueryExpBasics#62](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_18.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-244">Pour plus d’informations, consultez [let, clause](../language-reference/keywords/let-clause.md).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-244">For more information, see [let clause](../language-reference/keywords/let-clause.md).</span></span>  
  
### <a name="subqueries-in-a-query-expression"></a><span data-ttu-id="b1a8f-245">Sous-requêtes dans une expression de requête</span><span class="sxs-lookup"><span data-stu-id="b1a8f-245">Subqueries in a query expression</span></span>  

 <span data-ttu-id="b1a8f-246">Une clause de requête peut elle-même contenir une expression de requête, qui est parfois connue sous le nom de *sous-requête*.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-246">A query clause may itself contain a query expression, which is sometimes referred to as a *subquery*.</span></span> <span data-ttu-id="b1a8f-247">Chaque sous-requête démarre avec sa propre clause `from` qui ne pointe pas nécessairement vers la même source de données dans la première clause `from`.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-247">Each subquery starts with its own `from` clause that does not necessarily point to the same data source in the first `from` clause.</span></span> <span data-ttu-id="b1a8f-248">Par exemple, la requête suivante montre une expression de requête utilisée dans l’instruction select pour récupérer les résultats d’une opération de regroupement.</span><span class="sxs-lookup"><span data-stu-id="b1a8f-248">For example, the following query shows a query expression that is used in the select statement to retrieve the results of a grouping operation.</span></span>  
  
 <span data-ttu-id="b1a8f-249">[!code-cs[csrefQueryExpBasics#63](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_19.cs)]</span><span class="sxs-lookup"><span data-stu-id="b1a8f-249">[!code-cs[csrefQueryExpBasics#63](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_19.cs)]</span></span>  
  
 <span data-ttu-id="b1a8f-250">Pour plus d’informations, consultez [Guide pratique pour effectuer une sous-requête sur une opération de regroupement](perform-a-subquery-on-a-grouping-operation.md).</span><span class="sxs-lookup"><span data-stu-id="b1a8f-250">For more information, see [How to: perform a subquery on a grouping operation](perform-a-subquery-on-a-grouping-operation.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b1a8f-251">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="b1a8f-251">See Also</span></span>  
 <span data-ttu-id="b1a8f-252">[Guide de programmation C#](../programming-guide/index.md) </span><span class="sxs-lookup"><span data-stu-id="b1a8f-252">[C# programming guide](../programming-guide/index.md) </span></span>  
 <span data-ttu-id="b1a8f-253">[Expressions de requête LINQ](index.md) </span><span class="sxs-lookup"><span data-stu-id="b1a8f-253">[LINQ query expressions](index.md) </span></span>  
 <span data-ttu-id="b1a8f-254">[Mots clés de requête (LINQ)](../language-reference/keywords/query-keywords.md) </span><span class="sxs-lookup"><span data-stu-id="b1a8f-254">[Query keywords (LINQ)](../language-reference/keywords/query-keywords.md) </span></span>  
 [<span data-ttu-id="b1a8f-255">Vue d’ensemble des opérateurs de requête standard</span><span class="sxs-lookup"><span data-stu-id="b1a8f-255">Standard query operators overview</span></span>](../programming-guide/concepts/linq/standard-query-operators-overview.md)

