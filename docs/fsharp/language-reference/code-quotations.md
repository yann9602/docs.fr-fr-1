---
title: Quotations de code (F#)
description: "En savoir plus sur F # quotations de code, une fonctionnalité de langage qui vous permet de générer et d’utiliser des expressions de code F # par programmation."
keywords: visual f#, f#, programmation fonctionnelle
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: 4559e659-2b04-48bd-8a0b-8527920eec95
ms.openlocfilehash: f7a08013bc6487b570a62576bb01ca2dd65ce8b1
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/18/2017
---
# <a name="code-quotations"></a><span data-ttu-id="8c82f-104">Quotations de code</span><span class="sxs-lookup"><span data-stu-id="8c82f-104">Code Quotations</span></span>

> [!NOTE]
<span data-ttu-id="8c82f-105">Le lien des informations de référence sur les API pointe vers MSDN.</span><span class="sxs-lookup"><span data-stu-id="8c82f-105">The API reference link will take you to MSDN.</span></span>  <span data-ttu-id="8c82f-106">Les informations de référence sur les API docs.microsoft.com ne sont pas terminées.</span><span class="sxs-lookup"><span data-stu-id="8c82f-106">The docs.microsoft.com API reference is not complete.</span></span>

<span data-ttu-id="8c82f-107">Cette rubrique décrit *quotations de code*, une fonctionnalité de langage qui vous permet de générer et d’utiliser des expressions de code F # par programmation.</span><span class="sxs-lookup"><span data-stu-id="8c82f-107">This topic describes *code quotations*, a language feature that enables you to generate and work with F# code expressions programmatically.</span></span> <span data-ttu-id="8c82f-108">Cette fonctionnalité vous permet de générer une arborescence de syntaxe abstraite qui représente le code F #.</span><span class="sxs-lookup"><span data-stu-id="8c82f-108">This feature lets you generate an abstract syntax tree that represents F# code.</span></span> <span data-ttu-id="8c82f-109">L’arborescence de syntaxe abstraite peut ensuite être parcouru et traité en fonction des besoins de votre application.</span><span class="sxs-lookup"><span data-stu-id="8c82f-109">The abstract syntax tree can then be traversed and processed according to the needs of your application.</span></span> <span data-ttu-id="8c82f-110">Par exemple, vous pouvez utiliser l’arborescence pour générer du code F # ou générer du code dans un autre langage.</span><span class="sxs-lookup"><span data-stu-id="8c82f-110">For example, you can use the tree to generate F# code or generate code in some other language.</span></span>


## <a name="quoted-expressions"></a><span data-ttu-id="8c82f-111">Expressions entre guillemets</span><span class="sxs-lookup"><span data-stu-id="8c82f-111">Quoted Expressions</span></span>
<span data-ttu-id="8c82f-112">A *entre guillemets expression* est une expression F # dans votre code qui est délimitée de sorte qu’il n’est pas compilé dans le cadre de votre programme, mais au lieu de cela est compilé dans un objet qui représente une expression F #.</span><span class="sxs-lookup"><span data-stu-id="8c82f-112">A *quoted expression* is an F# expression in your code that is delimited in such a way that it is not compiled as part of your program, but instead is compiled into an object that represents an F# expression.</span></span> <span data-ttu-id="8c82f-113">Vous pouvez marquer une expression entre guillemets de deux manières : avec des informations de type ou sans informations de type.</span><span class="sxs-lookup"><span data-stu-id="8c82f-113">You can mark a quoted expression in one of two ways: either with type information or without type information.</span></span> <span data-ttu-id="8c82f-114">Si vous souhaitez inclure des informations de type, vous utilisez les symboles `<@` et `@>` pour délimiter l’expression entre guillemets.</span><span class="sxs-lookup"><span data-stu-id="8c82f-114">If you want to include type information, you use the symbols `<@` and `@>` to delimit the quoted expression.</span></span> <span data-ttu-id="8c82f-115">Si vous n’avez pas besoin d’informations de type, vous utilisez les symboles `<@@` et `@@>`.</span><span class="sxs-lookup"><span data-stu-id="8c82f-115">If you do not need type information, you use the symbols `<@@` and `@@>`.</span></span> <span data-ttu-id="8c82f-116">Le code suivant montre les quotations typées et non typées.</span><span class="sxs-lookup"><span data-stu-id="8c82f-116">The following code shows typed and untyped quotations.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet501.fs)]

<span data-ttu-id="8c82f-117">Parcourir une grande arborescence d’expression est plus rapide si vous n’incluez pas les informations de type.</span><span class="sxs-lookup"><span data-stu-id="8c82f-117">Traversing a large expression tree is faster if you do not include type information.</span></span> <span data-ttu-id="8c82f-118">Le type résultant d’une expression entre guillemets avec les symboles typés est `Expr<'T>`, où le paramètre de type a le type de l’expression, comme déterminé par l’algorithme d’inférence de type du compilateur F #.</span><span class="sxs-lookup"><span data-stu-id="8c82f-118">The resulting type of an expression quoted with the typed symbols is `Expr<'T>`, where the type parameter has the type of the expression as determined by the F# compiler's type inference algorithm.</span></span> <span data-ttu-id="8c82f-119">Lorsque vous utilisez des quotations de code sans informations de type, le type de l’expression entre guillemets est le type non générique [Expr](https://msdn.microsoft.com/library/ed6a2caf-69d4-45c2-ab97-e9b3be9bce65).</span><span class="sxs-lookup"><span data-stu-id="8c82f-119">When you use code quotations without type information, the type of the quoted expression is the non-generic type [Expr](https://msdn.microsoft.com/library/ed6a2caf-69d4-45c2-ab97-e9b3be9bce65).</span></span> <span data-ttu-id="8c82f-120">Vous pouvez appeler la [Raw](https://msdn.microsoft.com/library/47fb94f1-e77f-4c68-aabc-2b0ba40d59c2) propriété typées `Expr` classe pour obtenir la non typé `Expr` objet.</span><span class="sxs-lookup"><span data-stu-id="8c82f-120">You can call the [Raw](https://msdn.microsoft.com/library/47fb94f1-e77f-4c68-aabc-2b0ba40d59c2) property on the typed `Expr` class to obtain the untyped `Expr` object.</span></span>

<span data-ttu-id="8c82f-121">Il existe une multitude de méthodes statiques qui vous permettent de générer des objets expression F # par programmation dans le `Expr` classe sans utiliser les expressions quotées.</span><span class="sxs-lookup"><span data-stu-id="8c82f-121">There are a variety of static methods that allow you to generate F# expression objects programmatically in the `Expr` class without using quoted expressions.</span></span>

<span data-ttu-id="8c82f-122">Notez qu’une quotation de code doit inclure une expression complète.</span><span class="sxs-lookup"><span data-stu-id="8c82f-122">Note that a code quotation must include a complete expression.</span></span> <span data-ttu-id="8c82f-123">Pour un `let` de liaison, par exemple, vous devez la définition du nom lié et d’une expression supplémentaire qui utilise la liaison.</span><span class="sxs-lookup"><span data-stu-id="8c82f-123">For a `let` binding, for example, you need both the definition of the bound name and an additional expression that uses the binding.</span></span> <span data-ttu-id="8c82f-124">Dans la syntaxe détaillée, il s’agit d’une expression qui suit le `in` (mot clé).</span><span class="sxs-lookup"><span data-stu-id="8c82f-124">In verbose syntax, this is an expression that follows the `in` keyword.</span></span> <span data-ttu-id="8c82f-125">Au niveau supérieur dans un module, il s’agit simplement l’expression suivante dans le module, mais dans une quotation, elle est explicitement obligatoire.</span><span class="sxs-lookup"><span data-stu-id="8c82f-125">At the top-level in a module, this is just the next expression in the module, but in a quotation, it is explicitly required.</span></span>

<span data-ttu-id="8c82f-126">Par conséquent, l’expression suivante n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="8c82f-126">Therefore, the following expression is not valid.</span></span>

```fsharp
// Not valid:
// <@ let f x = x + 1 @>
```

<span data-ttu-id="8c82f-127">En revanche, les expressions suivantes sont valides.</span><span class="sxs-lookup"><span data-stu-id="8c82f-127">But the following expressions are valid.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet502.fs)]

<span data-ttu-id="8c82f-128">Pour utiliser des quotations de code, vous devez ajouter une déclaration d’importation (à l’aide de la `open` mot clé) qui ouvre le [Microsoft.FSharp.Quotations](https://msdn.microsoft.com/library/e9ce8a3a-e00c-4190-bad5-cce52ee089b2) espace de noms.</span><span class="sxs-lookup"><span data-stu-id="8c82f-128">To use code quotations, you must add an import declaration (by using the `open` keyword) that opens the [Microsoft.FSharp.Quotations](https://msdn.microsoft.com/library/e9ce8a3a-e00c-4190-bad5-cce52ee089b2) namespace.</span></span>

<span data-ttu-id="8c82f-129">F # PowerPack fournit la prise en charge pour l’évaluation et de l’exécution d’objets expression F #.</span><span class="sxs-lookup"><span data-stu-id="8c82f-129">The F# PowerPack provides support for evaluating and executing F# expression objects.</span></span>


## <a name="expr-type"></a><span data-ttu-id="8c82f-130">Type expr</span><span class="sxs-lookup"><span data-stu-id="8c82f-130">Expr Type</span></span>
<span data-ttu-id="8c82f-131">Une instance de la `Expr` type représente une expression F #.</span><span class="sxs-lookup"><span data-stu-id="8c82f-131">An instance of the `Expr` type represents an F# expression.</span></span> <span data-ttu-id="8c82f-132">Génériques et non génériques `Expr` types sont documentés dans la documentation de la bibliothèque F #.</span><span class="sxs-lookup"><span data-stu-id="8c82f-132">Both the generic and the non-generic `Expr` types are documented in the F# library documentation.</span></span> <span data-ttu-id="8c82f-133">Pour plus d’informations, consultez [Microsoft.FSharp.Quotations Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.quotations-namespace-%5bfsharp%5d) et [Quotations.expr, classe](https://msdn.microsoft.com/visualfsharpdocs/conceptual/quotations.expr-class-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="8c82f-133">For more information, see [Microsoft.FSharp.Quotations Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.quotations-namespace-%5bfsharp%5d) and [Quotations.Expr Class](https://msdn.microsoft.com/visualfsharpdocs/conceptual/quotations.expr-class-%5bfsharp%5d).</span></span>


## <a name="splicing-operators"></a><span data-ttu-id="8c82f-134">L’ajout d’opérateurs</span><span class="sxs-lookup"><span data-stu-id="8c82f-134">Splicing Operators</span></span>
<span data-ttu-id="8c82f-135">L’ajout de vous permet de combiner les quotations de code littéral avec les expressions que vous avez créé par programme ou à partir d’une autre quotation de code.</span><span class="sxs-lookup"><span data-stu-id="8c82f-135">Splicing enables you to combine literal code quotations with expressions that you have created programmatically or from another code quotation.</span></span> <span data-ttu-id="8c82f-136">Le `%` et `%%` opérateurs activent vous permet d’ajouter un objet expression F # dans une quotation de code.</span><span class="sxs-lookup"><span data-stu-id="8c82f-136">The `%` and `%%` operators enable you to add an F# expression object into a code quotation.</span></span> <span data-ttu-id="8c82f-137">Vous utilisez la `%` opérateur pour insérer un objet expression typé dans une quotation typée ; si vous utilisez la `%%` opérateur pour insérer un objet d’expression non typé dans une quotation non typée.</span><span class="sxs-lookup"><span data-stu-id="8c82f-137">You use the `%` operator to insert a typed expression object into a typed quotation; you use the `%%` operator to insert an untyped expression object into an untyped quotation.</span></span> <span data-ttu-id="8c82f-138">Les deux opérateurs sont des opérateurs préfixés unaires.</span><span class="sxs-lookup"><span data-stu-id="8c82f-138">Both operators are unary prefix operators.</span></span> <span data-ttu-id="8c82f-139">Par conséquent, si `expr` est une expression non typée de type `Expr`, le code suivant est valid.</span><span class="sxs-lookup"><span data-stu-id="8c82f-139">Thus if `expr` is an untyped expression of type `Expr`, the following code is valid.</span></span>

```fsharp
<@@ 1 + %%expr @@>
```

<span data-ttu-id="8c82f-140">Et si `expr` est une quotation typée de type `Expr<int>`, le code suivant est valid.</span><span class="sxs-lookup"><span data-stu-id="8c82f-140">And if `expr` is a typed quotation of type `Expr<int>`, the following code is valid.</span></span>

```fsharp
<@ 1 + %expr @>
```

## <a name="example"></a><span data-ttu-id="8c82f-141">Exemple</span><span class="sxs-lookup"><span data-stu-id="8c82f-141">Example</span></span>

### <a name="description"></a><span data-ttu-id="8c82f-142">Description</span><span class="sxs-lookup"><span data-stu-id="8c82f-142">Description</span></span>
<span data-ttu-id="8c82f-143">L’exemple suivant illustre l’utilisation de quotations de code pour placer le code F # dans un objet d’expression, puis imprimer le code F # qui représente l’expression.</span><span class="sxs-lookup"><span data-stu-id="8c82f-143">The following example illustrates the use of code quotations to put F# code into an expression object and then print the F# code that represents the expression.</span></span> <span data-ttu-id="8c82f-144">Une fonction `println` est définie qui contient une fonction récursive `print` qui affiche un objet expression F # (de type `Expr`) dans un format convivial.</span><span class="sxs-lookup"><span data-stu-id="8c82f-144">A function `println` is defined that contains a recursive function `print` that displays an F# expression object (of type `Expr`) in a friendly format.</span></span> <span data-ttu-id="8c82f-145">Il existe plusieurs modèles actifs dans le [Microsoft.FSharp.Quotations.Patterns](https://msdn.microsoft.com/library/093944a9-c752-403a-8983-5fcd5dbf92a4) et [Microsoft.FSharp.Quotations.DerivedPatterns](https://msdn.microsoft.com/library/d2434a6e-ae7b-4f3d-b567-c162938bc9cd) modules qui peuvent être utilisés pour analyser des objets expression.</span><span class="sxs-lookup"><span data-stu-id="8c82f-145">There are several active patterns in the [Microsoft.FSharp.Quotations.Patterns](https://msdn.microsoft.com/library/093944a9-c752-403a-8983-5fcd5dbf92a4) and [Microsoft.FSharp.Quotations.DerivedPatterns](https://msdn.microsoft.com/library/d2434a6e-ae7b-4f3d-b567-c162938bc9cd) modules that can be used to analyze expression objects.</span></span> <span data-ttu-id="8c82f-146">Cet exemple n’inclut pas tous les modèles possibles susceptibles d’apparaître dans une expression F #.</span><span class="sxs-lookup"><span data-stu-id="8c82f-146">This example does not include all the possible patterns that might appear in an F# expression.</span></span> <span data-ttu-id="8c82f-147">Un modèle non reconnu déclenche une correspondance au modèle de caractère générique (`_`) et est rendu à l’aide de la `ToString` (méthode), qui, sur le `Expr` de type, vous permet de connaître le modèle actif à ajouter à votre expression de correspondance.</span><span class="sxs-lookup"><span data-stu-id="8c82f-147">Any unrecognized pattern triggers a match to the wildcard pattern (`_`) and is rendered by using the `ToString` method, which, on the `Expr` type, lets you know the active pattern to add to your match expression.</span></span>


### <a name="code"></a><span data-ttu-id="8c82f-148">Code</span><span class="sxs-lookup"><span data-stu-id="8c82f-148">Code</span></span>
[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet601.fs)]
    
### <a name="output"></a><span data-ttu-id="8c82f-149">Sortie</span><span class="sxs-lookup"><span data-stu-id="8c82f-149">Output</span></span>

```fsharp
fun (x:System.Int32) -> x + 1
a + 1
let f = fun (x:System.Int32) -> x + 10 in f 10
```

## <a name="example"></a><span data-ttu-id="8c82f-150">Exemple</span><span class="sxs-lookup"><span data-stu-id="8c82f-150">Example</span></span>

### <a name="description"></a><span data-ttu-id="8c82f-151">Description</span><span class="sxs-lookup"><span data-stu-id="8c82f-151">Description</span></span>
<span data-ttu-id="8c82f-152">Vous pouvez également utiliser les trois modèles actifs dans le [module ExprShape](https://msdn.microsoft.com/library/7685150e-2432-4d39-9338-57292eff18de) pour parcourir les arborescences d’expression avec moins de modèles actifs.</span><span class="sxs-lookup"><span data-stu-id="8c82f-152">You can also use the three active patterns in the [ExprShape module](https://msdn.microsoft.com/library/7685150e-2432-4d39-9338-57292eff18de) to traverse expression trees with fewer active patterns.</span></span> <span data-ttu-id="8c82f-153">Ces modèles actifs peuvent être utiles lorsque vous souhaitez parcourir une arborescence, mais vous n’avez pas besoin de toutes les informations dans la plupart des nœuds.</span><span class="sxs-lookup"><span data-stu-id="8c82f-153">These active patterns can be useful when you want to traverse a tree but you do not need all the information in most of the nodes.</span></span> <span data-ttu-id="8c82f-154">Lorsque vous utilisez ces modèles, toute expression F # correspond à l’un des trois modèles suivants : `ShapeVar` si l’expression est une variable, `ShapeLambda` si l’expression est une expression lambda, ou `ShapeCombination` si l’expression est autre chose.</span><span class="sxs-lookup"><span data-stu-id="8c82f-154">When you use these patterns, any F# expression matches one of the following three patterns: `ShapeVar` if the expression is a variable, `ShapeLambda` if the expression is a lambda expression, or `ShapeCombination` if the expression is anything else.</span></span> <span data-ttu-id="8c82f-155">Si vous parcourez une arborescence d’expression en utilisant les modèles actifs comme dans l’exemple de code précédent, vous devez utiliser beaucoup plus de modèles pour gérer tous les types d’expression F # possibles et votre code sera plus complexe.</span><span class="sxs-lookup"><span data-stu-id="8c82f-155">If you traverse an expression tree by using the active patterns as in the previous code example, you have to use many more patterns to handle all possible F# expression types, and your code will be more complex.</span></span> <span data-ttu-id="8c82f-156">Pour plus d’informations, consultez [ExprShape.ShapeVar &#124; ShapeLambda &#124; ShapeCombination, modèle actif](https://msdn.microsoft.com/visualfsharpdocs/conceptual/exprshape.shapevarhshapelambdahshapecombination-active-pattern-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="8c82f-156">For more information, see [ExprShape.ShapeVar&#124;ShapeLambda&#124;ShapeCombination Active Pattern](https://msdn.microsoft.com/visualfsharpdocs/conceptual/exprshape.shapevarhshapelambdahshapecombination-active-pattern-%5bfsharp%5d).</span></span>

<span data-ttu-id="8c82f-157">L’exemple de code suivant peut être utilisé comme base pour le parcours plus complexes.</span><span class="sxs-lookup"><span data-stu-id="8c82f-157">The following code example can be used as a basis for more complex traversals.</span></span> <span data-ttu-id="8c82f-158">Dans ce code, une arborescence d’expression est créée pour une expression qui implique un appel de fonction, `add`.</span><span class="sxs-lookup"><span data-stu-id="8c82f-158">In this code, an expression tree is created for an expression that involves a function call, `add`.</span></span> <span data-ttu-id="8c82f-159">Le [SpecificCall](https://msdn.microsoft.com/library/05a77b21-20fe-4b9a-8e07-aa999538198d) (modèle actif) est utilisé pour détecter tout appel à `add` dans l’arborescence d’expression.</span><span class="sxs-lookup"><span data-stu-id="8c82f-159">The [SpecificCall](https://msdn.microsoft.com/library/05a77b21-20fe-4b9a-8e07-aa999538198d) active pattern is used to detect any call to `add` in the expression tree.</span></span> <span data-ttu-id="8c82f-160">Ce modèle actif assigne les arguments de l’appel à la `exprList` valeur.</span><span class="sxs-lookup"><span data-stu-id="8c82f-160">This active pattern assigns the arguments of the call to the `exprList` value.</span></span> <span data-ttu-id="8c82f-161">Dans ce cas, il ne étant que deux, ils sont extraits et la fonction est appelée de manière récursive sur les arguments.</span><span class="sxs-lookup"><span data-stu-id="8c82f-161">In this case, there are only two, so these are pulled out and the function is called recursively on the arguments.</span></span> <span data-ttu-id="8c82f-162">Les résultats sont insérés dans une quotation de code qui représente un appel à `mul` à l’aide de l’opérateur d’ajout (`%%`).</span><span class="sxs-lookup"><span data-stu-id="8c82f-162">The results are inserted into a code quotation that represents a call to `mul` by using the splice operator (`%%`).</span></span> <span data-ttu-id="8c82f-163">Le `println` fonction de l’exemple précédent est utilisée pour afficher les résultats.</span><span class="sxs-lookup"><span data-stu-id="8c82f-163">The `println` function from the previous example is used to display the results.</span></span>

<span data-ttu-id="8c82f-164">Le code dans les autres branches de modèle actif régénère simplement la même arborescence d’expression, donc la seule modification dans l’expression résultante est la modification à partir de `add` à `mul`.</span><span class="sxs-lookup"><span data-stu-id="8c82f-164">The code in the other active pattern branches just regenerates the same expression tree, so the only change in the resulting expression is the change from `add` to `mul`.</span></span>


### <a name="code"></a><span data-ttu-id="8c82f-165">Code</span><span class="sxs-lookup"><span data-stu-id="8c82f-165">Code</span></span>
[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet701.fs)]
    
### <a name="output"></a><span data-ttu-id="8c82f-166">Sortie</span><span class="sxs-lookup"><span data-stu-id="8c82f-166">Output</span></span>

```fsharp
1 + Module1.add(2,Module1.add(3,4))
1 + Module1.mul(2,Module1.mul(3,4))
```

## <a name="see-also"></a><span data-ttu-id="8c82f-167">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="8c82f-167">See Also</span></span>
[<span data-ttu-id="8c82f-168">Informations de référence du langage F#</span><span class="sxs-lookup"><span data-stu-id="8c82f-168">F# Language Reference</span></span>](index.md)

