---
title: Classes (F#)
description: "Découvrez comment les Classes F # sont des types qui représentent des objets qui peuvent avoir des propriétés, méthodes et événements."
keywords: visual f#, f#, programmation fonctionnelle
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: d58679d5-7753-4b3b-a12f-6e9f00ed5ba3
ms.openlocfilehash: 2a73baba1f7c1b0d3bd09d22c9d6d9f0524daef3
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/18/2017
---
# <a name="classes"></a><span data-ttu-id="0d228-104">Classes</span><span class="sxs-lookup"><span data-stu-id="0d228-104">Classes</span></span>

<span data-ttu-id="0d228-105">*Classes* sont des types qui représentent des objets qui peuvent avoir des propriétés, méthodes et événements.</span><span class="sxs-lookup"><span data-stu-id="0d228-105">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>


## <a name="syntax"></a><span data-ttu-id="0d228-106">Syntaxe</span><span class="sxs-lookup"><span data-stu-id="0d228-106">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="0d228-107">Remarques</span><span class="sxs-lookup"><span data-stu-id="0d228-107">Remarks</span></span>
<span data-ttu-id="0d228-108">Les classes représentent la description fondamentale des types d’objet .NET ; la classe est le concept de type principal qui prend en charge la programmation orientée objet en F #.</span><span class="sxs-lookup"><span data-stu-id="0d228-108">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="0d228-109">Dans la syntaxe précédente, le `type-name` est un identificateur valide quelconque.</span><span class="sxs-lookup"><span data-stu-id="0d228-109">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="0d228-110">Le `type-params` décrit les paramètres de type générique facultatifs.</span><span class="sxs-lookup"><span data-stu-id="0d228-110">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="0d228-111">Il se compose des noms de paramètre de type et contraintes placé entourés crochets pointus (`<` et `>`).</span><span class="sxs-lookup"><span data-stu-id="0d228-111">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="0d228-112">Pour plus d’informations, consultez [génériques](generics/index.md) et [contraintes](generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="0d228-112">For more information, see [Generics](generics/index.md) and [Constraints](generics/constraints.md).</span></span> <span data-ttu-id="0d228-113">Le `parameter-list` décrit les paramètres du constructeur.</span><span class="sxs-lookup"><span data-stu-id="0d228-113">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="0d228-114">Le modificateur d’accès associé au type ; le second se rapporte au constructeur principal.</span><span class="sxs-lookup"><span data-stu-id="0d228-114">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="0d228-115">Dans les deux cas, la valeur par défaut est `public`.</span><span class="sxs-lookup"><span data-stu-id="0d228-115">In both cases, the default is `public`.</span></span>

<span data-ttu-id="0d228-116">Vous spécifiez la classe de base pour une classe à l’aide de la `inherit` (mot clé).</span><span class="sxs-lookup"><span data-stu-id="0d228-116">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="0d228-117">Vous devez fournir des arguments entre parenthèses, pour le constructeur de classe de base.</span><span class="sxs-lookup"><span data-stu-id="0d228-117">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="0d228-118">Vous déclarez des champs ou valeurs de fonction qui sont locales à la classe à l’aide de `let` liaisons et vous devez suivre les règles générales pour `let` liaisons.</span><span class="sxs-lookup"><span data-stu-id="0d228-118">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="0d228-119">Le `do-bindings` comprend le code à exécuter après la construction d’objet.</span><span class="sxs-lookup"><span data-stu-id="0d228-119">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="0d228-120">Le `member-list` se compose de constructeurs supplémentaires, instance et les déclarations de méthode statique, les déclarations d’interface, liaisons abstraites et déclarations de propriété et événement.</span><span class="sxs-lookup"><span data-stu-id="0d228-120">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="0d228-121">Ceux-ci sont décrits dans [membres](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="0d228-121">These are described in [Members](members/index.md).</span></span>

<span data-ttu-id="0d228-122">Le `identifier` qui est utilisé avec le paramètre facultatif `as` mot clé donne un nom à la variable d’instance, ou auto-identificateur, qui peut être utilisé dans la définition de type pour faire référence à l’instance du type.</span><span class="sxs-lookup"><span data-stu-id="0d228-122">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="0d228-123">Pour plus d’informations, consultez la section auto-identificateurs plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="0d228-123">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="0d228-124">Les mots clés `class` et `end` qui marquent le début et la fin de la définition sont facultatifs.</span><span class="sxs-lookup"><span data-stu-id="0d228-124">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="0d228-125">Types mutuellement récursifs, qui sont des types qui se référencent mutuellement, sont joints avec la `and` mutuellement les fonctions récursives sont comme mot clé.</span><span class="sxs-lookup"><span data-stu-id="0d228-125">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="0d228-126">Pour obtenir un exemple, consultez la section Types mutuellement récursifs.</span><span class="sxs-lookup"><span data-stu-id="0d228-126">For an example, see the section Mutually Recursive Types.</span></span>


## <a name="constructors"></a><span data-ttu-id="0d228-127">Constructeurs</span><span class="sxs-lookup"><span data-stu-id="0d228-127">Constructors</span></span>
<span data-ttu-id="0d228-128">Le constructeur est le code qui crée une instance du type de classe.</span><span class="sxs-lookup"><span data-stu-id="0d228-128">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="0d228-129">Constructeurs pour les classes fonctionnent un peu différemment dans F # que dans d’autres langages .NET.</span><span class="sxs-lookup"><span data-stu-id="0d228-129">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="0d228-130">Dans une classe F #, il est toujours un constructeur principal dont les arguments sont décrits dans le `parameter-list` qui suit le nom de type, et dont le corps se compose de la `let` (et `let rec`) liaisons au début de la déclaration de classe et le `do`liaisons qui suivent.</span><span class="sxs-lookup"><span data-stu-id="0d228-130">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="0d228-131">Les arguments du constructeur principal sont dans la portée dans l’ensemble de la déclaration de classe.</span><span class="sxs-lookup"><span data-stu-id="0d228-131">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="0d228-132">Vous pouvez ajouter des constructeurs supplémentaires en utilisant le `new` mot clé pour ajouter un membre, comme suit :</span><span class="sxs-lookup"><span data-stu-id="0d228-132">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="0d228-133">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="0d228-133">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="0d228-134">Le corps du nouveau constructeur doit appeler le constructeur principal qui est spécifié en haut de la déclaration de classe.</span><span class="sxs-lookup"><span data-stu-id="0d228-134">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="0d228-135">L’exemple suivant illustre ce concept.</span><span class="sxs-lookup"><span data-stu-id="0d228-135">The following example illustrates this concept.</span></span> <span data-ttu-id="0d228-136">Dans le code suivant, `MyClass` a deux constructeurs : un constructeur principal qui prend deux arguments et un autre constructeur qui n’accepte aucun argument.</span><span class="sxs-lookup"><span data-stu-id="0d228-136">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]
    
## <a name="let-and-do-bindings"></a><span data-ttu-id="0d228-137">Let et liaisons do</span><span class="sxs-lookup"><span data-stu-id="0d228-137">let and do Bindings</span></span>

<span data-ttu-id="0d228-138">Le `let` et `do` liaisons dans une définition de classe forment le corps du constructeur de classe principal, et par conséquent, elles s’exécutent chaque fois qu’une instance de classe est créée.</span><span class="sxs-lookup"><span data-stu-id="0d228-138">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="0d228-139">Si un `let` liaison est une fonction, il est compilé dans un membre.</span><span class="sxs-lookup"><span data-stu-id="0d228-139">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="0d228-140">Si le `let` liaison est une valeur qui n’est pas utilisée dans une fonction ou un membre, il est compilé dans une variable qui est locale au constructeur.</span><span class="sxs-lookup"><span data-stu-id="0d228-140">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="0d228-141">Dans le cas contraire, il est compilé dans un champ de la classe.</span><span class="sxs-lookup"><span data-stu-id="0d228-141">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="0d228-142">Le `do` expressions qui suivent sont compilées dans le constructeur principal et d’exécuter du code d’initialisation pour chaque instance.</span><span class="sxs-lookup"><span data-stu-id="0d228-142">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="0d228-143">Étant donné que les constructeurs supplémentaires toujours appellent le constructeur principal, le `let` liaisons et `do` s’exécutent toujours quel constructeur est appelé.</span><span class="sxs-lookup"><span data-stu-id="0d228-143">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="0d228-144">Champs qui sont créés par `let` liaisons sont accessibles dans l’ensemble de méthodes et propriétés de la classe ; Toutefois, ils ne sont pas accessibles à partir de méthodes statiques, même si les méthodes statiques prennent une variable d’instance en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="0d228-144">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="0d228-145">Ils ne sont pas accessibles à l’aide de l’auto-identificateur, s’il en existe.</span><span class="sxs-lookup"><span data-stu-id="0d228-145">They cannot be accessed by using the self identifier, if one exists.</span></span>


## <a name="self-identifiers"></a><span data-ttu-id="0d228-146">Auto-identificateurs</span><span class="sxs-lookup"><span data-stu-id="0d228-146">Self Identifiers</span></span>

<span data-ttu-id="0d228-147">A *auto-identificateur* est un nom qui représente l’instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="0d228-147">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="0d228-148">Auto-identificateurs ressembler à la `this` mot clé en c# ou C++ ou `Me` dans Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="0d228-148">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="0d228-149">Vous pouvez définir un auto-identificateur de deux manières différentes, selon que vous souhaitez l’auto-identificateur à utiliser dans la portée pour la définition de classe entière ou simplement pour une méthode individuelle.</span><span class="sxs-lookup"><span data-stu-id="0d228-149">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="0d228-150">Pour définir un auto-identificateur pour la classe entière, utilisez la `as` (mot clé) après la parenthèse fermante du paramètre de constructeur de liste et spécifiez le nom d’identificateur.</span><span class="sxs-lookup"><span data-stu-id="0d228-150">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="0d228-151">Pour définir un auto-identificateur pour qu’une seule méthode, indiquez l’auto-identificateur dans la déclaration de membre, juste avant le nom de méthode et un point (.) comme séparateur.</span><span class="sxs-lookup"><span data-stu-id="0d228-151">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="0d228-152">L’exemple de code suivant illustre les deux façons de créer un identificateur personnel.</span><span class="sxs-lookup"><span data-stu-id="0d228-152">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="0d228-153">Dans la première ligne, le `as` est utilisé pour définir l’auto-identificateur.</span><span class="sxs-lookup"><span data-stu-id="0d228-153">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="0d228-154">Dans la cinquième ligne, l’identificateur `this` est utilisé pour définir un auto-identificateur dont la portée est limitée à la méthode `PrintMessage`.</span><span class="sxs-lookup"><span data-stu-id="0d228-154">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="0d228-155">Contrairement à d’autres langages .NET, vous pouvez nommer l’auto-identificateur comme vous le souhaitez ; vous n’êtes pas limité aux noms tels que `self`, `Me`, ou `this`.</span><span class="sxs-lookup"><span data-stu-id="0d228-155">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="0d228-156">L’auto-identificateur qui est déclaré avec le `as` mot clé n’est pas initialisée tant qu’après le `let` liaisons sont exécutées.</span><span class="sxs-lookup"><span data-stu-id="0d228-156">The self identifier that is declared with the `as` keyword is not initialized until after the `let` bindings are executed.</span></span> <span data-ttu-id="0d228-157">Par conséquent, il ne peut pas être utilisé dans le `let` liaisons.</span><span class="sxs-lookup"><span data-stu-id="0d228-157">Therefore, it cannot be used in the `let` bindings.</span></span> <span data-ttu-id="0d228-158">Vous pouvez utiliser l’auto-identificateur dans la `do` section des liaisons.</span><span class="sxs-lookup"><span data-stu-id="0d228-158">You can use the self identifier in the `do` bindings section.</span></span>


## <a name="generic-type-parameters"></a><span data-ttu-id="0d228-159">Paramètres de type générique</span><span class="sxs-lookup"><span data-stu-id="0d228-159">Generic Type Parameters</span></span>

<span data-ttu-id="0d228-160">Paramètres de type générique sont spécifiés dans des crochets pointus (`<` et `>`), sous la forme d’un guillemet simple suivi d’un identificateur.</span><span class="sxs-lookup"><span data-stu-id="0d228-160">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="0d228-161">Plusieurs paramètres de type générique sont séparés par des virgules.</span><span class="sxs-lookup"><span data-stu-id="0d228-161">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="0d228-162">Le paramètre de type générique est dans la portée dans l’ensemble de la déclaration.</span><span class="sxs-lookup"><span data-stu-id="0d228-162">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="0d228-163">L’exemple de code suivant montre comment spécifier des paramètres de type générique.</span><span class="sxs-lookup"><span data-stu-id="0d228-163">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="0d228-164">Arguments de type sont déduits lorsque le type est utilisé.</span><span class="sxs-lookup"><span data-stu-id="0d228-164">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="0d228-165">Dans le code suivant, le type déduit est une séquence de tuples.</span><span class="sxs-lookup"><span data-stu-id="0d228-165">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]
    
## <a name="specifying-inheritance"></a><span data-ttu-id="0d228-166">Spécification de l’héritage</span><span class="sxs-lookup"><span data-stu-id="0d228-166">Specifying Inheritance</span></span>

<span data-ttu-id="0d228-167">Le `inherit` clause identifie la classe de base directe, le cas échéant.</span><span class="sxs-lookup"><span data-stu-id="0d228-167">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="0d228-168">En F #, qu’une seule classe de base directe est autorisée.</span><span class="sxs-lookup"><span data-stu-id="0d228-168">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="0d228-169">Les interfaces qu’une classe implémente ne sont pas considérés comme des classes de base.</span><span class="sxs-lookup"><span data-stu-id="0d228-169">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="0d228-170">Interfaces sont traitées dans le [Interfaces](Interfaces.md) rubrique.</span><span class="sxs-lookup"><span data-stu-id="0d228-170">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="0d228-171">Vous pouvez accéder à des méthodes et propriétés de la classe de base à partir de la classe dérivée à l’aide du mot clé de langage `base` comme identificateur, suivi d’un point (.) et le nom du membre.</span><span class="sxs-lookup"><span data-stu-id="0d228-171">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="0d228-172">Pour plus d’informations, consultez [Héritage](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="0d228-172">For more information, see [Inheritance](inheritance.md).</span></span>


## <a name="members-section"></a><span data-ttu-id="0d228-173">Section de membres</span><span class="sxs-lookup"><span data-stu-id="0d228-173">Members Section</span></span>
<span data-ttu-id="0d228-174">Dans cette section, vous pouvez définir statiques ou méthodes d’instance, propriétés, des implémentations d’interface, membres abstraits, déclarations d’événement et des constructeurs supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="0d228-174">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="0d228-175">Let et effectuez les liaisons ne peut pas apparaître dans cette section.</span><span class="sxs-lookup"><span data-stu-id="0d228-175">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="0d228-176">Étant donné que les membres peuvent être ajoutés à une variété de types F # en plus des classes, ils sont traités dans une rubrique distincte, [membres](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="0d228-176">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](members/index.md).</span></span>


## <a name="mutually-recursive-types"></a><span data-ttu-id="0d228-177">Types mutuellement récursifs</span><span class="sxs-lookup"><span data-stu-id="0d228-177">Mutually Recursive Types</span></span>
<span data-ttu-id="0d228-178">Lorsque vous définissez des types qui font référence à l’autre de façon circulaire, vous associer les définitions de type à l’aide de la `and` (mot clé).</span><span class="sxs-lookup"><span data-stu-id="0d228-178">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="0d228-179">Le `and` mot clé remplace le `type` mot clé sur tous sauf la première définition, comme suit.</span><span class="sxs-lookup"><span data-stu-id="0d228-179">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="0d228-180">La sortie est une liste de tous les fichiers dans le répertoire actif.</span><span class="sxs-lookup"><span data-stu-id="0d228-180">The output is a list of all the files in the current directory.</span></span>


## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="0d228-181">Quand utiliser des Classes, des Unions, des enregistrements et des Structures</span><span class="sxs-lookup"><span data-stu-id="0d228-181">When to Use Classes, Unions, Records, and Structures</span></span>
<span data-ttu-id="0d228-182">Étant donné la diversité des types disponibles, vous devez avoir une bonne compréhension de ce que chaque type est conçu pour sélectionner le type approprié pour un cas particulier.</span><span class="sxs-lookup"><span data-stu-id="0d228-182">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="0d228-183">Classes sont conçues pour une utilisation dans des contextes de programmation orientée objet.</span><span class="sxs-lookup"><span data-stu-id="0d228-183">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="0d228-184">Programmation orientée objet est le paradigme dominant utilisé dans les applications qui sont écrites pour le .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="0d228-184">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="0d228-185">Si votre code F # doit fonctionner étroitement avec le .NET Framework ou une autre bibliothèque orientée objet, et surtout si vous avez besoin d’étendre à partir d’un système de type orienté objet tel que de la bibliothèque d’interface utilisateur, les classes sont probablement appropriés.</span><span class="sxs-lookup"><span data-stu-id="0d228-185">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="0d228-186">Si vous n’interagissez pas étroitement avec code orienté objet, ou si vous écrivez du code qui est autonome et par conséquent protégés à partir de l’interaction fréquente avec le code orienté objet, vous devez envisager d’utiliser des enregistrements et des unions discriminées.</span><span class="sxs-lookup"><span data-stu-id="0d228-186">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="0d228-187">Un seul bien pensée – hors union discriminée, ainsi que du code, mise en correspondance appropriée peut souvent être utilisée comme une alternative plus simple à une hiérarchie d’objets.</span><span class="sxs-lookup"><span data-stu-id="0d228-187">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="0d228-188">Pour plus d’informations sur les unions discriminées, consultez [les Unions discriminées](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="0d228-188">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="0d228-189">Enregistrements ont l’avantage d’être plus simples que les classes, mais les enregistrements ne sont pas appropriées lorsque les demandes d’un type dépassent ce qui est possible de leur simplicité.</span><span class="sxs-lookup"><span data-stu-id="0d228-189">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="0d228-190">Les enregistrements sont essentiellement des agrégats simples de valeurs, sans constructeurs séparés qui peuvent effectuer des actions personnalisées, sans champs masqués et sans implémentations d’héritage ou d’interface.</span><span class="sxs-lookup"><span data-stu-id="0d228-190">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="0d228-191">Bien que les membres tels que les propriétés et méthodes peuvent être ajoutés à des enregistrements pour rendre leur comportement plus complexe, les champs stockés dans un enregistrement restent un agrégat simple de valeurs.</span><span class="sxs-lookup"><span data-stu-id="0d228-191">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="0d228-192">Pour plus d’informations à propos des enregistrements, consultez [enregistrements](records.md).</span><span class="sxs-lookup"><span data-stu-id="0d228-192">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="0d228-193">Structures sont également utiles pour les petits volumes de données, mais elles diffèrent des classes et des enregistrements qu’ils ne sont des types valeur .NET.</span><span class="sxs-lookup"><span data-stu-id="0d228-193">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="0d228-194">Classes et les enregistrements sont des types référence.</span><span class="sxs-lookup"><span data-stu-id="0d228-194">Classes and records are .NET reference types.</span></span> <span data-ttu-id="0d228-195">La sémantique des types valeur et types référence est différente dans la mesure où les types valeur sont passés par valeur.</span><span class="sxs-lookup"><span data-stu-id="0d228-195">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="0d228-196">Cela signifie qu’ils sont copiés bit par bit lorsqu’ils sont passés en tant que paramètre ou retournés par une fonction.</span><span class="sxs-lookup"><span data-stu-id="0d228-196">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="0d228-197">Ils sont également stockés sur la pile ou, s’ils sont utilisés en tant que champ, incorporé à l’intérieur de l’objet parent au lieu de dans leur propre emplacement distinct sur le tas.</span><span class="sxs-lookup"><span data-stu-id="0d228-197">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="0d228-198">Par conséquent, les structures sont appropriées pour les données fréquemment sollicitées lorsque la surcharge de l’accès du tas est un problème.</span><span class="sxs-lookup"><span data-stu-id="0d228-198">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="0d228-199">Pour plus d’informations sur les structures, consultez [Structures](structures.md).</span><span class="sxs-lookup"><span data-stu-id="0d228-199">For more information about structures, see [Structures](structures.md).</span></span>


## <a name="see-also"></a><span data-ttu-id="0d228-200">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="0d228-200">See Also</span></span>
[<span data-ttu-id="0d228-201">Informations de référence du langage F#</span><span class="sxs-lookup"><span data-stu-id="0d228-201">F# Language Reference</span></span>](index.md)

[<span data-ttu-id="0d228-202">Membres</span><span class="sxs-lookup"><span data-stu-id="0d228-202">Members</span></span>](members/index.md)

[<span data-ttu-id="0d228-203">Héritage</span><span class="sxs-lookup"><span data-stu-id="0d228-203">Inheritance</span></span>](inheritance.md)

[<span data-ttu-id="0d228-204">Interfaces</span><span class="sxs-lookup"><span data-stu-id="0d228-204">Interfaces</span></span>](interfaces.md)

