---
title: "Sélection d’un modèle d’échange de messages"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 0f502ca1-6a8e-4607-ba15-59198c0e6146
caps.latest.revision: "11"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: ab9a894ad57a5324d466e0eb94e49e2cf6104a19
ms.sourcegitcommit: ce279f2d7fe2220e6ea0a25a8a7a5370ddf8d9f0
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/02/2017
---
# <a name="choosing-a-message-exchange-pattern"></a><span data-ttu-id="98106-102">Sélection d’un modèle d’échange de messages</span><span class="sxs-lookup"><span data-stu-id="98106-102">Choosing a Message Exchange Pattern</span></span>
<span data-ttu-id="98106-103">La première étape de l’écriture d’un transport personnalisé consiste à décider quels *modèles d’échange de messages* (ou MEP) sont requis pour le canal que vous développez.</span><span class="sxs-lookup"><span data-stu-id="98106-103">The first step in writing a custom transport is to decide which *message exchange patterns* (or MEPs) are required for the channel you are developing.</span></span> <span data-ttu-id="98106-104">Cette rubrique contient des explications sur les options disponibles ainsi que sur les différentes exigences.</span><span class="sxs-lookup"><span data-stu-id="98106-104">This topic describes the options available and discusses the various requirements.</span></span> <span data-ttu-id="98106-105">C’est la première tâche dans la liste de tâches de développement channel décrite dans [développement canaux](../../../../docs/framework/wcf/extending/developing-channels.md).</span><span class="sxs-lookup"><span data-stu-id="98106-105">This is the first task in the channel development task list described in [Developing Channels](../../../../docs/framework/wcf/extending/developing-channels.md).</span></span>  
  
## <a name="six-message-exchange-patterns"></a><span data-ttu-id="98106-106">Modèles d’échange de messages</span><span class="sxs-lookup"><span data-stu-id="98106-106">Six Message Exchange Patterns</span></span>  
 <span data-ttu-id="98106-107">Trois MEP sont disponibles :</span><span class="sxs-lookup"><span data-stu-id="98106-107">There are three MEPs to choose from:</span></span>  
  
-   <span data-ttu-id="98106-108">Datagramme (<xref:System.ServiceModel.Channels.IInputChannel> et <xref:System.ServiceModel.Channels.IOutputChannel>)</span><span class="sxs-lookup"><span data-stu-id="98106-108">Datagram (<xref:System.ServiceModel.Channels.IInputChannel> and <xref:System.ServiceModel.Channels.IOutputChannel>)</span></span>  
  
     <span data-ttu-id="98106-109">Lorsque vous utilisez un MEP datagramme, un client envoie un message à l’aide un *déclenché et oublié* exchange.</span><span class="sxs-lookup"><span data-stu-id="98106-109">When using a datagram MEP, a client sends a message using a *fire and forget* exchange.</span></span> <span data-ttu-id="98106-110">Un échange de ce type requiert une confirmation hors bande de la réussite de la remise.</span><span class="sxs-lookup"><span data-stu-id="98106-110">A fire and forget exchange is one that requires out-of-band confirmation of successful delivery.</span></span> <span data-ttu-id="98106-111">Le message peut être perdu lors de la transmission et ne jamais atteindre le service.</span><span class="sxs-lookup"><span data-stu-id="98106-111">The message might be lost in transit and never reach the service.</span></span> <span data-ttu-id="98106-112">Si l'opération d'envoi s'exécute correctement au niveau du client, cela ne garantit pas que le point de terminaison distant a effectivement reçu le message.</span><span class="sxs-lookup"><span data-stu-id="98106-112">If the send operation completes successfully at the client end, it does not guarantee that the remote endpoint has received the message.</span></span> <span data-ttu-id="98106-113">Le datagramme est un bloc de construction de messagerie fondamental. Vous pouvez en effet définir vos propres protocoles au-dessus de ce bloc, notamment des protocoles fiables et sécurisés.</span><span class="sxs-lookup"><span data-stu-id="98106-113">The datagram is a fundamental building block for messaging, as you can build your own protocols on top of it—including reliable protocols and secure protocols.</span></span> <span data-ttu-id="98106-114">Les canaux de datagramme du client implémentent l'interface <xref:System.ServiceModel.Channels.IOutputChannel> et ceux du service implémentent l'interface <xref:System.ServiceModel.Channels.IInputChannel>.</span><span class="sxs-lookup"><span data-stu-id="98106-114">Client datagram channels implement the <xref:System.ServiceModel.Channels.IOutputChannel> interface and service datagram channels implement the <xref:System.ServiceModel.Channels.IInputChannel> interface.</span></span>  
  
-   <span data-ttu-id="98106-115">Demande-réponse (<xref:System.ServiceModel.Channels.IRequestChannel> et <xref:System.ServiceModel.Channels.IReplyChannel>)</span><span class="sxs-lookup"><span data-stu-id="98106-115">Request-Response (<xref:System.ServiceModel.Channels.IRequestChannel> and <xref:System.ServiceModel.Channels.IReplyChannel>)</span></span>  
  
     <span data-ttu-id="98106-116">Dans ce MEP, un message est envoyé et une réponse est reçue.</span><span class="sxs-lookup"><span data-stu-id="98106-116">In this MEP, a message is sent, and a reply is received.</span></span> <span data-ttu-id="98106-117">Ce modèle se compose de paires demande-réponse.</span><span class="sxs-lookup"><span data-stu-id="98106-117">The pattern consists of request-response pairs.</span></span> <span data-ttu-id="98106-118">Parmi les exemples d'appels demande-réponse figurent notamment les appels de procédure distante (RPC) et les demandes GET de navigateur.</span><span class="sxs-lookup"><span data-stu-id="98106-118">Examples of request-response calls are remote procedure calls (RPC) and browser GET requests.</span></span> <span data-ttu-id="98106-119">Ce modèle est également connu sous le nom de mode semi-duplex.</span><span class="sxs-lookup"><span data-stu-id="98106-119">This pattern is also known as half-duplex.</span></span> <span data-ttu-id="98106-120">Dans ce MEP, les canaux du client implémentent <xref:System.ServiceModel.Channels.IRequestChannel> et ceux du service implémentent <xref:System.ServiceModel.Channels.IReplyChannel>.</span><span class="sxs-lookup"><span data-stu-id="98106-120">In this MEP, client channels implement <xref:System.ServiceModel.Channels.IRequestChannel> and service channels implement <xref:System.ServiceModel.Channels.IReplyChannel>.</span></span>  
  
-   <span data-ttu-id="98106-121">Duplex (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span><span class="sxs-lookup"><span data-stu-id="98106-121">Duplex (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span></span>  
  
     <span data-ttu-id="98106-122">Le MEP duplex permet à un nombre aléatoire de messages d'être envoyés par un client et d'être reçus dans un ordre indifférencié.</span><span class="sxs-lookup"><span data-stu-id="98106-122">The duplex MEP allows an arbitrary number of messages to be sent by a client and received in any order.</span></span> <span data-ttu-id="98106-123">Le MEP duplex est similaire à une conversation téléphonique, où chaque mot prononcé correspond à un message.</span><span class="sxs-lookup"><span data-stu-id="98106-123">The duplex MEP is like a phone conversation, where each word being spoken is a message.</span></span> <span data-ttu-id="98106-124">Les deux côtés pouvant envoyer et recevoir des messages dans ce MEP, l'interface implémentée par les canaux du client et du service est <xref:System.ServiceModel.Channels.IDuplexChannel>.</span><span class="sxs-lookup"><span data-stu-id="98106-124">Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <xref:System.ServiceModel.Channels.IDuplexChannel>.</span></span>  
  
 <span data-ttu-id="98106-125">![Choix d’un modèle d’échange de messages](../../../../docs/framework/wcf/extending/media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span><span class="sxs-lookup"><span data-stu-id="98106-125">![Choosing a message exchange pattern](../../../../docs/framework/wcf/extending/media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span></span>  
<span data-ttu-id="98106-126">Les trois modèles d’échange de messages de base.</span><span class="sxs-lookup"><span data-stu-id="98106-126">The three basic message exchange patterns.</span></span> <span data-ttu-id="98106-127">De haut en bas : datagramme, demande-réponse et duplex.</span><span class="sxs-lookup"><span data-stu-id="98106-127">Top to bottom: datagram, request-response, and duplex.</span></span>  
  
 <span data-ttu-id="98106-128">Chacun de ces MEP peut également prendre en charge *sessions*.</span><span class="sxs-lookup"><span data-stu-id="98106-128">Each of these MEPs can also support *sessions*.</span></span> <span data-ttu-id="98106-129">Une session (et une implémentation de <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> de type <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) met en corrélation tous les messages envoyés et reçus sur un canal.</span><span class="sxs-lookup"><span data-stu-id="98106-129">A session (and implementation of <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> of type <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) correlates all messages sent and received on a channel.</span></span> <span data-ttu-id="98106-130">Le modèle de demande-réponse correspond à une session autonome à deux messages, la demande et la réponse étant corrélées.</span><span class="sxs-lookup"><span data-stu-id="98106-130">The request-response pattern is a stand-alone two-message session, as the request and reply are correlated.</span></span> <span data-ttu-id="98106-131">Par comparaison, lorsque le modèle demande-réponse prend en charge les sessions, cela signifie que toutes les paires demande-réponse envoyées et reçues sur le canal doivent être corrélées les unes avec les autres.</span><span class="sxs-lookup"><span data-stu-id="98106-131">In contrast, the request-response pattern that supports sessions implies that all request/response pairs on that channel are correlated with each other.</span></span> <span data-ttu-id="98106-132">Vous pouvez donc choisir entre six MEP au total :</span><span class="sxs-lookup"><span data-stu-id="98106-132">This gives you a total of six MEPs to choose from:</span></span>  
  
-   <span data-ttu-id="98106-133">Datagramme</span><span class="sxs-lookup"><span data-stu-id="98106-133">Datagram</span></span>  
  
-   <span data-ttu-id="98106-134">Demande-réponse</span><span class="sxs-lookup"><span data-stu-id="98106-134">Request-response</span></span>  
  
-   <span data-ttu-id="98106-135">Duplex</span><span class="sxs-lookup"><span data-stu-id="98106-135">Duplex</span></span>  
  
-   <span data-ttu-id="98106-136">Datagramme avec sessions</span><span class="sxs-lookup"><span data-stu-id="98106-136">Datagram with sessions</span></span>  
  
-   <span data-ttu-id="98106-137">Demande-réponse avec sessions</span><span class="sxs-lookup"><span data-stu-id="98106-137">Request-response with sessions</span></span>  
  
-   <span data-ttu-id="98106-138">Duplex avec sessions</span><span class="sxs-lookup"><span data-stu-id="98106-138">Duplex with sessions</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="98106-139">Pour le transport UDP, le seul MEP pris en charge est datagramme, le protocole UDP, de part sa nature même, permettant uniquement l'échange de messages de type « déclenché et oublié ».</span><span class="sxs-lookup"><span data-stu-id="98106-139">For the UDP transport, the only MEP that is supported is datagram, because UDP is inherently a fire and forget protocol.</span></span>  
  
## <a name="sessions-and-sessionful-channels"></a><span data-ttu-id="98106-140">Sessions et canaux de session</span><span class="sxs-lookup"><span data-stu-id="98106-140">Sessions and Sessionful Channels</span></span>  
 <span data-ttu-id="98106-141">En matière de réseaux, il existe des protocoles orientés connexion (par exemple, le protocole TCP) et des protocoles sans connexion (par exemple, le protocole UDP).</span><span class="sxs-lookup"><span data-stu-id="98106-141">In the networking world, there are connection-oriented protocols (for example, TCP) and connection-less protocols (for example, UDP).</span></span> [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="98106-142"> utilise le terme « session » à la place du terme « connexion » à des fins d'abstraction logique.</span><span class="sxs-lookup"><span data-stu-id="98106-142"> uses the term session to mean a connection-like logical abstraction.</span></span> <span data-ttu-id="98106-143">Les protocoles de session WCF s'apparentent aux protocoles de réseau orientés connexion et les protocoles sans session WCF aux protocoles de réseau sans connexion.</span><span class="sxs-lookup"><span data-stu-id="98106-143">Sessionful WCF protocols are similar to connection-oriented network protocols and sessionless WCF protocols are similar to connection-less network protocols.</span></span>  
  
 <span data-ttu-id="98106-144">Dans le modèle d'objet de canal, chaque session logique se manifeste sous forme d'instance de canal de session.</span><span class="sxs-lookup"><span data-stu-id="98106-144">In the channel object model, each logical session manifests as an instance of a sessionful channel.</span></span> <span data-ttu-id="98106-145">Par conséquent, chaque nouvelle session créée par le client et acceptée par le service correspond à un nouveau canal de session de part et d'autre.</span><span class="sxs-lookup"><span data-stu-id="98106-145">Therefore every new session created by the client, and accepted on the service, corresponds to a new sessionful channel on each side.</span></span> <span data-ttu-id="98106-146">Le diagramme suivant contient, dans sa partie supérieure, la structure des canaux sans session et, dans sa partie inférieure, la structure des canaux de session.</span><span class="sxs-lookup"><span data-stu-id="98106-146">The following diagram shows, on the top, the structure of sessionless channels, and on the bottom, the structure of sessionful channels.</span></span>  
  
 <span data-ttu-id="98106-147">![Choix d’un modèle d’échange de messages](../../../../docs/framework/wcf/extending/media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span><span class="sxs-lookup"><span data-stu-id="98106-147">![Choosing a message exchange pattern](../../../../docs/framework/wcf/extending/media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span></span>  
  
 <span data-ttu-id="98106-148">Un client crée un nouveau canal de session, puis envoie un message.</span><span class="sxs-lookup"><span data-stu-id="98106-148">A client creates a new sessionful channel and sends a message.</span></span> <span data-ttu-id="98106-149">Du côté du service, l'écouteur de canal reçoit ce message et détecte qu'il appartient à une nouvelle session. Il crée par conséquent un nouveau canal de session qu'il transmet à l'application (en réponse à l'appel AcceptChannel transmis par cette dernière).</span><span class="sxs-lookup"><span data-stu-id="98106-149">On the service side, the channel listener receives this message and detects that it belongs to a new session so it creates a new sessionful channel and hands it to the application (in response to the application calling AcceptChannel on the channel listener).</span></span> <span data-ttu-id="98106-150">L'application reçoit alors le message ainsi que tous les messages suivants envoyés dans la même session via le même canal de session.</span><span class="sxs-lookup"><span data-stu-id="98106-150">The application then receives this message and all subsequent messages sent in the same session through the same sessionful channel.</span></span>  
  
 <span data-ttu-id="98106-151">Un autre client (ou le même client que précédemment) crée un nouveau canal de session, puis envoie un message.</span><span class="sxs-lookup"><span data-stu-id="98106-151">Another client (or the same client) creates a new sessionful and sends a message.</span></span> <span data-ttu-id="98106-152">L'écouteur de canal détecte que ce message figure dans une nouvelle session et crée un nouveau canal de session, puis la même procédure se répète.</span><span class="sxs-lookup"><span data-stu-id="98106-152">The channel listener detects this message is in a new session and creates a new sessionful channel and the process repeats.</span></span>  
  
 <span data-ttu-id="98106-153">Sans session, il n'existe pas de corrélation entre canaux et sessions.</span><span class="sxs-lookup"><span data-stu-id="98106-153">Without sessions, there is no correlation between channels and sessions.</span></span> <span data-ttu-id="98106-154">Par conséquent, l'écouteur de canal crée un seul canal via lequel tous les messages sont reçus, puis remis à l'application.</span><span class="sxs-lookup"><span data-stu-id="98106-154">Therefore a channel listener creates only one channel through which all received messages are delivered to the application.</span></span> <span data-ttu-id="98106-155">En l'absence de session pour maintenir l'ordre des messages, ceux-ci sont transmis sans respecter leur ordre d'envoi.</span><span class="sxs-lookup"><span data-stu-id="98106-155">There is also no message ordering because there is no session within which to maintain message order.</span></span> <span data-ttu-id="98106-156">La partie supérieure du graphique précédent illustre un échange de messages sans session.</span><span class="sxs-lookup"><span data-stu-id="98106-156">The top portion of the preceding graphic illustrates a sessionless message exchange.</span></span>  
  
## <a name="starting-and-terminating-sessions"></a><span data-ttu-id="98106-157">Démarrage et fin des sessions</span><span class="sxs-lookup"><span data-stu-id="98106-157">Starting and Terminating Sessions</span></span>  
 <span data-ttu-id="98106-158">Les sessions sont démarrées à partir du client à la création par ce dernier d'un nouveau canal de session.</span><span class="sxs-lookup"><span data-stu-id="98106-158">Sessions are started on the client by simply creating a new sessionful channel.</span></span> <span data-ttu-id="98106-159">Elles sont démarrées à partir du service à réception par cette dernière d'un message envoyé dans une nouvelle session.</span><span class="sxs-lookup"><span data-stu-id="98106-159">They are started on the service when the service receives a message that was sent in a new session.</span></span> <span data-ttu-id="98106-160">De la même façon, les sessions sont arrêtées par la fermeture ou l'annulation du canal de session.</span><span class="sxs-lookup"><span data-stu-id="98106-160">Likewise, sessions are terminated by closing or aborting a sessionful channel.</span></span>  
  
 <span data-ttu-id="98106-161">Le canal <xref:System.ServiceModel.Channels.IDuplexSessionChannel> qui est utilisé à la fois pour l'envoi et la réception des messages selon un modèle de communication duplex avec session fait exception à cette règle.</span><span class="sxs-lookup"><span data-stu-id="98106-161">The exception to this is <xref:System.ServiceModel.Channels.IDuplexSessionChannel> which is used for both sending and receiving messages in a duplex, sessionful communication pattern.</span></span> <span data-ttu-id="98106-162">L'une des parties peut souhaiter ne plus envoyer de messages tout en continuant à en recevoir. Par conséquent, lors de l'utilisation d'un canal <xref:System.ServiceModel.Channels.IDuplexSessionChannel>, un système vous permet de fermer la session de sortie, indiquant ainsi que vous ne souhaitez plus envoyer de messages, tout en maintenant la session d'entrée ouverte, ce qui vous permet en revanche de continuer à en recevoir.</span><span class="sxs-lookup"><span data-stu-id="98106-162">It is possible that one side will want to stop sending messages but continue to receive messages therefore when using <xref:System.ServiceModel.Channels.IDuplexSessionChannel> there is a mechanism that lets you close the output session indicating you will not send any more messages but keep the input session opened allowing you to continue to receive messages.</span></span>  
  
 <span data-ttu-id="98106-163">En général, les sessions sont fermées du côté sortant et non du côté entrant.</span><span class="sxs-lookup"><span data-stu-id="98106-163">In general, sessions are closed on the outgoing side and not on the incoming side.</span></span> <span data-ttu-id="98106-164">En d'autres termes, il est possible de fermer les canaux de sortie des sessions, permettant ainsi de mettre correctement un terme à ces dernières.</span><span class="sxs-lookup"><span data-stu-id="98106-164">That is, sessionful output channels can be closed, thereby cleanly terminating the session.</span></span> <span data-ttu-id="98106-165">Lorsqu'un canal de sortie de session est fermé, le canal d'entrée de session retourne la valeur null en réponse à l'appel <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> de l'application sur <xref:System.ServiceModel.Channels.IDuplexSessionChannel>.</span><span class="sxs-lookup"><span data-stu-id="98106-165">Closing a sessionful output channel causes the corresponding sessionful input channel to return null to the application calling <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel>.</span></span>  
  
 <span data-ttu-id="98106-166">Cependant, les canaux d'entrée de session ne doivent pas être fermés, sauf si la méthode <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> sur <xref:System.ServiceModel.Channels.IDuplexSessionChannel> retourne la valeur null, indiquant alors que la session est déjà fermée.</span><span class="sxs-lookup"><span data-stu-id="98106-166">However sessionful input channels should not be closed unless <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> returns null, indicating that the session is already closed.</span></span> <span data-ttu-id="98106-167">Lorsque la méthode <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> sur <xref:System.ServiceModel.Channels.IDuplexSessionChannel> ne retourne pas la valeur null, la fermeture du canal d'entrée de session risque de lever une exception, celui-ci étant susceptible de recevoir des messages de manière inopinée pendant le processus de fermeture.</span><span class="sxs-lookup"><span data-stu-id="98106-167">If <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> has not returned null, closing a sessionful input channel may throw an exception because it may receive unexpected messages while closing.</span></span> <span data-ttu-id="98106-168">Lorsque le destinataire souhaite mettre un terme à la session avant l'expéditeur, il doit appeler la méthode <xref:System.ServiceModel.ICommunicationObject.Abort%2A> sur le canal d'entrée, mettant ainsi un terme brutal à la session.</span><span class="sxs-lookup"><span data-stu-id="98106-168">If a receiver wishes to terminate a session before the sender does, it should call <xref:System.ServiceModel.ICommunicationObject.Abort%2A> on the input channel, which abruptly terminates the session.</span></span>  
  
## <a name="writing-sessionful-channels"></a><span data-ttu-id="98106-169">Création des canaux de session</span><span class="sxs-lookup"><span data-stu-id="98106-169">Writing Sessionful Channels</span></span>  
 <span data-ttu-id="98106-170">Lorsque vous créez des canaux de session, ceux-ci doivent remplir certaines conditions pour permettre l'avènement des sessions.</span><span class="sxs-lookup"><span data-stu-id="98106-170">As a sessionful channel author, there are a few things your channel must do to provide sessions.</span></span> <span data-ttu-id="98106-171">Du côté expéditeur, votre canal doit :</span><span class="sxs-lookup"><span data-stu-id="98106-171">On the send side, your channel needs to:</span></span>  
  
-   <span data-ttu-id="98106-172">Créer une nouvelle session (pour chaque nouveau canal) et y associer un nouvel ID de session correspondant à une chaîne unique.</span><span class="sxs-lookup"><span data-stu-id="98106-172">For each new channel, create a new session and associate it with a new session id which is a unique string.</span></span> <span data-ttu-id="98106-173">Ou obtenir une nouvelle session à partir du canal de session figurant en dessous du vôtre dans la pile.</span><span class="sxs-lookup"><span data-stu-id="98106-173">Or obtain a new session from the sessionful channel below you in the stack.</span></span>  
  
-   <span data-ttu-id="98106-174">Si votre canal a créé la session (c'est-à-dire qu'il ne l'a pas obtenue à partir de la couche figurant en dessous du vôtre dans la pile), vous devez associer chaque message envoyé à l'aide de ce canal à cette session.</span><span class="sxs-lookup"><span data-stu-id="98106-174">For each message sent using this channel, if your channel created the session (as opposed to obtaining it from the layer below you), you need to associate the message with the session.</span></span> <span data-ttu-id="98106-175">Pour les canaux de protocole, cette association s'effectue en principe en ajoutant un en-tête SOAP.</span><span class="sxs-lookup"><span data-stu-id="98106-175">For protocol channels, this is typically done by adding a SOAP header.</span></span> <span data-ttu-id="98106-176">Pour les canaux de transport, cette association s'effectue en principe en créant une nouvelle connexion de transport ou en ajoutant des informations de session au protocole de tramage.</span><span class="sxs-lookup"><span data-stu-id="98106-176">For transport channels, this is typically done by creating a new transport connection or adding session information to the framing protocol.</span></span>  
  
-   <span data-ttu-id="98106-177">Pour chaque message envoyé à l'aide de ce canal, vous devez également fournir les garanties de remise mentionnées ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="98106-177">For each message sent using this channel, you need to provide the delivery guarantees mentioned above.</span></span> <span data-ttu-id="98106-178">Si vous utilisez le canal figurant en dessous du vôtre dans la pile pour générer la session, ce canal fournira également les garanties de remise requises.</span><span class="sxs-lookup"><span data-stu-id="98106-178">If you are relying on the channel below you to provide the session, that channel will also provide the delivery guarantees.</span></span> <span data-ttu-id="98106-179">Si la session est générée par votre propre canal, vous devrez implémenter ces garanties dans le cadre de votre propre protocole.</span><span class="sxs-lookup"><span data-stu-id="98106-179">If you’re providing the session yourself, you need to implement those guarantees as part of your protocol.</span></span> <span data-ttu-id="98106-180">En principe, si vous rédigez un canal de protocole en supposant que WCF est utilisé de part et d'autre, vous aurez vraisemblablement besoin d'un transport TCP ou d'un canal de messagerie fiable pour générer la session.</span><span class="sxs-lookup"><span data-stu-id="98106-180">In general, if you are writing a protocol channel that assumes WCF on both sides you may require the TCP transport or the Reliable Messaging channel and rely on either one to provide a session.</span></span>  
  
-   <span data-ttu-id="98106-181">Lorsque la méthode <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> est appelée sur votre canal, effectuez la tâche requise pour fermer la session en utilisant le délai spécifié ou le délai par défaut.</span><span class="sxs-lookup"><span data-stu-id="98106-181">When <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> is called on your channel, perform the necessary work to close the session using either the specified timeout or the default one.</span></span> <span data-ttu-id="98106-182">Cette tâche peut simplement consister à appeler la méthode <xref:System.ServiceModel.ICommunicationObject.Close%2A> sur le canal figurant en dessous du vôtre dans la pile (s'il s'agit du canal utilisé pour obtenir la session), à envoyer un message SOAP spécial ou à fermer une connexion de transport.</span><span class="sxs-lookup"><span data-stu-id="98106-182">This can be as simple as calling <xref:System.ServiceModel.ICommunicationObject.Close%2A> on the channel below you (if you just obtained the session from it) or sending a special SOAP message or closing a transport connection.</span></span>  
  
-   <span data-ttu-id="98106-183">Lorsque la méthode <xref:System.ServiceModel.ICommunicationObject.Abort%2A> est appelée sur votre canal, mettez sans plus attendre un terme à la session sans effectuer d'E/S.</span><span class="sxs-lookup"><span data-stu-id="98106-183">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="98106-184">Cette fermeture peut être sans conséquence ou signifier l'annulation d'une connexion réseau ou d'une autre ressource.</span><span class="sxs-lookup"><span data-stu-id="98106-184">This may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
 <span data-ttu-id="98106-185">Du côté destinataire, votre canal doit :</span><span class="sxs-lookup"><span data-stu-id="98106-185">On the receive side, your channel needs to:</span></span>  
  
-   <span data-ttu-id="98106-186">Permettre à l'écouteur de canal de détecter la session à laquelle chaque message entrant appartient.</span><span class="sxs-lookup"><span data-stu-id="98106-186">For each incoming message, the channel listener must detect the session it belongs to.</span></span> <span data-ttu-id="98106-187">S'il s'agit du premier message dans la session, l'écouteur de canal doit créer un nouveau canal et le retourner en réponse à l'appel de la méthode <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="98106-187">If this is the first message in the session, the channel listener must create a new channel and return it from the call to <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="98106-188">Dans le cas contraire, l'écouteur de canal doit rechercher le canal existant, correspondant à la session et remettre le message via ce canal.</span><span class="sxs-lookup"><span data-stu-id="98106-188">Otherwise the channel listener must find the existing channel that corresponds to the session and deliver the message through that channel.</span></span>  
  
-   <span data-ttu-id="98106-189">Si la session a été générée par votre propre canal (avec les garanties de remise requises), le destinataire devra peut-être effectuer certaines opérations, telles que remettre les messages dans l'ordre ou envoyer des accusés de réception.</span><span class="sxs-lookup"><span data-stu-id="98106-189">If your channel is providing the session (along with the required delivery guarantees) the receive side may be required to perform some actions such as re-order messages or send acknowledgements.</span></span>  
  
-   <span data-ttu-id="98106-190">Lorsque la méthode <xref:System.ServiceModel.ICommunicationObject.Close%2A> est appelée sur votre canal, opérez la tâche requise pour fermer la session en utilisant le délai spécifié ou le délai par défaut.</span><span class="sxs-lookup"><span data-stu-id="98106-190">When <xref:System.ServiceModel.ICommunicationObject.Close%2A> is called on your channel, perform the necessary work to close the session either the specified timeout or the default one.</span></span> <span data-ttu-id="98106-191">Cette opération peut provoquer la levée d'une exception si le canal reçoit un message avant expiration du délai de fermeture.</span><span class="sxs-lookup"><span data-stu-id="98106-191">This could result in exceptions if the channel receives a message while waiting for the close timeout to expire.</span></span> <span data-ttu-id="98106-192">Ce qui est prévisible dans la mesure où l'état du canal est « en cours de fermeture » lorsqu'il reçoit le message.</span><span class="sxs-lookup"><span data-stu-id="98106-192">That’s because the channel will be in the Closing state when it receives a message so it would throw.</span></span>  
  
-   <span data-ttu-id="98106-193">Lorsque la méthode <xref:System.ServiceModel.ICommunicationObject.Abort%2A> est appelée sur votre canal, mettez sans plus attendre un terme à la session sans effectuer d'E/S.</span><span class="sxs-lookup"><span data-stu-id="98106-193">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="98106-194">Encore une fois, cette fermeture peut être sans conséquence ou signifier l'annulation d'une connexion réseau ou d'une autre ressource.</span><span class="sxs-lookup"><span data-stu-id="98106-194">Again, this may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="98106-195">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="98106-195">See Also</span></span>  
 [<span data-ttu-id="98106-196">Vue d’ensemble du modèle de canal</span><span class="sxs-lookup"><span data-stu-id="98106-196">Channel Model Overview</span></span>](../../../../docs/framework/wcf/extending/channel-model-overview.md)
