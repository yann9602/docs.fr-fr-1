---
title: "Fonctionnement des modifications d'état"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: a79ed2aa-e49a-47a8-845a-c9f436ec9987
caps.latest.revision: "13"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 9f93b1e9fdb1569507937c5381b157204ac88f87
ms.sourcegitcommit: ce279f2d7fe2220e6ea0a25a8a7a5370ddf8d9f0
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/02/2017
---
# <a name="understanding-state-changes"></a><span data-ttu-id="f747a-102">Fonctionnement des modifications d'état</span><span class="sxs-lookup"><span data-stu-id="f747a-102">Understanding State Changes</span></span>
<span data-ttu-id="f747a-103">Cette rubrique présente les états et transitions des canaux, les types utilisés pour structurer les états des canaux et la manière de les implémenter.</span><span class="sxs-lookup"><span data-stu-id="f747a-103">This topic discusses the states and transitions that channels have, the types used to structure channel states, and how to implement them.</span></span>  
  
## <a name="state-machines-and-channels"></a><span data-ttu-id="f747a-104">Ordinateurs d'état et canaux</span><span class="sxs-lookup"><span data-stu-id="f747a-104">State Machines and Channels</span></span>  
 <span data-ttu-id="f747a-105">Les objets qui sont en charge de la communication, par exemple les sockets, présentent habituellement un ordinateur d'état dont les transitions d'état sont liées à l'allocation des ressources réseau, à l'établissement ou l'acceptation des connexions, à la fermeture des connexions et à l'arrêt de la communication.</span><span class="sxs-lookup"><span data-stu-id="f747a-105">Objects that deal with communication, for example sockets, usually present a state machine whose state transitions relate to allocating network resources, making or accepting connections, closing connections and terminating communication.</span></span> <span data-ttu-id="f747a-106">L'ordinateur d'état des canaux fournit un modèle uniforme des états d'un objet de communication qui extrait l'implémentation sous-jacente de cet objet.</span><span class="sxs-lookup"><span data-stu-id="f747a-106">The channel state machine provides a uniform model of the states of a communication object that abstracts the underlying implementation of that object.</span></span> <span data-ttu-id="f747a-107">L'interface <xref:System.ServiceModel.ICommunicationObject> fournit un jeu d'états, de méthodes de transition d'état et d'événements de transition d'état.</span><span class="sxs-lookup"><span data-stu-id="f747a-107">The <xref:System.ServiceModel.ICommunicationObject> interface provides a set of states, state transition methods and state transition events.</span></span> <span data-ttu-id="f747a-108">Tous les canaux, toutes les fabrications de canaux et tous les écouteurs de canal implémentent l'ordinateur d'état des canaux.</span><span class="sxs-lookup"><span data-stu-id="f747a-108">All channels, channel factories and channel listeners implement the channel state machine.</span></span>  
  
 <span data-ttu-id="f747a-109">Les événements Closed, Closing, Faulted, Opened et Opening avertissent un observateur externe après une transition d'état.</span><span class="sxs-lookup"><span data-stu-id="f747a-109">The events Closed, Closing, Faulted, Opened and Opening signal an external observer after a state transition occurs.</span></span>  
  
 <span data-ttu-id="f747a-110">Les méthodes Abort, Close et Open (et leurs équivalents asynchrones) provoquent des transitions d'état.</span><span class="sxs-lookup"><span data-stu-id="f747a-110">The methods Abort, Close, and Open (and their asynchronous equivalents) cause state transitions.</span></span>  
  
 <span data-ttu-id="f747a-111">La propriété d'état retourne l'état actuel comme le définit <xref:System.ServiceModel.CommunicationState> :</span><span class="sxs-lookup"><span data-stu-id="f747a-111">The state property returns the current state as defined by <xref:System.ServiceModel.CommunicationState>:</span></span>  
  
## <a name="icommunicationobject-communicationobject-and-states-and-state-transition"></a><span data-ttu-id="f747a-112">États et transitions d'état ICommunicationObject et CommunicationObject</span><span class="sxs-lookup"><span data-stu-id="f747a-112">ICommunicationObject, CommunicationObject, and States and State Transition</span></span>  
 <span data-ttu-id="f747a-113">Un <xref:System.ServiceModel.ICommunicationObject> démarre dans l'état Created où ses différentes propriétés peuvent être configurées.</span><span class="sxs-lookup"><span data-stu-id="f747a-113">An <xref:System.ServiceModel.ICommunicationObject> starts out in the Created state where its various properties can be configured.</span></span> <span data-ttu-id="f747a-114">Une fois dans l'état Opened, l'objet est utilisable pour envoyer et recevoir des messages mais ses propriétés sont considérées comme immuables.</span><span class="sxs-lookup"><span data-stu-id="f747a-114">Once in the Opened state, the object is usable for sending and receiving messages but its properties are considered immutable.</span></span> <span data-ttu-id="f747a-115">Une fois dans l'état Closing, l'objet ne peut plus traiter de nouvelles demandes d'envoi ou de réception, mais les demandes existantes ont la possibilité d'aboutir jusqu'à ce que le délai d'attente Close soit atteint.</span><span class="sxs-lookup"><span data-stu-id="f747a-115">Once in the Closing state, the object can no longer process new send or receive requests, but existing requests have a chance to complete until the Close timeout is reached.</span></span>  <span data-ttu-id="f747a-116">Si une erreur irrécupérable se produit, l'objet passe à l'état Faulted qui permet de rechercher des informations sur l'erreur avant de le fermer.</span><span class="sxs-lookup"><span data-stu-id="f747a-116">If an unrecoverable error occurs, the object transitions to the Faulted state where it can be inspected for information about the error and ultimately closed.</span></span> <span data-ttu-id="f747a-117">Dans l'état Closed, l'objet a atteint avant tout la fin de l'ordinateur d'état.</span><span class="sxs-lookup"><span data-stu-id="f747a-117">When in the Closed state the object has essentially reached the end of the state machine.</span></span> <span data-ttu-id="f747a-118">Une fois qu'un objet est passé d'un état au suivant, il ne revient pas à l'état précédent.</span><span class="sxs-lookup"><span data-stu-id="f747a-118">Once an object transitions from one state to the next, it does not go back to a previous state.</span></span>  
  
 <span data-ttu-id="f747a-119">Le diagramme suivant présente les états et les transitions d'état <xref:System.ServiceModel.ICommunicationObject>.</span><span class="sxs-lookup"><span data-stu-id="f747a-119">The following diagram shows the <xref:System.ServiceModel.ICommunicationObject> states and state transitions.</span></span> <span data-ttu-id="f747a-120">Les transitions d'état peuvent être provoquées en appelant l'une des trois méthodes : Abort, Open ou Close.</span><span class="sxs-lookup"><span data-stu-id="f747a-120">State transitions can be caused by calling one of the three methods: Abort, Open, or Close.</span></span> <span data-ttu-id="f747a-121">Elles peuvent également être provoquées en appelant d'autres méthodes spécifiques à l'implémentation.</span><span class="sxs-lookup"><span data-stu-id="f747a-121">They could also be caused by calling other implementation-specific methods.</span></span> <span data-ttu-id="f747a-122">La transition vers l'état Faulted peut se produire suite à des erreurs lors de l'ouverture ou à l'issue de l'ouverture de l'objet de communication.</span><span class="sxs-lookup"><span data-stu-id="f747a-122">Transitioning to the Faulted state could happen as a result of errors while opening or after having opened the communication object.</span></span>  
  
 <span data-ttu-id="f747a-123">Chaque <xref:System.ServiceModel.ICommunicationObject> démarre dans l'état Created.</span><span class="sxs-lookup"><span data-stu-id="f747a-123">Every <xref:System.ServiceModel.ICommunicationObject> starts out in the Created state.</span></span> <span data-ttu-id="f747a-124">Dans cet état, une application peut configurer l'objet en définissant ses propriétés.</span><span class="sxs-lookup"><span data-stu-id="f747a-124">In this state, an application can configure the object by setting its properties.</span></span> <span data-ttu-id="f747a-125">Une fois qu'un objet est dans un état autre que Created, il est considéré comme immuable.</span><span class="sxs-lookup"><span data-stu-id="f747a-125">Once an object is in a state other than Created, it is considered immutable.</span></span>  
  
 <span data-ttu-id="f747a-126">![Transition d’état de canal](../../../../docs/framework/wcf/extending/media/channelstatetranitionshighleveldiagram.gif "ChannelStateTranitionsHighLevelDiagram")</span><span class="sxs-lookup"><span data-stu-id="f747a-126">![Channel state transitition](../../../../docs/framework/wcf/extending/media/channelstatetranitionshighleveldiagram.gif "ChannelStateTranitionsHighLevelDiagram")</span></span>  
<span data-ttu-id="f747a-127">Figure 1.</span><span class="sxs-lookup"><span data-stu-id="f747a-127">Figure 1.</span></span> <span data-ttu-id="f747a-128">Ordinateur d'état ICommunicationObject.</span><span class="sxs-lookup"><span data-stu-id="f747a-128">The ICommunicationObject State Machine.</span></span>  
  
 [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]<span data-ttu-id="f747a-129"> fournit une classe de base abstraite nommée <xref:System.ServiceModel.Channels.CommunicationObject> qui implémente <xref:System.ServiceModel.ICommunicationObject> et l'ordinateur d'état des canaux.</span><span class="sxs-lookup"><span data-stu-id="f747a-129"> provides an abstract base class named <xref:System.ServiceModel.Channels.CommunicationObject> that implements <xref:System.ServiceModel.ICommunicationObject> and the channel state machine.</span></span> <span data-ttu-id="f747a-130">Le graphique suivant est un diagramme d'état modifié qui est spécifique à <xref:System.ServiceModel.Channels.CommunicationObject>.</span><span class="sxs-lookup"><span data-stu-id="f747a-130">The following graphic is a modified state diagram that is specific to <xref:System.ServiceModel.Channels.CommunicationObject>.</span></span> <span data-ttu-id="f747a-131">Outre l'ordinateur d'état <xref:System.ServiceModel.ICommunicationObject>, il présente la temporisation lorsque des méthodes <xref:System.ServiceModel.Channels.CommunicationObject> supplémentaires sont appelées.</span><span class="sxs-lookup"><span data-stu-id="f747a-131">In addition to the <xref:System.ServiceModel.ICommunicationObject> state machine, it shows the timing when additional <xref:System.ServiceModel.Channels.CommunicationObject> methods are invoked.</span></span>  
  
 <span data-ttu-id="f747a-132">![Modifications d’état](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure5statetransitionsdetailsc.gif "wcfc_WCFChannelsigure5StateTransitionsDetailsc")</span><span class="sxs-lookup"><span data-stu-id="f747a-132">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure5statetransitionsdetailsc.gif "wcfc_WCFChannelsigure5StateTransitionsDetailsc")</span></span>  
<span data-ttu-id="f747a-133">Figure 2.</span><span class="sxs-lookup"><span data-stu-id="f747a-133">Figure 2.</span></span> <span data-ttu-id="f747a-134">Implémentation CommunicationObject de l'ordinateur d'état ICommunicationObject comprenant les appels d'événements et de méthodes protégées.</span><span class="sxs-lookup"><span data-stu-id="f747a-134">The CommunicationObject implementation of the ICommunicationObject state machine including calls to events and protected methods.</span></span>  
  
### <a name="icommunicationobject-events"></a><span data-ttu-id="f747a-135">Événements ICommunicationObject</span><span class="sxs-lookup"><span data-stu-id="f747a-135">ICommunicationObject Events</span></span>  
 <span data-ttu-id="f747a-136"><xref:System.ServiceModel.Channels.CommunicationObject> expose les cinq événements définis par <xref:System.ServiceModel.ICommunicationObject>.</span><span class="sxs-lookup"><span data-stu-id="f747a-136"><xref:System.ServiceModel.Channels.CommunicationObject> exposes the five events defined by <xref:System.ServiceModel.ICommunicationObject>.</span></span> <span data-ttu-id="f747a-137">Ces événements sont conçus pour le code à l'aide de l'objet de communication à notifier des transitions d'état.</span><span class="sxs-lookup"><span data-stu-id="f747a-137">These events are designed for code using the communication object to be notified of state transitions.</span></span> <span data-ttu-id="f747a-138">Comme l'illustre la figure 2 ci-dessus, chaque événement est déclenché une fois après la transition de l'état de l'objet vers l'état nommé par l'événement.</span><span class="sxs-lookup"><span data-stu-id="f747a-138">As shown in Figure 2 above, each event is fired once after the object’s state transitions to the state named by the event.</span></span> <span data-ttu-id="f747a-139">Les cinq événements sont tous du type `EventHandler` défini comme suit :</span><span class="sxs-lookup"><span data-stu-id="f747a-139">All five events are of the `EventHandler` type which is defined as:</span></span>  
  
 `public delegate void EventHandler(object sender, EventArgs e);`  
  
 <span data-ttu-id="f747a-140">Dans l'implémentation <xref:System.ServiceModel.Channels.CommunicationObject>, l'expéditeur est soit <xref:System.ServiceModel.Channels.CommunicationObject>, soit ce qui a été passé en tant qu'expéditeur au constructeur <xref:System.ServiceModel.Channels.CommunicationObject> (si la surcharge de ce constructeur a été utilisée).</span><span class="sxs-lookup"><span data-stu-id="f747a-140">In the <xref:System.ServiceModel.Channels.CommunicationObject> implementation, the sender is either the <xref:System.ServiceModel.Channels.CommunicationObject> itself or whatever was passed in as the sender to the <xref:System.ServiceModel.Channels.CommunicationObject> constructor (if that constructor overload was used).</span></span> <span data-ttu-id="f747a-141">Le paramètre EventArgs, `e`, a toujours la valeur `EventArgs.Empty`.</span><span class="sxs-lookup"><span data-stu-id="f747a-141">The EventArgs parameter, `e`, is always `EventArgs.Empty`.</span></span>  
  
### <a name="derived-object-callbacks"></a><span data-ttu-id="f747a-142">Rappels d'objets dérivés</span><span class="sxs-lookup"><span data-stu-id="f747a-142">Derived Object Callbacks</span></span>  
 <span data-ttu-id="f747a-143">Outre les cinq événements, <xref:System.ServiceModel.Channels.CommunicationObject> déclare huit méthodes virtuelles protégées conçues pour autoriser un objet dérivé à être rappelé avant et après les transitions d'état.</span><span class="sxs-lookup"><span data-stu-id="f747a-143">In addition to the five events, <xref:System.ServiceModel.Channels.CommunicationObject> declares eight protected virtual methods designed to allow a derived object to be called back before and after state transitions occur.</span></span>  
  
 <span data-ttu-id="f747a-144">Les méthodes <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> et <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> possèdent trois rappels de ce type associés avec chacune d'elles.</span><span class="sxs-lookup"><span data-stu-id="f747a-144">The <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> methods have three such callbacks associated with each of them.</span></span> <span data-ttu-id="f747a-145">Par exemple, en rapport avec <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType>, il y a <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType> et <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f747a-145">For example, corresponding to <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> there is <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f747a-146">En association avec <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> figurent les méthodes <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> et <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f747a-146">Associated with <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> are the <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="f747a-147">De même, la méthode <xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A?displayProperty=nameWithType> est associée à <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f747a-147">Similarly, the <xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A?displayProperty=nameWithType> method has a corresponding <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f747a-148">Alors que <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType> et <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType> n'ont aucune implémentation par défaut, les autres rappels en ont une qui est nécessaire pour que l'ordinateur d'état soit correct.</span><span class="sxs-lookup"><span data-stu-id="f747a-148">While <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType> have no default implementation, the other callbacks do have a default implementation which is necessary for state machine correctness.</span></span> <span data-ttu-id="f747a-149">Si vous substituez ces méthodes, veillez à appeler l'implémentation de base ou à la remplacer correctement.</span><span class="sxs-lookup"><span data-stu-id="f747a-149">If you override those methods be sure to call the base implementation or correctly replace it.</span></span>  
  
 <span data-ttu-id="f747a-150"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> et <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A?displayProperty=nameWithType> déclenchent les événements <xref:System.ServiceModel.Channels.CommunicationObject.Opening?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.Closing?displayProperty=nameWithType> et <xref:System.ServiceModel.Channels.CommunicationObject.Faulted?displayProperty=nameWithType> correspondants.</span><span class="sxs-lookup"><span data-stu-id="f747a-150"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A?displayProperty=nameWithType> fire the corresponding <xref:System.ServiceModel.Channels.CommunicationObject.Opening?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.Closing?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Faulted?displayProperty=nameWithType> events.</span></span> <span data-ttu-id="f747a-151"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType> et <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> définissent l'état de l'objet à Ouvert et Fermé respectivement, puis déclenchent les événements <xref:System.ServiceModel.Channels.CommunicationObject.Opened?displayProperty=nameWithType> et <xref:System.ServiceModel.Channels.CommunicationObject.Closed?displayProperty=nameWithType> correspondants.</span><span class="sxs-lookup"><span data-stu-id="f747a-151"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> set the object state to Opened and Closed respectively then fire the corresponding <xref:System.ServiceModel.Channels.CommunicationObject.Opened?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Closed?displayProperty=nameWithType> events.</span></span>  
  
### <a name="state-transition-methods"></a><span data-ttu-id="f747a-152">Méthodes de transition d'état</span><span class="sxs-lookup"><span data-stu-id="f747a-152">State Transition Methods</span></span>  
 <span data-ttu-id="f747a-153"><xref:System.ServiceModel.Channels.CommunicationObject> fournit des implémentations d'Abort, Close et Open.</span><span class="sxs-lookup"><span data-stu-id="f747a-153"><xref:System.ServiceModel.Channels.CommunicationObject> provides implementations of Abort, Close and Open.</span></span> <span data-ttu-id="f747a-154">Il fournit également une méthode Fault qui provoque une transition d'état vers l'état Faulted.</span><span class="sxs-lookup"><span data-stu-id="f747a-154">It also provides a Fault method which causes a state transition to the Faulted state.</span></span> <span data-ttu-id="f747a-155">La figure 2 illustre l'ordinateur d'état <xref:System.ServiceModel.ICommunicationObject> avec chaque transition étiquetée par la méthode qui la provoque (les transitions sans étiquette se produisent à l'intérieur de l'implémentation de la méthode qui a provoqué la dernière transition étiquetée).</span><span class="sxs-lookup"><span data-stu-id="f747a-155">Figure 2 shows the <xref:System.ServiceModel.ICommunicationObject> state machine with each transition labeled by the method that causes it (unlabeled transitions happen inside the implementation of the method that caused the last labeled transition).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f747a-156">Toutes les implémentations <xref:System.ServiceModel.Channels.CommunicationObject> d'obtentions/définitions d'état de communication sont synchronisées par thread.</span><span class="sxs-lookup"><span data-stu-id="f747a-156">All <xref:System.ServiceModel.Channels.CommunicationObject> implementations of communication state gets/sets are thread-synchronized.</span></span>  
  
 <span data-ttu-id="f747a-157">Constructeur</span><span class="sxs-lookup"><span data-stu-id="f747a-157">Constructor</span></span>  
  
 <span data-ttu-id="f747a-158"><xref:System.ServiceModel.Channels.CommunicationObject> fournit trois constructeurs, qui laissent tous l'objet dans l'état Created.</span><span class="sxs-lookup"><span data-stu-id="f747a-158"><xref:System.ServiceModel.Channels.CommunicationObject> provides three constructors, all of which leave the object in the Created state.</span></span> <span data-ttu-id="f747a-159">Les constructeurs sont définis comme suit :</span><span class="sxs-lookup"><span data-stu-id="f747a-159">The constructors are defined as:</span></span>  
  
 <span data-ttu-id="f747a-160">Le premier constructeur est un constructeur par défaut qui délègue à la surcharge du constructeur qui prend un objet :</span><span class="sxs-lookup"><span data-stu-id="f747a-160">The first constructor is a default constructor that delegates to the constructor overload that takes an object:</span></span>  
  
 `protected CommunicationObject() : this(new object()) { … }`  
  
 <span data-ttu-id="f747a-161">Le constructeur qui prend un objet utilise ce paramètre comme objet à verrouiller lors de la synchronisation de l’accès à l’état de l’objet de communication :</span><span class="sxs-lookup"><span data-stu-id="f747a-161">The constructor that takes an object uses that parameter as the object to be locked when synchronizing access to communication object state:</span></span>  
  
 `protected CommunicationObject(object mutex) { … }`  
  
 <span data-ttu-id="f747a-162">Enfin, un troisième constructeur prend un paramètre supplémentaire utilisé comme argument d'expéditeur lorsque des événements <xref:System.ServiceModel.ICommunicationObject> sont déclenchés.</span><span class="sxs-lookup"><span data-stu-id="f747a-162">Finally, a third constructor takes an additional parameter that is used as the sender argument when <xref:System.ServiceModel.ICommunicationObject> events are fired.</span></span>  
  
 `protected CommunicationObject(object mutex, object eventSender) { … }`  
  
 <span data-ttu-id="f747a-163">Les deux constructeurs précédents affectent cette valeur à l'expéditeur.</span><span class="sxs-lookup"><span data-stu-id="f747a-163">The previous two constructors set the sender to this.</span></span>  
  
 <span data-ttu-id="f747a-164">Méthode Open</span><span class="sxs-lookup"><span data-stu-id="f747a-164">Open Method</span></span>  
  
 <span data-ttu-id="f747a-165">Condition préalable : l'état est Created.</span><span class="sxs-lookup"><span data-stu-id="f747a-165">Precondition: State is Created.</span></span>  
  
 <span data-ttu-id="f747a-166">Post-condition : l'état est Opened ou Faulted.</span><span class="sxs-lookup"><span data-stu-id="f747a-166">Post-condition: State is Opened or Faulted.</span></span> <span data-ttu-id="f747a-167">Peut lever une exception.</span><span class="sxs-lookup"><span data-stu-id="f747a-167">May throw an exception.</span></span>  
  
 <span data-ttu-id="f747a-168">La méthode Open() essaiera d'ouvrir l'objet de communication et d'affecter la valeur Opened à l'état.</span><span class="sxs-lookup"><span data-stu-id="f747a-168">The Open() method will try to open the communication object and set the state to Opened.</span></span> <span data-ttu-id="f747a-169">Si elle rencontre une erreur, elle affectera la valeur Faulted à l'état.</span><span class="sxs-lookup"><span data-stu-id="f747a-169">If it encounters an error, it will set the state to Faulted.</span></span>  
  
 <span data-ttu-id="f747a-170">La méthode vérifie d'abord que l'état actuel est Created.</span><span class="sxs-lookup"><span data-stu-id="f747a-170">The method first checks that the current state is Created.</span></span> <span data-ttu-id="f747a-171">Si l'état actuel est Opening ou Opened, elle lève une <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="f747a-171">If the current state is Opening or Opened it throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="f747a-172">Si l'état actuel est Closing ou Closed, elle lève une <xref:System.ServiceModel.CommunicationObjectAbortedException> si l'objet a été arrêté et une <xref:System.ObjectDisposedException> sinon.</span><span class="sxs-lookup"><span data-stu-id="f747a-172">If the current state is Closing or Closed, it throws a <xref:System.ServiceModel.CommunicationObjectAbortedException> if the object has been terminated and <xref:System.ObjectDisposedException> otherwise.</span></span> <span data-ttu-id="f747a-173">Si l'état actuel est Faulted, elle lève une <xref:System.ServiceModel.CommunicationObjectFaultedException>.</span><span class="sxs-lookup"><span data-stu-id="f747a-173">If the current state is Faulted, it throws a <xref:System.ServiceModel.CommunicationObjectFaultedException>.</span></span>  
  
 <span data-ttu-id="f747a-174">Elle affecte ensuite la valeur Opening à l'état et appelle OnOpening() (laquelle déclenche l'événement Opening), OnOpen() et OnOpened() dans cet ordre.</span><span class="sxs-lookup"><span data-stu-id="f747a-174">It then sets the state to Opening and calls OnOpening() (which raises the Opening event), OnOpen() and OnOpened() in that order.</span></span> <span data-ttu-id="f747a-175">OnOpened() affecte la valeur Opened à l'état et déclenche l'événement Opened.</span><span class="sxs-lookup"><span data-stu-id="f747a-175">OnOpened() sets the state to Opened and raises the Opened event.</span></span> <span data-ttu-id="f747a-176">Si l'un de ces appels lève une exception, Open() appelle Fault() et permet à l'exception de se propager.</span><span class="sxs-lookup"><span data-stu-id="f747a-176">If any of these throws an exception, Open()calls Fault() and lets the exception bubble up.</span></span> <span data-ttu-id="f747a-177">Le diagramme suivant présente le processus Open de manière plus détaillée.</span><span class="sxs-lookup"><span data-stu-id="f747a-177">The following diagram shows the Open process in more detail.</span></span>  
  
 <span data-ttu-id="f747a-178">![Modifications d’état](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigurecoopenflowchartf.gif "wcfc_WCFChannelsigureCOOpenFlowChartf")</span><span class="sxs-lookup"><span data-stu-id="f747a-178">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigurecoopenflowchartf.gif "wcfc_WCFChannelsigureCOOpenFlowChartf")</span></span>  
<span data-ttu-id="f747a-179">Substituez la méthode OnOpen pour implémenter une logique d'ouverture personnalisée telle que l'ouverture d'un objet de communication interne.</span><span class="sxs-lookup"><span data-stu-id="f747a-179">Override the OnOpen method to implement custom open logic such as opening an inner communication object.</span></span>  
  
 <span data-ttu-id="f747a-180">Close, méthode</span><span class="sxs-lookup"><span data-stu-id="f747a-180">Close Method</span></span>  
  
 <span data-ttu-id="f747a-181">Condition préalable : aucune.</span><span class="sxs-lookup"><span data-stu-id="f747a-181">Precondition: None.</span></span>  
  
 <span data-ttu-id="f747a-182">Post-condition : l'état est Closed.</span><span class="sxs-lookup"><span data-stu-id="f747a-182">Post-condition: State is Closed.</span></span> <span data-ttu-id="f747a-183">Peut lever une exception.</span><span class="sxs-lookup"><span data-stu-id="f747a-183">May throw an exception.</span></span>  
  
 <span data-ttu-id="f747a-184">La méthode Close() peut être appelée à tous les états.</span><span class="sxs-lookup"><span data-stu-id="f747a-184">The Close() method can be called at any state.</span></span> <span data-ttu-id="f747a-185">Elle essaie de fermer normalement l'objet.</span><span class="sxs-lookup"><span data-stu-id="f747a-185">It tries to close the object normally.</span></span> <span data-ttu-id="f747a-186">Si une erreur est rencontrée, elle arrête l'objet.</span><span class="sxs-lookup"><span data-stu-id="f747a-186">If an error is encountered, it terminates the object.</span></span> <span data-ttu-id="f747a-187">La méthode ne fait rien si l'état actuel est Closing ou Closed.</span><span class="sxs-lookup"><span data-stu-id="f747a-187">The method does nothing if the current state is Closing or Closed.</span></span> <span data-ttu-id="f747a-188">Sinon, elle affecte la valeur Closing à l'état.</span><span class="sxs-lookup"><span data-stu-id="f747a-188">Otherwise it sets the state to Closing.</span></span> <span data-ttu-id="f747a-189">Si l'état d'origine est Created, Opening ou Faulted, elle appelle Abort() (voir le diagramme suivant).</span><span class="sxs-lookup"><span data-stu-id="f747a-189">If the original state was Created, Opening or Faulted, it calls Abort() (see the following diagram).</span></span> <span data-ttu-id="f747a-190">Si l'état d'origine est Opened, elle appelle OnClosing() (laquelle déclenche l'événement Closing), OnClose() et OnClosed() dans cet ordre.</span><span class="sxs-lookup"><span data-stu-id="f747a-190">If the original state was Opened, it calls OnClosing() (which raises the Closing event), OnClose() and OnClosed() in that order.</span></span> <span data-ttu-id="f747a-191">Si l'un de ces appels lève une exception, Close() appelle Abort() et permet à l'exception de se propager.</span><span class="sxs-lookup"><span data-stu-id="f747a-191">If any of these throws an exception, Close()calls Abort() and lets the exception bubble up.</span></span> <span data-ttu-id="f747a-192">OnClosed() affecte la valeur Closed à l'état et déclenche l'événement Closed.</span><span class="sxs-lookup"><span data-stu-id="f747a-192">OnClosed() sets the state to Closed and raises the Closed event.</span></span> <span data-ttu-id="f747a-193">Le diagramme suivant présente le processus Close de manière plus détaillée.</span><span class="sxs-lookup"><span data-stu-id="f747a-193">The following diagram shows the Close process in more detail.</span></span>  
  
 <span data-ttu-id="f747a-194">![Modifications d’état](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsguire7ico-closeflowchartc.gif "wcfc_WCFChannelsguire7ICO-CloseFlowChartc")</span><span class="sxs-lookup"><span data-stu-id="f747a-194">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsguire7ico-closeflowchartc.gif "wcfc_WCFChannelsguire7ICO-CloseFlowChartc")</span></span>  
<span data-ttu-id="f747a-195">Substituez la méthode OnClose pour implémenter une logique de fermeture personnalisée telle que la fermeture d'un objet de communication interne.</span><span class="sxs-lookup"><span data-stu-id="f747a-195">Override the OnClose method to implement custom close logic, such as closing an inner communication object.</span></span> <span data-ttu-id="f747a-196">Toute la logique de fermeture normale, susceptible d'être bloquée pendant longtemps (par exemple, en attendant la réponse de l'autre côté), doit être implémentée dans OnClose() parce qu'un paramètre de délai d'attente est nécessaire et parce qu'elle n'est pas appelée dans le cadre d'Abort().</span><span class="sxs-lookup"><span data-stu-id="f747a-196">All graceful closing logic that may block for a long time (for example, waiting for the other side to respond) should be implemented in OnClose() because it takes a timeout parameter and because it is not called as part of Abort().</span></span>  
  
 <span data-ttu-id="f747a-197">Abandonner</span><span class="sxs-lookup"><span data-stu-id="f747a-197">Abort</span></span>  
  
 <span data-ttu-id="f747a-198">Condition préalable : aucune.</span><span class="sxs-lookup"><span data-stu-id="f747a-198">Precondition: None.</span></span>  
<span data-ttu-id="f747a-199">Post-condition : l'état est Closed.</span><span class="sxs-lookup"><span data-stu-id="f747a-199">Post-condition: State is Closed.</span></span> <span data-ttu-id="f747a-200">Peut lever une exception.</span><span class="sxs-lookup"><span data-stu-id="f747a-200">May throw an exception.</span></span>  
  
 <span data-ttu-id="f747a-201">La méthode Abort() ne fait rien si l'état actuel est Closed ou si l'objet a été arrêté avant (par exemple, en faisant exécuter Abort() sur un autre thread).</span><span class="sxs-lookup"><span data-stu-id="f747a-201">The Abort() method does nothing if the current state is Closed or if the object has been terminated before (for example, possibly by having Abort() executing on another thread).</span></span> <span data-ttu-id="f747a-202">Sinon, elle affecte la valeur Closing à l'état et appelle OnClosing() (laquelle déclenche l'événement Closing), OnAbort() et OnClosed() dans cet ordre (elle n'appelle pas OnClose parce que l'objet est arrêté, mais pas fermé).</span><span class="sxs-lookup"><span data-stu-id="f747a-202">Otherwise it sets the state to Closing and calls OnClosing() (which raises the Closing event), OnAbort(), and OnClosed() in that order (does not call OnClose because the object is being terminated, not closed).</span></span> <span data-ttu-id="f747a-203">OnClosed() affecte la valeur Closed à l'état et déclenche l'événement Closed.</span><span class="sxs-lookup"><span data-stu-id="f747a-203">OnClosed() sets the state to Closed and raises the Closed event.</span></span> <span data-ttu-id="f747a-204">En cas de levée d'une exception, celle-ci est à nouveau levée pour l'appelant d'Abort.</span><span class="sxs-lookup"><span data-stu-id="f747a-204">If any of these throw an exception, it is re-thrown to the caller of Abort.</span></span> <span data-ttu-id="f747a-205">Les implémentations d'OnClosing(), OnClosed() et OnAbort() ne doivent pas bloquer (par exemple, lors de l'entrée/sortie).</span><span class="sxs-lookup"><span data-stu-id="f747a-205">Implementations of OnClosing(), OnClosed() and OnAbort() should not block (for example, on input/output).</span></span> <span data-ttu-id="f747a-206">Le diagramme suivant présente le processus Abort de manière plus détaillée.</span><span class="sxs-lookup"><span data-stu-id="f747a-206">The following diagram shows the Abort process in more detail.</span></span>  
  
 <span data-ttu-id="f747a-207">![Modifications d’état](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure8ico-abortflowchartc.gif "wcfc_WCFChannelsigure8ICO-AbortFlowChartc")</span><span class="sxs-lookup"><span data-stu-id="f747a-207">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure8ico-abortflowchartc.gif "wcfc_WCFChannelsigure8ICO-AbortFlowChartc")</span></span>  
<span data-ttu-id="f747a-208">Substituez la méthode OnAbort pour implémenter une logique d'arrêt personnalisée telle que l'arrêt d'un objet de communication interne.</span><span class="sxs-lookup"><span data-stu-id="f747a-208">Override the OnAbort method to implement custom terminate logic such as terminating an inner communication object.</span></span>  
  
 <span data-ttu-id="f747a-209">Fault</span><span class="sxs-lookup"><span data-stu-id="f747a-209">Fault</span></span>  
  
 <span data-ttu-id="f747a-210">La méthode Fault est propre à <xref:System.ServiceModel.Channels.CommunicationObject> et ne fait pas partie de l'interface <xref:System.ServiceModel.ICommunicationObject>.</span><span class="sxs-lookup"><span data-stu-id="f747a-210">The Fault method is specific to <xref:System.ServiceModel.Channels.CommunicationObject> and is not part of the <xref:System.ServiceModel.ICommunicationObject> interface.</span></span> <span data-ttu-id="f747a-211">Elle est incluse ici par souci d'exhaustivité.</span><span class="sxs-lookup"><span data-stu-id="f747a-211">It is included here for completeness.</span></span>  
  
 <span data-ttu-id="f747a-212">Condition préalable : aucune.</span><span class="sxs-lookup"><span data-stu-id="f747a-212">Precondition: None.</span></span>  
  
 <span data-ttu-id="f747a-213">Post-condition : l'état est Faulted.</span><span class="sxs-lookup"><span data-stu-id="f747a-213">Post-condition: State is Faulted.</span></span> <span data-ttu-id="f747a-214">Peut lever une exception.</span><span class="sxs-lookup"><span data-stu-id="f747a-214">May throw an exception.</span></span>  
  
 <span data-ttu-id="f747a-215">La méthode Fault() ne fait rien si l'état actuel est Faulted ou Closed.</span><span class="sxs-lookup"><span data-stu-id="f747a-215">The Fault() method does nothing if the current state is Faulted or Closed.</span></span> <span data-ttu-id="f747a-216">Sinon, elle affecte la valeur Faulted à l'état et appelle OnFaulted(), laquelle déclenche l'événement Faulted.</span><span class="sxs-lookup"><span data-stu-id="f747a-216">Otherwise it sets the state to Faulted and call OnFaulted(), which raises the Faulted event.</span></span> <span data-ttu-id="f747a-217">Si OnFaulted lève une exception, elle est à nouveau levée.</span><span class="sxs-lookup"><span data-stu-id="f747a-217">If OnFaulted throws an exception it is re-thrown.</span></span>  
  
### <a name="throwifxxx-methods"></a><span data-ttu-id="f747a-218">Méthodes ThrowIfXxx</span><span class="sxs-lookup"><span data-stu-id="f747a-218">ThrowIfXxx Methods</span></span>  
 <span data-ttu-id="f747a-219">CommunicationObject possède trois méthodes protégées qui peuvent être utilisées pour lever des exceptions si l'objet est dans un état spécifique.</span><span class="sxs-lookup"><span data-stu-id="f747a-219">CommunicationObject has three protected methods that can be used to throw exceptions if the object is in a specific state.</span></span>  
  
 <span data-ttu-id="f747a-220"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposed%2A> lève une exception si l'état est Closing, Closed ou Faulted.</span><span class="sxs-lookup"><span data-stu-id="f747a-220"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposed%2A> throws an exception if the state is Closing, Closed or Faulted.</span></span>  
  
 <span data-ttu-id="f747a-221"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrImmutable%2A> lève une exception si l'état n'est pas Created.</span><span class="sxs-lookup"><span data-stu-id="f747a-221"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrImmutable%2A> throws an exception if the state is not Created.</span></span>  
  
 <span data-ttu-id="f747a-222"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrNotOpen%2A> lève une exception si l'état n'est pas Opened.</span><span class="sxs-lookup"><span data-stu-id="f747a-222"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrNotOpen%2A> throws an exception if the state is not Opened.</span></span>  
  
 <span data-ttu-id="f747a-223">Les exceptions levées dépendent de l'état.</span><span class="sxs-lookup"><span data-stu-id="f747a-223">The exceptions thrown depend on the state.</span></span> <span data-ttu-id="f747a-224">Le tableau suivant présente les différents états et le type d'exception correspondant levé en appelant une méthode ThrowIfXxx qui lève sur cet état.</span><span class="sxs-lookup"><span data-stu-id="f747a-224">The following table shows the different states and the corresponding exception type thrown by calling a ThrowIfXxx that throws on that state.</span></span>  
  
|<span data-ttu-id="f747a-225">État</span><span class="sxs-lookup"><span data-stu-id="f747a-225">State</span></span>|<span data-ttu-id="f747a-226">La méthode Abort a-t-elle été appelée ?</span><span class="sxs-lookup"><span data-stu-id="f747a-226">Has Abort been called?</span></span>|<span data-ttu-id="f747a-227">Exception</span><span class="sxs-lookup"><span data-stu-id="f747a-227">Exception</span></span>|  
|-----------|----------------------------|---------------|  
|<span data-ttu-id="f747a-228">Créé le</span><span class="sxs-lookup"><span data-stu-id="f747a-228">Created</span></span>|<span data-ttu-id="f747a-229">N/A</span><span class="sxs-lookup"><span data-stu-id="f747a-229">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="f747a-230">Opening</span><span class="sxs-lookup"><span data-stu-id="f747a-230">Opening</span></span>|<span data-ttu-id="f747a-231">N/A</span><span class="sxs-lookup"><span data-stu-id="f747a-231">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="f747a-232">Opened</span><span class="sxs-lookup"><span data-stu-id="f747a-232">Opened</span></span>|<span data-ttu-id="f747a-233">N/A</span><span class="sxs-lookup"><span data-stu-id="f747a-233">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="f747a-234">Closing</span><span class="sxs-lookup"><span data-stu-id="f747a-234">Closing</span></span>|<span data-ttu-id="f747a-235">Oui</span><span class="sxs-lookup"><span data-stu-id="f747a-235">Yes</span></span>|<xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType>|  
|<span data-ttu-id="f747a-236">Closing</span><span class="sxs-lookup"><span data-stu-id="f747a-236">Closing</span></span>|<span data-ttu-id="f747a-237">Non</span><span class="sxs-lookup"><span data-stu-id="f747a-237">No</span></span>|<xref:System.ObjectDisposedException?displayProperty=nameWithType>|  
|<span data-ttu-id="f747a-238">Closed</span><span class="sxs-lookup"><span data-stu-id="f747a-238">Closed</span></span>|<span data-ttu-id="f747a-239">Oui</span><span class="sxs-lookup"><span data-stu-id="f747a-239">Yes</span></span>|<span data-ttu-id="f747a-240"><xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType> dans le cas où un objet aurait été fermé par un appel précédent et explicite d'Abort.</span><span class="sxs-lookup"><span data-stu-id="f747a-240"><xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType> in the case that an object was closed by a previous and explicit call of Abort.</span></span> <span data-ttu-id="f747a-241">Si vous appelez Close sur l'objet, alors une <xref:System.ObjectDisposedException?displayProperty=nameWithType> est levée.</span><span class="sxs-lookup"><span data-stu-id="f747a-241">If you call Close on the object then an <xref:System.ObjectDisposedException?displayProperty=nameWithType> is thrown.</span></span>|  
|<span data-ttu-id="f747a-242">Fermé</span><span class="sxs-lookup"><span data-stu-id="f747a-242">Closed</span></span>|<span data-ttu-id="f747a-243">Non</span><span class="sxs-lookup"><span data-stu-id="f747a-243">No</span></span>|<xref:System.ObjectDisposedException?displayProperty=nameWithType>|  
|<span data-ttu-id="f747a-244">Faulted</span><span class="sxs-lookup"><span data-stu-id="f747a-244">Faulted</span></span>|<span data-ttu-id="f747a-245">N/A</span><span class="sxs-lookup"><span data-stu-id="f747a-245">N/A</span></span>|<xref:System.ServiceModel.CommunicationObjectFaultedException?displayProperty=nameWithType>|  
  
### <a name="timeouts"></a><span data-ttu-id="f747a-246">Délais d'attente</span><span class="sxs-lookup"><span data-stu-id="f747a-246">Timeouts</span></span>  
 <span data-ttu-id="f747a-247">Plusieurs des méthodes présentées prennent des paramètres de délai d'attente.</span><span class="sxs-lookup"><span data-stu-id="f747a-247">Several of the methods we discussed take timeout parameters.</span></span> <span data-ttu-id="f747a-248">Ces paramètres sont Close, Open (certaines surcharges et versions asynchrones), OnClose et OnOpen.</span><span class="sxs-lookup"><span data-stu-id="f747a-248">These are Close, Open (certain overloads and asynchronous versions), OnClose and OnOpen.</span></span> <span data-ttu-id="f747a-249">Ces méthodes sont conçues pour tenir compte des longues opérations (par exemple, un blocage sur l'entrée/sortie pendant l'arrêt normal d'une connexion), donc le paramètre de délai d'attente indique la durée maximale de ces opérations avant leur interruption.</span><span class="sxs-lookup"><span data-stu-id="f747a-249">These methods are designed to allow for lengthy operations (for example, blocking on input/output while gracefully closing down a connection) so the timeout parameter indicates how long such operations can take before being interrupted.</span></span> <span data-ttu-id="f747a-250">Les implémentations de chacune de ces méthodes doivent utiliser la valeur du délai d'attente fournie pour garantir le renvoi à l'appelant à l'issue de ce délai d'attente.</span><span class="sxs-lookup"><span data-stu-id="f747a-250">Implementations of any of these methods should use the supplied timeout value to ensure it returns to the caller within that timeout.</span></span> <span data-ttu-id="f747a-251">Les implémentations d'autres méthodes qui ne prennent pas de délai d'attente ne sont pas conçues pour les opérations longues et ne doivent pas bloquer sur l'entrée/sortie.</span><span class="sxs-lookup"><span data-stu-id="f747a-251">Implementations of other methods that do not take a timeout are not designed for lengthy operations and should not block on input/output.</span></span>  
  
 <span data-ttu-id="f747a-252">Les surcharges Open() et Close() qui ne prennent pas de délai d'attente font exception.</span><span class="sxs-lookup"><span data-stu-id="f747a-252">The exception are the Open() and Close() overloads that do not take a timeout.</span></span> <span data-ttu-id="f747a-253">Elles utilisent une valeur de délai par défaut fournie par la classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="f747a-253">These use a default timeout value supplied by the derived class.</span></span> <span data-ttu-id="f747a-254"><xref:System.ServiceModel.Channels.CommunicationObject> expose deux propriétés abstraites protégées nommées <xref:System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout%2A> et <xref:System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout%2A> définies comme suit :</span><span class="sxs-lookup"><span data-stu-id="f747a-254"><xref:System.ServiceModel.Channels.CommunicationObject> exposes two protected abstract properties named <xref:System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout%2A> defined as:</span></span>  
  
 `protected abstract TimeSpan DefaultCloseTimeout { get; }`  
  
 `protected abstract TimeSpan DefaultOpenTimeout { get; }`  
  
 <span data-ttu-id="f747a-255">Une classe dérivée implémente ces propriétés pour fournir le délai d'attente par défaut pour les surcharges Open() et Close() qui ne prennent pas de valeur de délai d'attente.</span><span class="sxs-lookup"><span data-stu-id="f747a-255">A derived class implements these properties to provide the default timeout for the Open() and Close() overloads that do not take a timeout value.</span></span> <span data-ttu-id="f747a-256">Ensuite, les implémentations Open() et Close() délèguent à la surcharge qui prend un délai d'attente en la transmettant à la valeur de délai d'attente par défaut, par exemple :</span><span class="sxs-lookup"><span data-stu-id="f747a-256">Then the Open() and Close() implementations delegate to the overload that takes a timeout passing it the default timeout value, for example:</span></span>  
  
 `public void Open()`  
  
 `{`  
  
 `this.Open(this.DefaultOpenTimeout);`  
  
 `}`  
  
#### <a name="idefaultcommunicationtimeouts"></a><span data-ttu-id="f747a-257">IDefaultCommunicationTimeouts</span><span class="sxs-lookup"><span data-stu-id="f747a-257">IDefaultCommunicationTimeouts</span></span>  
 <span data-ttu-id="f747a-258">Cette interface possède quatre propriétés en lecture seule pour fournir des valeurs de délai d'attente par défaut pour l'ouverture, l'envoi, la réception et la fermeture.</span><span class="sxs-lookup"><span data-stu-id="f747a-258">This interface has four read-only properties for providing default timeout values for open, send, receive, and close.</span></span> <span data-ttu-id="f747a-259">Chaque implémentation est chargée d'obtenir les valeurs par défaut de quelque manière appropriée que ce soit.</span><span class="sxs-lookup"><span data-stu-id="f747a-259">Each implementation is responsible for obtaining the default values in whatever manner appropriate.</span></span> <span data-ttu-id="f747a-260">Par commodité, <xref:System.ServiceModel.Channels.ChannelFactoryBase> et <xref:System.ServiceModel.Channels.ChannelListenerBase> utilisent par défaut 1 minute pour chacune de ces valeurs.</span><span class="sxs-lookup"><span data-stu-id="f747a-260">As a convenience, <xref:System.ServiceModel.Channels.ChannelFactoryBase> and <xref:System.ServiceModel.Channels.ChannelListenerBase> default these values to 1 minute each.</span></span>
