---
title: "Types XML et ADO.NET dans les contrats de données"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
ms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6
caps.latest.revision: "7"
author: Erikre
ms.author: erikre
manager: erikre
ms.openlocfilehash: 9bc54b4f2a29f9fd082bafd7cf6007441365c35c
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/21/2017
---
# <a name="xml-and-adonet-types-in-data-contracts"></a><span data-ttu-id="cfe97-102">Types XML et ADO.NET dans les contrats de données</span><span class="sxs-lookup"><span data-stu-id="cfe97-102">XML and ADO.NET Types in Data Contracts</span></span>
<span data-ttu-id="cfe97-103">Le modèle de contrat de données [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] prend en charge certains types qui représentent directement du XML.</span><span class="sxs-lookup"><span data-stu-id="cfe97-103">The [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] data contract model supports certain types that represent XML directly.</span></span> <span data-ttu-id="cfe97-104">Lorsque ces types sont sérialisés en XML, le sérialiseur écrit le contenu XML de ces types sans traitement supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="cfe97-104">When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.</span></span> <span data-ttu-id="cfe97-105">Les types pris en charge sont <xref:System.Xml.XmlElement>, les tableaux de <xref:System.Xml.XmlNode> (mais pas le type `XmlNode` lui-même), ainsi que les types qui implémentent <xref:System.Xml.Serialization.IXmlSerializable>.</span><span class="sxs-lookup"><span data-stu-id="cfe97-105">Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span> <span data-ttu-id="cfe97-106">Le type <xref:System.Data.DataSet> et <xref:System.Data.DataTable>, ainsi que les groupes de données typés, sont utilisés couramment dans la programmation de base de données.</span><span class="sxs-lookup"><span data-stu-id="cfe97-106">The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming.</span></span> <span data-ttu-id="cfe97-107">Ces types implémentent l'interface `IXmlSerializable` et sont par conséquent sérialisables dans le modèle de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="cfe97-107">These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model.</span></span> <span data-ttu-id="cfe97-108">Des considérations particulières pour ces types sont répertoriées à la fin de cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="cfe97-108">Some special considerations for these types are listed at the end of this topic.</span></span>  
  
## <a name="xml-types"></a><span data-ttu-id="cfe97-109">Types XML</span><span class="sxs-lookup"><span data-stu-id="cfe97-109">XML Types</span></span>  
  
### <a name="xml-element"></a><span data-ttu-id="cfe97-110">Élément xml</span><span class="sxs-lookup"><span data-stu-id="cfe97-110">Xml Element</span></span>  
 <span data-ttu-id="cfe97-111">Le type `XmlElement` est sérialisé à l'aide de son contenu XML.</span><span class="sxs-lookup"><span data-stu-id="cfe97-111">The `XmlElement` type is serialized using its XML contents.</span></span> <span data-ttu-id="cfe97-112">Par exemple, utilisez le type ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="cfe97-112">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#4)]
 [!code-vb[DataContractAttribute#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#4)]  
  
 <span data-ttu-id="cfe97-113">Ce type est sérialisé en XML comme suit :</span><span class="sxs-lookup"><span data-stu-id="cfe97-113">This is serialized to XML as follows:</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
    <myDataMember>  
        <myElement xmlns="" myAttribute="myValue">  
            myContents  
        </myElement>  
    </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="cfe97-114">Notez qu'un élément du membre de données du wrapper `<myDataMember>` est encore présent.</span><span class="sxs-lookup"><span data-stu-id="cfe97-114">Notice that a wrapper data member element `<myDataMember>` is still present.</span></span> <span data-ttu-id="cfe97-115">Il est impossible de supprimer cet élément dans le modèle de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="cfe97-115">There is no way of removing this element in the data contract model.</span></span> <span data-ttu-id="cfe97-116">Les sérialiseurs qui gèrent ce modèle (<xref:System.Runtime.Serialization.DataContractSerializer> et <xref:System.Runtime.Serialization.NetDataContractSerializer>) peuvent émettre des attributs spéciaux dans cet élément wrapper.</span><span class="sxs-lookup"><span data-stu-id="cfe97-116">The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element.</span></span> <span data-ttu-id="cfe97-117">Ces attributs incluent l'attribut « nil » de l'instance de schéma Xml standard (qui permet à `XmlElement` d'être `null`) et l'attribut « type" (qui permet une utilisation polymorphe de `XmlElement`).</span><span class="sxs-lookup"><span data-stu-id="cfe97-117">These attributes include the standard XML Schema Instance "nil" attribute (allowing the `XmlElement` to be `null`) and the "type" attribute (allowing `XmlElement` to be used polymorphically).</span></span> <span data-ttu-id="cfe97-118">De plus, les attributs XML suivants sont spécifiques à [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] :« Id », « Ref », « Type » et « Assembly ».</span><span class="sxs-lookup"><span data-stu-id="cfe97-118">Also, the following XML attributes are specific to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]: "Id", "Ref", "Type" and "Assembly".</span></span> <span data-ttu-id="cfe97-119">Ces attributs peuvent être émis pour prendre en charge l'utilisation de `XmlElement` avec le mode de conservation des graphiques d'objet activé ou avec <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="cfe97-119">These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="cfe97-120">([!INCLUDE[crabout](../../../../includes/crabout-md.md)] le mode de conservation de l’objet graphique, consultez [sérialisation et désérialisation](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span><span class="sxs-lookup"><span data-stu-id="cfe97-120">([!INCLUDE[crabout](../../../../includes/crabout-md.md)] the object graph preservation mode, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span></span>  
  
 <span data-ttu-id="cfe97-121">Les tableaux ou les collections de `XmlElement` sont autorisés et gérés comme les autres tableaux ou collections.</span><span class="sxs-lookup"><span data-stu-id="cfe97-121">Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection.</span></span> <span data-ttu-id="cfe97-122">Autrement dit, il y a un élément wrapper pour la collection entière, et un élément wrapper séparé (semblable à `<myDataMember>` dans l'exemple précédent) pour chaque `XmlElement` du tableau.</span><span class="sxs-lookup"><span data-stu-id="cfe97-122">That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array.</span></span>  
  
 <span data-ttu-id="cfe97-123">Au moment de la désérialisation, un `XmlElement` est créé par le désérialiseur à partir du XML entrant.</span><span class="sxs-lookup"><span data-stu-id="cfe97-123">On deserialization, an `XmlElement` is created by the deserializer from the incoming XML.</span></span> <span data-ttu-id="cfe97-124">Un parent valide <xref:System.Xml.XmlDocument> est fourni par le désérialiseur.</span><span class="sxs-lookup"><span data-stu-id="cfe97-124">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span>  
  
 <span data-ttu-id="cfe97-125">Veillez à ce que le fragment XML qui est désérialisé en `XmlElement` définit tous les préfixes qu'il utilise et ne repose pas sur des définitions de préfixe d'éléments ancêtres.</span><span class="sxs-lookup"><span data-stu-id="cfe97-125">Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.</span></span> <span data-ttu-id="cfe97-126">Ce problème se pose uniquement au cours de l'utilisation du `DataContractSerializer` pour accéder au XML d'une source différente (qui n'est pas `DataContractSerializer`).</span><span class="sxs-lookup"><span data-stu-id="cfe97-126">This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source.</span></span>  
  
 <span data-ttu-id="cfe97-127">Lorsqu’il est utilisé avec le `DataContractSerializer`, le `XmlElement` peuvent être affectés de manière polymorphe, mais uniquement à un membre de données de type <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="cfe97-127">When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>.</span></span> <span data-ttu-id="cfe97-128">Même s'il implémente <xref:System.Collections.IEnumerable>, un `XmlElement` ne peut pas être utilisé comme un type de collection et ne peut pas être assigné à un membre de données <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="cfe97-128">Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member.</span></span> <span data-ttu-id="cfe97-129">Comme avec toutes les assignations polymorphes, le `DataContractSerializer` émet le nom de contrat de données dans le XML résultant. Dans ce cas, « XmlElement » est dans l'espace de noms « http://schemas.datacontract.org/2004/07/System.Xml ».</span><span class="sxs-lookup"><span data-stu-id="cfe97-129">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "XmlElement" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span>  
  
 <span data-ttu-id="cfe97-130">Avec le `NetDataContractSerializer`, toute assignation polymorphe valide de `XmlElement` (à `Object` ou `IEnumerable`) est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="cfe97-130">With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported.</span></span>  
  
 <span data-ttu-id="cfe97-131">N'essayez pas d'utiliser l'un ou l'autre sérialiseur avec des types dérivés de `XmlElement`, qu'il soit assigné de manière polymorphe ou non.</span><span class="sxs-lookup"><span data-stu-id="cfe97-131">Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not.</span></span>  
  
### <a name="array-of-xmlnode"></a><span data-ttu-id="cfe97-132">Tableau de XmlNode</span><span class="sxs-lookup"><span data-stu-id="cfe97-132">Array of XmlNode</span></span>  
 <span data-ttu-id="cfe97-133">L'utilisation de tableaux de <xref:System.Xml.XmlNode> est très semblable à l'utilisation de `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-133">Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`.</span></span> <span data-ttu-id="cfe97-134">Utiliser les tableaux de `XmlNode` offre plus de souplesse que `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-134">Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`.</span></span> <span data-ttu-id="cfe97-135">Vous pouvez écrire plusieurs éléments à l'intérieur de l'élément d'habillage du membre de données.</span><span class="sxs-lookup"><span data-stu-id="cfe97-135">You can write multiple elements inside the data member wrapping element.</span></span> <span data-ttu-id="cfe97-136">Vous pouvez injecter également un autre contenu que des éléments dans l'élément d'habillage du membre de données, tel que des commentaires XML.</span><span class="sxs-lookup"><span data-stu-id="cfe97-136">You can also inject content other than elements inside of the data member wrapping element, such as XML comments.</span></span> <span data-ttu-id="cfe97-137">Enfin, vous pouvez injecter des attributs dans l'élément d'habillage du membre de données.</span><span class="sxs-lookup"><span data-stu-id="cfe97-137">Finally, you can put attributes into the wrapping data member element.</span></span> <span data-ttu-id="cfe97-138">Toutes ces opérations sont possibles en remplissant le tableau de `XmlNode` avec les classes dérivées spécifiques de `XmlNode` telles que <xref:System.Xml.XmlAttribute>, `XmlElement` ou <xref:System.Xml.XmlComment>.</span><span class="sxs-lookup"><span data-stu-id="cfe97-138">All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>.</span></span> <span data-ttu-id="cfe97-139">Par exemple, utilisez le type ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="cfe97-139">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#5)]
 [!code-vb[DataContractAttribute#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#5)]  
  
 <span data-ttu-id="cfe97-140">En cas de sérialisation, le XML résultant est semblable au code suivant.</span><span class="sxs-lookup"><span data-stu-id="cfe97-140">When serialized, the resulting XML is similar to the following code.</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
  <myDataMember myAttribute="myValue">  
     <!--myComment-->  
     <myElement xmlns="" myAttribute="myValue">  
 myContents  
     </myElement>  
     <myElement xmlns="" myAttribute="myValue">  
       myContents  
     </myElement>  
  </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="cfe97-141">Notez que l'élément wrapper du membre de données `<myDataMember>` contient un attribut, un commentaire et deux éléments.</span><span class="sxs-lookup"><span data-stu-id="cfe97-141">Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements.</span></span> <span data-ttu-id="cfe97-142">Ce sont les quatre instances `XmlNode` ayant été sérialisées.</span><span class="sxs-lookup"><span data-stu-id="cfe97-142">These are the four `XmlNode` instances that were serialized.</span></span>  
  
 <span data-ttu-id="cfe97-143">Un tableau de `XmlNode` qui produit un XML non valide ne peut pas être sérialisé.</span><span class="sxs-lookup"><span data-stu-id="cfe97-143">An array of `XmlNode` that results in invalid XML cannot be serialized.</span></span> <span data-ttu-id="cfe97-144">Par exemple, un tableau de deux instances `XmlNode` où la première est un `XmlElement` et la deuxième est un <xref:System.Xml.XmlAttribute> n'est pas valide, parce que cette séquence ne correspond pas à une instance XML valide (pas d'espace pour y joindre l'attribut).</span><span class="sxs-lookup"><span data-stu-id="cfe97-144">For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).</span></span>  
  
 <span data-ttu-id="cfe97-145">Au moment de la désérialisation d'un tableau de `XmlNode`, les nœuds sont créés et remplis avec les informations XML entrantes.</span><span class="sxs-lookup"><span data-stu-id="cfe97-145">On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML.</span></span> <span data-ttu-id="cfe97-146">Un parent valide <xref:System.Xml.XmlDocument> est fourni par le désérialiseur.</span><span class="sxs-lookup"><span data-stu-id="cfe97-146">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span> <span data-ttu-id="cfe97-147">Tous les nœuds sont désérialisés, y compris tous les attributs sur l'élément du membre de données du wrapper, mais à l'exclusion des attributs placés à cet endroit par les sérialiseurs [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] (tels que les attributs utilisés pour indiquer l'assignation polymorphe).</span><span class="sxs-lookup"><span data-stu-id="cfe97-147">All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] serializers (such as the attributes used to indicate polymorphic assignment).</span></span> <span data-ttu-id="cfe97-148">La restriction liée à la définition de tous les préfixes d'espace de noms dans le fragment XML s'applique à la désérialisation des tableaux de `XmlNode` au même titre que la désérialisation de `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-148">The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`.</span></span>  
  
 <span data-ttu-id="cfe97-149">Lorsque vous utilisez des sérialiseurs avec la conservation des graphiques d'objet activée, l'égalité d'objet est conservée uniquement au niveau des tableaux `XmlNode`, pas des instances `XmlNode` individuelles.</span><span class="sxs-lookup"><span data-stu-id="cfe97-149">When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances.</span></span>  
  
 <span data-ttu-id="cfe97-150">N'essayez pas de sérialiser un tableau de `XmlNode` qui contient un ou plusieurs nœuds de valeur `null`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-150">Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`.</span></span> <span data-ttu-id="cfe97-151">Les membres du tableau entier sont autorisés à être `null`, mais pas pour les `XmlNode` individuels contenus dans le tableau.</span><span class="sxs-lookup"><span data-stu-id="cfe97-151">It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array.</span></span> <span data-ttu-id="cfe97-152">Si le membre du tableau entier est null, l'élément du membre de données du wrapper contient un attribut spécial qui indique qu'il est null.</span><span class="sxs-lookup"><span data-stu-id="cfe97-152">If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.</span></span> <span data-ttu-id="cfe97-153">Au moment de la désérialisation, le membre du tableau entier prend aussi la valeur null.</span><span class="sxs-lookup"><span data-stu-id="cfe97-153">On deserialization, the entire array member also becomes null.</span></span>  
  
 <span data-ttu-id="cfe97-154">Seuls les tableaux réguliers de `XmlNode` font l'objet d'un traitement particulier par le sérialiseur.</span><span class="sxs-lookup"><span data-stu-id="cfe97-154">Only regular arrays of `XmlNode` are treated specially by the serializer.</span></span> <span data-ttu-id="cfe97-155">Les membres de données déclarés comme d'autres types de collection qui contiennent `XmlNode`, ou les membres de données déclarés comme tableaux de types dérivés de `XmlNode`, ne font pas l'objet d'un traitement particulier.</span><span class="sxs-lookup"><span data-stu-id="cfe97-155">Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially.</span></span> <span data-ttu-id="cfe97-156">Par conséquent, elles ne sont pas normalement sérialisables sauf si elles correspondent aussi à l'un des autres critères pour la sérialisation.</span><span class="sxs-lookup"><span data-stu-id="cfe97-156">Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.</span></span>  
  
 <span data-ttu-id="cfe97-157">Les tableaux ou collections de tableaux de `XmlNode` sont autorisés.</span><span class="sxs-lookup"><span data-stu-id="cfe97-157">Arrays or collections of arrays of `XmlNode` are allowed.</span></span> <span data-ttu-id="cfe97-158">Il existe un élément wrapper pour la collection entière, et un élément wrapper séparé (semblable à `<myDataMember>` dans l'exemple précédent) pour chaque tableau du `XmlNode` de la collection ou du tableau externe.</span><span class="sxs-lookup"><span data-stu-id="cfe97-158">There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection.</span></span>  
  
 <span data-ttu-id="cfe97-159">Le remplissage d'un membre de données de type <xref:System.Array> de `Object` ou `Array` de `IEnumerable` avec les instances `XmlNode` n'entraîne pas le traitement du membre de données en tant que `Array` des instances `XmlNode`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-159">Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances.</span></span> <span data-ttu-id="cfe97-160">Chaque membre de tableau est sérialisé séparément.</span><span class="sxs-lookup"><span data-stu-id="cfe97-160">Each array member is serialized separately.</span></span>  
  
 <span data-ttu-id="cfe97-161">Lorsqu'ils sont utilisés avec `DataContractSerializer`, les tableaux `XmlNode` peuvent être assignés d'une manière polymorphe mais uniquement à un membre de données de type `Object`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-161">When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`.</span></span> <span data-ttu-id="cfe97-162">Même s'il implémente `IEnumerable`, un tableau de `XmlNode` ne peut pas être utilisé comme un type de collection et ne peut pas être assigné à un membre de données `IEnumerable`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-162">Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member.</span></span> <span data-ttu-id="cfe97-163">Comme avec toutes les assignations polymorphes, le `DataContractSerializer` émet le nom de contrat de données dans le XML résultant. Dans ce cas, « ArrayOfXmlNode » est dans l'espace de noms « http://schemas.datacontract.org/2004/07/System.Xml ».</span><span class="sxs-lookup"><span data-stu-id="cfe97-163">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "ArrayOfXmlNode" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span> <span data-ttu-id="cfe97-164">Lorsqu’il est utilisé avec le `NetDataContractSerializer`, les assignations valides d’un `XmlNode` tableau est pris en charge.</span><span class="sxs-lookup"><span data-stu-id="cfe97-164">When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported.</span></span>  
  
### <a name="schema-considerations"></a><span data-ttu-id="cfe97-165">Considérations sur le schéma</span><span class="sxs-lookup"><span data-stu-id="cfe97-165">Schema Considerations</span></span>  
 <span data-ttu-id="cfe97-166">Pour plus d’informations sur le mappage de schéma des types XML, consultez [référence de schéma de contrat de données](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="cfe97-166">For details about the schema mapping of XML types, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="cfe97-167">Cette section fournit un résumé des points importants.</span><span class="sxs-lookup"><span data-stu-id="cfe97-167">This section provides a summary of the important points.</span></span>  
  
 <span data-ttu-id="cfe97-168">Un membre de données de type `XmlElement` est mappé à un élément défini à l'aide du type anonyme suivant.</span><span class="sxs-lookup"><span data-stu-id="cfe97-168">A data member of type `XmlElement` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType>  
   <xsd:sequence>  
      <xsd:any minOccurs="0" processContents="lax" />  
   </xsd:sequence>  
</xsd:complexType>  
```  
  
 <span data-ttu-id="cfe97-169">Un membre de données de type Array de `XmlNode` est mappé à un élément défini à l'aide du type anonyme suivant.</span><span class="sxs-lookup"><span data-stu-id="cfe97-169">A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType mixed="true">  
   <xsd:sequence>  
      <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax" />  
   </xsd:sequence>  
   <xsd:anyAttribute/>  
</xsd:complexType>  
```  
  
## <a name="types-implementing-the-ixmlserializable-interface"></a><span data-ttu-id="cfe97-170">Types qui implémentent l'interface IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="cfe97-170">Types Implementing the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="cfe97-171">Les types qui implémentent l'interface `IXmlSerializable` sont pleinement pris en charge par le `DataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-171">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="cfe97-172">L'attribut <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> doit toujours être appliqué à ces types pour contrôler leur schéma.</span><span class="sxs-lookup"><span data-stu-id="cfe97-172">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
 <span data-ttu-id="cfe97-173">Trois variétés de types implémentent `IXmlSerializable` : les types représentant le contenu arbitraire, les types représentant un élément unique et les types <xref:System.Data.DataSet> hérités.</span><span class="sxs-lookup"><span data-stu-id="cfe97-173">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
-   <span data-ttu-id="cfe97-174">Les types de contenu utilisent une méthode du fournisseur de schéma spécifiée par l'attribut `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-174">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="cfe97-175">La méthode ne retourne pas `null`, et la propriété <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> sur l'attribut conserve sa valeur par défaut `false`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-175">The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="cfe97-176">Il s'agit de l'utilisation la plus courante des types `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-176">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
-   <span data-ttu-id="cfe97-177">Les types d'élément sont utilisés lorsqu'un type `IXmlSerializable` doit contrôler son propre nom d'élément racine.</span><span class="sxs-lookup"><span data-stu-id="cfe97-177">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="cfe97-178">Pour marquer un type comme un type élément, affectez à la propriété <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> sur l'attribut <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> la valeur `true` ou retournez null à partir de la méthode du fournisseur de schéma.</span><span class="sxs-lookup"><span data-stu-id="cfe97-178">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method.</span></span> <span data-ttu-id="cfe97-179">L'utilisation d'une méthode du fournisseur de schéma est facultative pour les types élément. Vous pouvez spécifier null au lieu du nom de méthode dans `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-179">Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="cfe97-180">Toutefois, si `IsAny` a la valeur `true` et qu'une méthode du fournisseur de schéma est spécifiée, la méthode doit retourner null.</span><span class="sxs-lookup"><span data-stu-id="cfe97-180">However, if `IsAny` is `true` and a schema provider method is specified, the method must return null.</span></span>  
  
-   <span data-ttu-id="cfe97-181">Les types <xref:System.Data.DataSet> hérités sont des types `IXmlSerializable` qui ne sont pas marqués avec l'attribut `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-181">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="cfe97-182">À la place, ils comptent sur la méthode <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> pour la génération de schéma.</span><span class="sxs-lookup"><span data-stu-id="cfe97-182">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="cfe97-183">Ce modèle est utilisé pour le type `DataSet` et son groupe de données typés dérive une classe dans les versions antérieures du .NET Framework, mais il est désormais obsolète et pris en charge uniquement pour des raisons d'héritage.</span><span class="sxs-lookup"><span data-stu-id="cfe97-183">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="cfe97-184">Ne vous fiez pas à ce modèle et appliquez toujours `XmlSchemaProviderAttribute` à vos types `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-184">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="cfe97-185">Types de contenu IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="cfe97-185">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="cfe97-186">Lors de la sérialisation d'un membre de données d'un type qui implémente `IXmlSerializable` et qui est un type de contenu défini précédemment, le sérialiseur écrit l'élément wrapper pour le membre de données et transmet le contrôle à la méthode <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="cfe97-186">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="cfe97-187">L'implémentation <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> peut écrire n'importe quel code XML, y compris ajouter des attributs à l'élément wrapper.</span><span class="sxs-lookup"><span data-stu-id="cfe97-187">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element.</span></span> <span data-ttu-id="cfe97-188">Au terme de l'écriture de `WriteXml`, le sérialiseur ferme l'élément.</span><span class="sxs-lookup"><span data-stu-id="cfe97-188">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="cfe97-189">Lors de la désérialisation d'un membre de données d'un type qui implémente `IXmlSerializable` et qui est un type de contenu défini précédemment, le désérialiseur positionne le lecteur XML sur l'élément wrapper du membre de données et transmet le contrôle à la méthode <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="cfe97-189">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="cfe97-190">La méthode doit lire l'élément en entier, y compris les balises de début et de fin.</span><span class="sxs-lookup"><span data-stu-id="cfe97-190">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="cfe97-191">Assurez-vous que votre code `ReadXml` gère le cas où l'élément est vide.</span><span class="sxs-lookup"><span data-stu-id="cfe97-191">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="cfe97-192">En outre, votre implémentation `ReadXml` ne doit pas dépendre d'un nom particulier qui affecterait l'élément wrapper.</span><span class="sxs-lookup"><span data-stu-id="cfe97-192">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="cfe97-193">Le nom est choisi par le sérialiseur et peut varier.</span><span class="sxs-lookup"><span data-stu-id="cfe97-193">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="cfe97-194">Il est possible d'assigner de manière polymorphe des types de contenu `IXmlSerializable` par exemple aux membres de données de type <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="cfe97-194">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="cfe97-195">Les instances de types peuvent aussi être Null.</span><span class="sxs-lookup"><span data-stu-id="cfe97-195">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="cfe97-196">Enfin, il est possible d'utiliser des types `IXmlSerializable` avec la conservation des graphiques d'objet activée et avec <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="cfe97-196">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="cfe97-197">Toutes ces fonctionnalités nécessitent que le sérialiseur [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] joigne certains attributs dans l'élément wrapper (« nil » et « type » dans l'espace de noms de l'instance du schéma XML et « ID », « Ref », « Type » et « Assembly » dans un espace de noms spécifique à [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]).</span><span class="sxs-lookup"><span data-stu-id="cfe97-197">All these features require the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="cfe97-198">Attributs à ignorer lors de l'implémentation de ReadXml</span><span class="sxs-lookup"><span data-stu-id="cfe97-198">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="cfe97-199">Avant de passer le contrôle à votre code `ReadXml`, le désérialiseur examine l'élément XML, détecte les attributs XML spéciaux et effectue des actions sur ceux-ci.</span><span class="sxs-lookup"><span data-stu-id="cfe97-199">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="cfe97-200">Par exemple, si « nil » est `true`, une valeur Null sera désérialisée et `ReadXml` n'est pas appelée.</span><span class="sxs-lookup"><span data-stu-id="cfe97-200">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="cfe97-201">Si le polymorphisme est détecté, le contenu de l'élément est désérialisé comme s'il s'agissait d'un type différent.</span><span class="sxs-lookup"><span data-stu-id="cfe97-201">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="cfe97-202">L'implémentation de `ReadXml` du type assigné de manière polymorphe est appelée.</span><span class="sxs-lookup"><span data-stu-id="cfe97-202">The polymorphically assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="cfe97-203">Dans tous les cas, une implémentation `ReadXml` doit ignorer les attributs spéciaux puisqu'ils sont contrôlés par le désérialiseur.</span><span class="sxs-lookup"><span data-stu-id="cfe97-203">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="cfe97-204">Considérations sur le schéma pour les types de contenu IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="cfe97-204">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="cfe97-205">Lors de l'exportation du schéma d'un type de contenu `IXmlSerializable`, la méthode du fournisseur de schéma est appelée.</span><span class="sxs-lookup"><span data-stu-id="cfe97-205">When exporting schema an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="cfe97-206">Un <xref:System.Xml.Schema.XmlSchemaSet> est passé à la méthode du fournisseur de schéma.</span><span class="sxs-lookup"><span data-stu-id="cfe97-206">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="cfe97-207">La méthode peut ajouter un schéma valide au jeu de schémas.</span><span class="sxs-lookup"><span data-stu-id="cfe97-207">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="cfe97-208">Le jeu de schémas contient le schéma déjà connu au moment où se produit l'exportation de schéma.</span><span class="sxs-lookup"><span data-stu-id="cfe97-208">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="cfe97-209">Lorsque la méthode du fournisseur de schéma doit ajouter un élément au jeu de schémas, elle doit déterminer si un <xref:System.Xml.Schema.XmlSchema> avec l'espace de noms approprié existe déjà dans le jeu.</span><span class="sxs-lookup"><span data-stu-id="cfe97-209">When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="cfe97-210">Si tel est le cas, la méthode du fournisseur de schéma doit ajouter le nouvel élément au `XmlSchema` existant.</span><span class="sxs-lookup"><span data-stu-id="cfe97-210">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="cfe97-211">Sinon, il doit créer une nouvelle instance `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-211">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="cfe97-212">Cette opération est importante si les tableaux de types `IXmlSerializable` sont utilisés.</span><span class="sxs-lookup"><span data-stu-id="cfe97-212">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="cfe97-213">Par exemple, si vous avez un type `IXmlSerializable` exporté comme type « A » dans l'espace de noms « B », il est possible qu'au moment où la méthode du fournisseur de schéma est appelée, le jeu de schémas contienne déjà le schéma pour que « B » contienne le type « ArrayOfA ».</span><span class="sxs-lookup"><span data-stu-id="cfe97-213">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="cfe97-214">En plus d'ajouter des types à <xref:System.Xml.Schema.XmlSchemaSet>, la méthode du fournisseur de schéma pour les types de contenu doit retourner une valeur non NULL.</span><span class="sxs-lookup"><span data-stu-id="cfe97-214">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="cfe97-215">Elle peut retourner un <xref:System.Xml.XmlQualifiedName> qui spécifie le nom du type de schéma à utiliser pour le type `IXmlSerializable` donné.</span><span class="sxs-lookup"><span data-stu-id="cfe97-215">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="cfe97-216">Ce nom qualifié sert également comme nom et espace de noms de contrat de données pour le type.</span><span class="sxs-lookup"><span data-stu-id="cfe97-216">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="cfe97-217">Il est possible de retourner un type qui n'existe pas immédiatement dans le jeu de schémas lorsque la méthode du fournisseur de schéma est retournée.</span><span class="sxs-lookup"><span data-stu-id="cfe97-217">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="cfe97-218">Toutefois, au moment de l'exportation de tous les types connexes (la méthode <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> est appelée pour tous les types pertinents sur <xref:System.Runtime.Serialization.XsdDataContractExporter> et la propriété <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> est accessible), le type est dans le jeu de schémas.</span><span class="sxs-lookup"><span data-stu-id="cfe97-218">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="cfe97-219">Accéder à la propriété `Schemas` avant d'effectuer tous les appels `Export` pertinents peut provoquer une <xref:System.Xml.Schema.XmlSchemaException>.</span><span class="sxs-lookup"><span data-stu-id="cfe97-219">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="cfe97-220">le processus d’exportation, consultez [exportation de schémas à partir des Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="cfe97-220"> the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="cfe97-221">La méthode du fournisseur de schéma peut aussi retourner le <xref:System.Xml.Schema.XmlSchemaType> à utiliser.</span><span class="sxs-lookup"><span data-stu-id="cfe97-221">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="cfe97-222">Le type peut ou ne peut pas être anonyme.</span><span class="sxs-lookup"><span data-stu-id="cfe97-222">The type may or may not be anonymous.</span></span> <span data-ttu-id="cfe97-223">S'il est anonyme, le schéma du type `IXmlSerializable` est exporté sous la forme d'un type anonyme à chaque fois que le type `IXmlSerializable` est utilisé comme un membre de données.</span><span class="sxs-lookup"><span data-stu-id="cfe97-223">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="cfe97-224">Le type `IXmlSerializable` a encore un nom et un espace de noms de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="cfe97-224">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="cfe97-225">(Cela est déterminé comme décrit dans [les noms de contrat de données](../../../../docs/framework/wcf/feature-details/data-contract-names.md) , sauf que le <xref:System.Runtime.Serialization.DataContractAttribute> attribut ne peut pas être utilisé pour personnaliser le nom.) S'il n'est pas anonyme, il doit être l'un des types dans le `XmlSchemaSet`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-225">(This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="cfe97-226">Ce cas revient à retourner le `XmlQualifiedName` du type.</span><span class="sxs-lookup"><span data-stu-id="cfe97-226">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="cfe97-227">En outre, une déclaration d'élément globale est exportée pour le type.</span><span class="sxs-lookup"><span data-stu-id="cfe97-227">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="cfe97-228">Si l'attribut <xref:System.Xml.Serialization.XmlRootAttribute> n'est pas appliqué au type, l'élément a le même nom et espace de noms comme contrat de données, et sa propriété « nillable » a la valeur true.</span><span class="sxs-lookup"><span data-stu-id="cfe97-228">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is true.</span></span> <span data-ttu-id="cfe97-229">La seule exception concerne l'espace de noms de schéma (« http://www.w3.org/2001/XMLSchema »). Si le contrat de données du type est dans cet espace de noms, l'élément global correspondant est dans l'espace de noms vierge car il est défendu d'ajouter de nouveaux éléments à l'espace de noms de schéma.</span><span class="sxs-lookup"><span data-stu-id="cfe97-229">The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="cfe97-230">Si l'attribut `XmlRootAttribute` s'applique au type, la déclaration d'élément globale est exportée à l'aide des propriétés suivantes : <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> et <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A>.</span><span class="sxs-lookup"><span data-stu-id="cfe97-230">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="cfe97-231">Les valeurs par défaut appliquées avec `XmlRootAttribute` sont le nom de contrat de données, un espace de noms vide et « nillable » ayant pour valeur true.</span><span class="sxs-lookup"><span data-stu-id="cfe97-231">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being true.</span></span>  
  
 <span data-ttu-id="cfe97-232">Les mêmes règles de déclaration d'élément globale s'appliquent aux types de groupes de données hérités.</span><span class="sxs-lookup"><span data-stu-id="cfe97-232">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="cfe97-233">Notez que `XmlRootAttribute` ne peut pas substituer de déclarations d'élément globales ajoutées par l'intermédiaire du code personnalisé, ajoutées soit à `XmlSchemaSet` à l'aide de la méthode du fournisseur de schéma, soit à l'aide de `GetSchema` pour les types de groupes de données hérités.</span><span class="sxs-lookup"><span data-stu-id="cfe97-233">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="cfe97-234">Types d'élément IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="cfe97-234">IXmlSerializable Element Types</span></span>  
 <span data-ttu-id="cfe97-235">La propriété `IXmlSerializable` des types d'élément `IsAny` a la valeur `true` ou leur méthode du fournisseur de schéma retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-235">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="cfe97-236">La sérialisation et la désérialisation d'un type d'élément est très semblable à la sérialisation et la désérialisation d'un type de contenu.</span><span class="sxs-lookup"><span data-stu-id="cfe97-236">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="cfe97-237">Toutefois, il y a des différences importantes :</span><span class="sxs-lookup"><span data-stu-id="cfe97-237">However, there are some important differences:</span></span>  
  
-   <span data-ttu-id="cfe97-238">L'implémentation `WriteXml` est censée écrire exactement un élément (qui peut contenir évidemment plusieurs éléments enfants).</span><span class="sxs-lookup"><span data-stu-id="cfe97-238">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="cfe97-239">Elle ne doit pas écrire d'attributs en dehors de cet élément unique, plusieurs éléments frères ou de contenu mixte.</span><span class="sxs-lookup"><span data-stu-id="cfe97-239">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="cfe97-240">L'élément peut être vide.</span><span class="sxs-lookup"><span data-stu-id="cfe97-240">The element may be empty.</span></span>  
  
-   <span data-ttu-id="cfe97-241">L'implémentation `ReadXml` ne doit pas lire l'élément wrapper.</span><span class="sxs-lookup"><span data-stu-id="cfe97-241">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="cfe97-242">Elle est censée lire l'élément unique produit par `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-242">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
-   <span data-ttu-id="cfe97-243">Lors de la sérialisation régulière d'un type d'élément (par exemple, comme membre de données dans un contrat de données), le sérialiseur produit un élément wrapper avant d'appeler `WriteXml`, comme avec les types de contenu.</span><span class="sxs-lookup"><span data-stu-id="cfe97-243">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="cfe97-244">Cependant, lors de la sérialisation d'un type d'élément au niveau supérieur, le sérialiseur ne produit pas normalement un élément wrapper autour de l'élément écrit par `WriteXml`, sauf si un nom racine et l'espace de noms ont été spécifiés explicitement lors de l'élaboration du sérialiseur dans les constructeurs `DataContractSerializer` ou `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-244">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="cfe97-245">[Sérialisation et désérialisation](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="cfe97-245"> [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
-   <span data-ttu-id="cfe97-246">Si vous sérialisez un type d'élément au niveau supérieur sans spécifier le nom racine et l'espace de noms au moment de la construction, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> et <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> n'effectuent essentiellement aucune tâche et <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> appelle `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-246">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="cfe97-247">Dans ce mode, l'objet qui est sérialisé ne peut pas être null et ne peut pas être assigné d'une manière polymorphe.</span><span class="sxs-lookup"><span data-stu-id="cfe97-247">In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.</span></span> <span data-ttu-id="cfe97-248">La conservation des graphiques d'objet ne peut pas non plus être activée et le `NetDataContractSerializer` ne peut pas être utilisé.</span><span class="sxs-lookup"><span data-stu-id="cfe97-248">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
-   <span data-ttu-id="cfe97-249">Si vous désérialisez un type d'élément au niveau supérieur sans spécifier le nom racine et l'espace de noms au moment de la construction, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> retourne `true` s'il trouve le début d'un élément.</span><span class="sxs-lookup"><span data-stu-id="cfe97-249">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="cfe97-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A>, avec le paramètre `verifyObjectName` ayant la valeur `true`, se comporte de la même façon que `IsStartObject` avant de lire l'objet.</span><span class="sxs-lookup"><span data-stu-id="cfe97-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="cfe97-251">`ReadObject` passe ensuite le contrôle à la méthode `ReadXml`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-251">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="cfe97-252">Le schéma exporté pour les types d'élément est le même que pour le type `XmlElement` décrit dans une section antérieure, sauf que la méthode du fournisseur de schéma peut ajouter tout schéma supplémentaire au <xref:System.Xml.Schema.XmlSchemaSet> comme avec les types de contenu.</span><span class="sxs-lookup"><span data-stu-id="cfe97-252">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="cfe97-253">L'utilisation de l'attribut `XmlRootAttribute` avec les types d'élément n'est pas autorisé, et les déclarations d'élément globales ne sont jamais émises pour ces types.</span><span class="sxs-lookup"><span data-stu-id="cfe97-253">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="cfe97-254">Différences par rapport au XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="cfe97-254">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="cfe97-255">L'interface `IXmlSerializable` et les attributs `XmlSchemaProviderAttribute` et `XmlRootAttribute` sont également compris par le <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="cfe97-255">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="cfe97-256">Cependant, il existe des différences dans la manière dont ils sont traités dans le modèle de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="cfe97-256">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="cfe97-257">Ces différences importantes sont répertoriées comme suit :</span><span class="sxs-lookup"><span data-stu-id="cfe97-257">The important differences are summarized in the following:</span></span>  
  
-   <span data-ttu-id="cfe97-258">La méthode du fournisseur de schéma doit être publique pour être utilisable dans le `XmlSerializer`, mais ne doit pas être nécessairement publique pour être utilisable dans le modèle de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="cfe97-258">The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model.</span></span>  
  
-   <span data-ttu-id="cfe97-259">La méthode du fournisseur de schéma est appelée lorsque `IsAny` est true dans le modèle de contrat de données mais pas avec le `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-259">The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="cfe97-260">Lorsque l'attribut `XmlRootAttribute` n'est pas présent pour les types de contenu ou de groupes de données hérités, le `XmlSerializer` exporte une déclaration d'élément globale dans l'espace de noms vide.</span><span class="sxs-lookup"><span data-stu-id="cfe97-260">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="cfe97-261">Dans le modèle de contrat de données, l'espace de noms utilisé est normalement l'espace de noms de contrat de données décrit précédemment.</span><span class="sxs-lookup"><span data-stu-id="cfe97-261">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="cfe97-262">Gardez ces différences à l'esprit lors de la création des types qui sont utilisés avec les deux technologies de sérialisation.</span><span class="sxs-lookup"><span data-stu-id="cfe97-262">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="cfe97-263">Importation du schéma IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="cfe97-263">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="cfe97-264">Lorsque vous importez un schéma généré à partir des types `IXmlSerializable`, plusieurs possibilités sont offertes :</span><span class="sxs-lookup"><span data-stu-id="cfe97-264">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
-   <span data-ttu-id="cfe97-265">Le schéma généré peut être un schéma de contrat de données valide comme décrit dans [référence de schéma de contrat de données](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="cfe97-265">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="cfe97-266">Dans ce cas, le schéma peut être importé comme d'habitude et les types de contrat de données normaux sont générés.</span><span class="sxs-lookup"><span data-stu-id="cfe97-266">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
-   <span data-ttu-id="cfe97-267">Le schéma généré peut ne pas être un schéma de contrat de données valide.</span><span class="sxs-lookup"><span data-stu-id="cfe97-267">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="cfe97-268">Par exemple, votre méthode du fournisseur de schéma peut générer un schéma qui implique des attributs XML pris en charge dans le modèle de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="cfe97-268">For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.</span></span> <span data-ttu-id="cfe97-269">Dans ce cas, vous pouvez importer le schéma comme des types `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-269">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="cfe97-270">Ce mode d’importation est pas activé par défaut, mais peut être activé facilement, par exemple, avec la `/importXmlTypes` commutateur de ligne de commande pour le [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="cfe97-270">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="cfe97-271">Cet exemple est décrit en détail dans les [l’importation de schéma pour générer des Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="cfe97-271">This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="cfe97-272">Notez que vous devez utiliser directement le XML pour vos instances de type.</span><span class="sxs-lookup"><span data-stu-id="cfe97-272">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="cfe97-273">Vous pouvez envisager d'utiliser également une technologie de sérialisation différente qui prend en charge une plage de schéma plus large. Consultez la rubrique sur l'utilisation du `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-273">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="cfe97-274">Vous pouvez réutiliser vos types `IXmlSerializable` existants dans le proxy au lieu d'en générer de nouveaux.</span><span class="sxs-lookup"><span data-stu-id="cfe97-274">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="cfe97-275">Dans ce cas, la fonctionnalité des types référencés décrite dans la rubrique « Importation du schéma pour générer des types » peut être utilisée pour indiquer le type à réutiliser.</span><span class="sxs-lookup"><span data-stu-id="cfe97-275">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="cfe97-276">Cela revient à utiliser le `/reference` basculer sur svcutil.exe qui spécifie l’assembly qui contient les types à réutiliser.</span><span class="sxs-lookup"><span data-stu-id="cfe97-276">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
## <a name="representing-arbitrary-xml-in-data-contracts"></a><span data-ttu-id="cfe97-277">Représentation du XML arbitraire dans les contrats de données</span><span class="sxs-lookup"><span data-stu-id="cfe97-277">Representing Arbitrary XML in Data Contracts</span></span>  
 <span data-ttu-id="cfe97-278">Le `XmlElement`, le tableau de `XmlNode` et les types `IXmlSerializable` vous permettent d'injecter du code XML arbitraire dans le modèle de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="cfe97-278">The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model.</span></span> <span data-ttu-id="cfe97-279">Les `DataContractSerializer` et `NetDataContractSerializer` transmettent ce contenu XML au writer XML utilisé, sans intervenir dans le processus.</span><span class="sxs-lookup"><span data-stu-id="cfe97-279">The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process.</span></span> <span data-ttu-id="cfe97-280">Toutefois, les writers XML peuvent appliquer certaines restrictions dans le code XML qu'ils écrivent.</span><span class="sxs-lookup"><span data-stu-id="cfe97-280">However, the XML writers may enforce certain restrictions on the XML that they write.</span></span> <span data-ttu-id="cfe97-281">En voici quelques exemples importants :</span><span class="sxs-lookup"><span data-stu-id="cfe97-281">Specifically, here are some important examples:</span></span>  
  
-   <span data-ttu-id="cfe97-282">Les enregistreurs XML n’autorisent pas généralement une déclaration de document XML (par exemple, \<? xml version ='1.0 ' ? >) au milieu de l’écriture d’un autre document.</span><span class="sxs-lookup"><span data-stu-id="cfe97-282">The XML writers do not typically allow an XML document declaration (for example, \<?xml version=’1.0’ ?>) in the middle of writing another document.</span></span> <span data-ttu-id="cfe97-283">Vous ne pouvez pas prendre un document XML complet et le sérialiser comme un `Array` d'un membre de données `XmlNode`.</span><span class="sxs-lookup"><span data-stu-id="cfe97-283">You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member.</span></span> <span data-ttu-id="cfe97-284">Pour cela, vous devez supprimer la déclaration de document ou utiliser votre propre méthode d'encodage pour la représenter.</span><span class="sxs-lookup"><span data-stu-id="cfe97-284">To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.</span></span>  
  
-   <span data-ttu-id="cfe97-285">Tous les enregistreurs XML fournis avec [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] rejeter les instructions de traitement XML (\<?</span><span class="sxs-lookup"><span data-stu-id="cfe97-285">All of the XML writers supplied with [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] reject XML processing instructions (\<?</span></span> <span data-ttu-id="cfe97-286">…</span><span class="sxs-lookup"><span data-stu-id="cfe97-286">…</span></span> <span data-ttu-id="cfe97-287">? >) et les définitions de type de document (\<!</span><span class="sxs-lookup"><span data-stu-id="cfe97-287">?>) and document type definitions (\<!</span></span> <span data-ttu-id="cfe97-288">…</span><span class="sxs-lookup"><span data-stu-id="cfe97-288">…</span></span> <span data-ttu-id="cfe97-289">>), car ils ne sont pas autorisées dans les messages SOAP.</span><span class="sxs-lookup"><span data-stu-id="cfe97-289">>), because they are not allowed in SOAP messages.</span></span> <span data-ttu-id="cfe97-290">Là encore, vous pouvez utiliser votre propre mécanisme d'encodage pour contourner cette restriction.</span><span class="sxs-lookup"><span data-stu-id="cfe97-290">Again, you can use your own encoding mechanism to get around this restriction.</span></span> <span data-ttu-id="cfe97-291">Si vous devez inclure celles-ci dans votre code XML résultant, vous pouvez écrire un encodeur personnalisé qui fait appel à des writers XML pour les prendre en charge.</span><span class="sxs-lookup"><span data-stu-id="cfe97-291">If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.</span></span>  
  
-   <span data-ttu-id="cfe97-292">Lors de l'implémentation de `WriteXml`, évitez d'appeler la méthode <xref:System.Xml.XmlWriter.WriteRaw%2A> sur l'enregistreur XML.</span><span class="sxs-lookup"><span data-stu-id="cfe97-292">When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer.</span></span> [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="cfe97-293"> utilise divers encodages XML (y compris binaire) ; il est très difficile ou impossible d'utiliser `WriteRaw` de telle sorte que le résultat soit utilisable dans un encodage.</span><span class="sxs-lookup"><span data-stu-id="cfe97-293"> uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding.</span></span>  
  
-   <span data-ttu-id="cfe97-294">Lorsque vous implémentez `WriteXml`, évitez d'utiliser les méthodes <xref:System.Xml.XmlWriter.WriteEntityRef%2A> et <xref:System.Xml.XmlWriter.WriteNmToken%2A> qui ne sont pas prises en charge sur les writers XML fournis avec [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span><span class="sxs-lookup"><span data-stu-id="cfe97-294">When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span></span>  
  
## <a name="using-dataset-typed-dataset-and-datatable"></a><span data-ttu-id="cfe97-295">Utilisation de DataSet, Typed DataSet et DataTable</span><span class="sxs-lookup"><span data-stu-id="cfe97-295">Using DataSet, Typed DataSet and DataTable</span></span>  
 <span data-ttu-id="cfe97-296">L'utilisation de ces types est prise en charge pleinement dans le modèle de contrat de données.</span><span class="sxs-lookup"><span data-stu-id="cfe97-296">Using these types is fully supported in the data contract model.</span></span> <span data-ttu-id="cfe97-297">Lorsque vous utilisez ces types, considérez les points suivants :</span><span class="sxs-lookup"><span data-stu-id="cfe97-297">When using these types, consider the following points:</span></span>  
  
-   <span data-ttu-id="cfe97-298">Le schéma pour ces types (surtout <xref:System.Data.DataSet> et ses classes dérivées typées) peut ne pas être interopérable avec certaines plateformes non [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], ou sa facilité d'utilisation peut s'en trouver limitée.</span><span class="sxs-lookup"><span data-stu-id="cfe97-298">The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] platforms, or may result in poor usability when used with these platforms.</span></span> <span data-ttu-id="cfe97-299">En outre, l'utilisation du type `DataSet` peut avoir un impact sur les performances.</span><span class="sxs-lookup"><span data-stu-id="cfe97-299">Additionally, using the `DataSet` type may have performance implications.</span></span> <span data-ttu-id="cfe97-300">Enfin, il peut compliquer la gestion de la version de votre application dans le futur.</span><span class="sxs-lookup"><span data-stu-id="cfe97-300">Finally, it may make it more difficult for you to version your application in the future.</span></span> <span data-ttu-id="cfe97-301">Utilisez des types de contrat de données définis explicitement plutôt que des types `DataSet` dans vos contrats.</span><span class="sxs-lookup"><span data-stu-id="cfe97-301">Consider using explicitly defined data contract types instead of `DataSet` types in your contracts.</span></span>  
  
-   <span data-ttu-id="cfe97-302">Lorsque vous importez le schéma `DataSet` ou `DataTable`, il est important de référencer ces types.</span><span class="sxs-lookup"><span data-stu-id="cfe97-302">When importing `DataSet` or `DataTable` schema, it is important to reference these types.</span></span> <span data-ttu-id="cfe97-303">Avec l’outil de ligne de commande Svcutil.exe, cela peut être accompli en passant le nom de l’assembly System.Data.dll à la `/reference` basculer.</span><span class="sxs-lookup"><span data-stu-id="cfe97-303">With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch.</span></span> <span data-ttu-id="cfe97-304">Si vous importez un schéma de groupe de données typé, vous devez référencer le type du groupe de données typé.</span><span class="sxs-lookup"><span data-stu-id="cfe97-304">If importing typed dataset schema, you must reference the typed dataset’s type.</span></span> <span data-ttu-id="cfe97-305">Avec Svcutil.exe, passez à l’emplacement de l’assembly du dataset typé à le `/reference` basculer.</span><span class="sxs-lookup"><span data-stu-id="cfe97-305">With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="cfe97-306">Référencement de types, consultez le [l’importation de schéma pour générer des Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="cfe97-306"> referencing types, see the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span>  
  
 <span data-ttu-id="cfe97-307">La prise en charge des groupes de données typés dans le modèle de contrat de données est limitée.</span><span class="sxs-lookup"><span data-stu-id="cfe97-307">Support for typed DataSets in the data contract model is limited.</span></span> <span data-ttu-id="cfe97-308">Les groupes de données typés peuvent être sérialisés et désérialisés et exportés à partir de leur schéma.</span><span class="sxs-lookup"><span data-stu-id="cfe97-308">Typed DataSets can be serialized and deserialized and can export their schema.</span></span> <span data-ttu-id="cfe97-309">Cependant, l'importation du schéma de contrat de données ne peut pas générer de nouveaux types DataSet typés depuis le schéma, elle ne peut que réutiliser les types existants.</span><span class="sxs-lookup"><span data-stu-id="cfe97-309">However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.</span></span> <span data-ttu-id="cfe97-310">Vous pouvez pointer vers un DataSet typé existant à l'aide du commutateur `/r` sur Svcutil.exe.</span><span class="sxs-lookup"><span data-stu-id="cfe97-310">You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe.</span></span> <span data-ttu-id="cfe97-311">Si vous tentez d'utiliser Svcutil.exe sans le commutateur `/r` sur un service qui utilise un groupe de données typé, un autre sérialiseur est automatiquement (XmlSerializer) sélectionné.</span><span class="sxs-lookup"><span data-stu-id="cfe97-311">If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.</span></span> <span data-ttu-id="cfe97-312">Si vous devez utiliser DataContractSerializer et générer des DataSets à partir du schéma, procédez comme suit : générez les types DataSet typés (à l'aide de l'outil Xsd.exe et du commutateur `/d` sur le service), compilez les types, et pointez vers eux à l'aide du commutateur `/r` sur Svcutil.exe.</span><span class="sxs-lookup"><span data-stu-id="cfe97-312">If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="cfe97-313">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="cfe97-313">See Also</span></span>  
 <xref:System.Runtime.Serialization.DataContractSerializer>  
 <xref:System.Xml.Serialization.IXmlSerializable>  
 [<span data-ttu-id="cfe97-314">À l’aide de contrats de données</span><span class="sxs-lookup"><span data-stu-id="cfe97-314">Using Data Contracts</span></span>](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)  
 [<span data-ttu-id="cfe97-315">Types pris en charge par le sérialiseur de contrat de données</span><span class="sxs-lookup"><span data-stu-id="cfe97-315">Types Supported by the Data Contract Serializer</span></span>](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)
