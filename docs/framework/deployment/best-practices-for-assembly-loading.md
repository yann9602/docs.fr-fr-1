---
title: Meilleures pratiques pour le chargement d'assembly
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- assemblies,binding
- LoadFrom method
- default load context
- TypeLoadException class,causes
- assembly loading errors
- load contexts
- assemblies,loading
- LoadWithPartialName method
- load-from context
ms.assetid: 68d1c539-6a47-4614-ab59-4b071c9d4b4c
caps.latest.revision: "10"
author: mairaw
ms.author: mairaw
manager: wpickett
ms.openlocfilehash: 302be9cafc0fd2ef327767cbf1178d4927757d2d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/21/2017
---
# <a name="best-practices-for-assembly-loading"></a><span data-ttu-id="92039-102">Meilleures pratiques pour le chargement d'assembly</span><span class="sxs-lookup"><span data-stu-id="92039-102">Best Practices for Assembly Loading</span></span>
<span data-ttu-id="92039-103">Cet article explique les moyens d’éviter les problèmes d’identités de type qui peuvent générer des exceptions <xref:System.InvalidCastException> et <xref:System.MissingMethodException>, et d’autres erreurs.</span><span class="sxs-lookup"><span data-stu-id="92039-103">This article discusses ways to avoid problems of type identity that can lead to <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, and other errors.</span></span> <span data-ttu-id="92039-104">L’article aborde les recommandations suivantes :</span><span class="sxs-lookup"><span data-stu-id="92039-104">The article discusses the following recommendations:</span></span>  
  
-   [<span data-ttu-id="92039-105">Comprendre les avantages et les inconvénients des contextes de chargement</span><span class="sxs-lookup"><span data-stu-id="92039-105">Understand the advantages and disadvantages of load contexts</span></span>](#load_contexts)  
  
-   [<span data-ttu-id="92039-106">Éviter la liaison sur les noms d’assemblys partiels</span><span class="sxs-lookup"><span data-stu-id="92039-106">Avoid binding on partial assembly names</span></span>](#avoid_partial_names)  
  
-   [<span data-ttu-id="92039-107">Éviter de charger un assembly dans plusieurs contextes</span><span class="sxs-lookup"><span data-stu-id="92039-107">Avoid loading an assembly into multiple contexts</span></span>](#avoid_loading_into_multiple_contexts)  
  
-   [<span data-ttu-id="92039-108">Éviter de charger plusieurs versions d’un assembly dans le même contexte</span><span class="sxs-lookup"><span data-stu-id="92039-108">Avoid loading multiple versions of an assembly into the same context</span></span>](#avoid_loading_multiple_versions)  
  
-   [<span data-ttu-id="92039-109">Envisager de basculer vers le contexte de chargement par défaut</span><span class="sxs-lookup"><span data-stu-id="92039-109">Consider switching to the default load context</span></span>](#switch_to_default)  
  
 <span data-ttu-id="92039-110">La première recommandation, [comprendre les avantages et inconvénients des contextes de chargement](#load_contexts), fournit des informations générales pour les autres recommandations, car elles dépendent toutes d’une connaissance des contextes de chargement.</span><span class="sxs-lookup"><span data-stu-id="92039-110">The first recommendation, [understand the advantages and disadvantages of load contexts](#load_contexts), provides background information for the other recommendations, because they all depend on a knowledge of load contexts.</span></span>  
  
<a name="load_contexts"></a>   
## <a name="understand-the-advantages-and-disadvantages-of-load-contexts"></a><span data-ttu-id="92039-111">Comprendre les avantages et les inconvénients des contextes de chargement</span><span class="sxs-lookup"><span data-stu-id="92039-111">Understand the Advantages and Disadvantages of Load Contexts</span></span>  
 <span data-ttu-id="92039-112">Dans un domaine d’application, les assemblys peuvent être chargés dans un contexte parmi trois, ou peuvent être chargés sans contexte :</span><span class="sxs-lookup"><span data-stu-id="92039-112">Within an application domain, assemblies can be loaded into one of three contexts, or they can be loaded without context:</span></span>  
  
-   <span data-ttu-id="92039-113">Le contexte de chargement par défaut contient les assemblys trouvés en recherchant dans le Global Assembly Cache, dans le magasin d’assemblys de l’hôte si le runtime est hébergé (par exemple dans SQL Server), et dans le <xref:System.AppDomainSetup.ApplicationBase%2A> et le <xref:System.AppDomainSetup.PrivateBinPath%2A> du domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="92039-113">The default load context contains assemblies found by probing the global assembly cache, the host assembly store if the runtime is hosted (for example, in SQL Server), and the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="92039-114">La plupart des surcharges de la méthode <xref:System.Reflection.Assembly.Load%2A> chargent les assemblys dans ce contexte.</span><span class="sxs-lookup"><span data-stu-id="92039-114">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="92039-115">Le contexte de chargement source contient des assemblys chargés à partir d’emplacements où le chargeur ne fait pas de recherche.</span><span class="sxs-lookup"><span data-stu-id="92039-115">The load-from context contains assemblies that are loaded from locations that are not searched by the loader.</span></span> <span data-ttu-id="92039-116">Par exemple, des compléments peuvent être installés dans un répertoire qui n’est pas sous le chemin de l’application.</span><span class="sxs-lookup"><span data-stu-id="92039-116">For example, add-ins might be installed in a directory that is not under the application path.</span></span> <span data-ttu-id="92039-117"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, <xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType> et <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType> sont des exemples de méthodes qui sont chargées via un chemin.</span><span class="sxs-lookup"><span data-stu-id="92039-117"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, <xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType>, and <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType> are examples of methods that load by path.</span></span>  
  
-   <span data-ttu-id="92039-118">Le contexte de réflexion uniquement contient des assemblys chargés avec les méthodes <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> et <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="92039-118">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods.</span></span> <span data-ttu-id="92039-119">Le code de ce contexte ne peut pas être exécuté et il n’est donc pas abordé ici.</span><span class="sxs-lookup"><span data-stu-id="92039-119">Code in this context cannot be executed, so it is not discussed here.</span></span> <span data-ttu-id="92039-120">Pour plus d’informations, consultez [Guide pratique pour charger des assemblys dans le contexte de réflexion uniquement](../../../docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span><span class="sxs-lookup"><span data-stu-id="92039-120">For more information, see [How to: Load Assemblies into the Reflection-Only Context](../../../docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
-   <span data-ttu-id="92039-121">Si vous avez généré un assembly dynamique transitoire en utilisant l’émission par réflexion, l’assembly ne se trouve dans aucun contexte.</span><span class="sxs-lookup"><span data-stu-id="92039-121">If you generated a transient dynamic assembly by using reflection emit, the assembly is not in any context.</span></span> <span data-ttu-id="92039-122">En outre, la plupart des assemblys chargés à l’aide de la méthode <xref:System.Reflection.Assembly.LoadFile%2A> sont chargés sans contexte, et les assemblys qui sont chargés à partir de tableaux d’octets sont chargés sans contexte, à moins que leur identité (une fois que la stratégie est appliquée) établisse qu’ils se trouvent dans le Global Assembly Cache.</span><span class="sxs-lookup"><span data-stu-id="92039-122">In addition, most assemblies that are loaded by using the <xref:System.Reflection.Assembly.LoadFile%2A> method are loaded without context, and assemblies that are loaded from byte arrays are loaded without context unless their identity (after policy is applied) establishes that they are in the global assembly cache.</span></span>  
  
 <span data-ttu-id="92039-123">Les contextes d’exécution présentent des avantages et des inconvénients, qui sont présentés dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="92039-123">The execution contexts have advantages and disadvantages, as discussed in the following sections.</span></span>  
  
### <a name="default-load-context"></a><span data-ttu-id="92039-124">Contexte de chargement par défaut</span><span class="sxs-lookup"><span data-stu-id="92039-124">Default Load Context</span></span>  
 <span data-ttu-id="92039-125">Quand les assemblys sont chargés dans le contexte de chargement par défaut, leurs dépendances sont chargées automatiquement.</span><span class="sxs-lookup"><span data-stu-id="92039-125">When assemblies are loaded into the default load context, their dependencies are loaded automatically.</span></span> <span data-ttu-id="92039-126">Les dépendances qui sont chargées dans le contexte de chargement par défaut sont trouvées automatiquement pour les assemblys dans le contexte de chargement par défaut ou dans le contexte de chargement source.</span><span class="sxs-lookup"><span data-stu-id="92039-126">Dependencies that are loaded into the default load context are found automatically for assemblies in the default load context or the load-from context.</span></span> <span data-ttu-id="92039-127">Le chargement par identité d’assembly augmente la stabilité des applications en vérifiant que des versions inconnues des assemblys ne sont pas utilisées (consultez la section [Éviter la liaison sur les noms d’assemblys partiels](#avoid_partial_names)).</span><span class="sxs-lookup"><span data-stu-id="92039-127">Loading by assembly identity increases the stability of applications by ensuring that unknown versions of assemblies are not used (see the [Avoid Binding on Partial Assembly Names](#avoid_partial_names) section).</span></span>  
  
 <span data-ttu-id="92039-128">L’utilisation du contexte de chargement par défaut a les inconvénients suivants :</span><span class="sxs-lookup"><span data-stu-id="92039-128">Using the default load context has the following disadvantages:</span></span>  
  
-   <span data-ttu-id="92039-129">Les dépendances chargées dans d’autres contextes ne sont pas disponibles.</span><span class="sxs-lookup"><span data-stu-id="92039-129">Dependencies that are loaded into other contexts are not available.</span></span>  
  
-   <span data-ttu-id="92039-130">Vous ne pouvez pas charger des assemblys à partir d’emplacements qui sont en dehors du chemin de recherche dans le contexte de chargement par défaut.</span><span class="sxs-lookup"><span data-stu-id="92039-130">You cannot load assemblies from locations outside the probing path into the default load context.</span></span>  
  
### <a name="load-from-context"></a><span data-ttu-id="92039-131">Contexte de chargement source</span><span class="sxs-lookup"><span data-stu-id="92039-131">Load-From Context</span></span>  
 <span data-ttu-id="92039-132">Le contexte de chargement source vous permet de charger un assembly à partir d’un chemin qui n’est pas sous le chemin de l’application et qui n’est par conséquent pas inclus dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="92039-132">The load-from context lets you load an assembly from a path that is not under the application path, and therefore is not included in probing.</span></span> <span data-ttu-id="92039-133">Il permet la localisation et le chargement des dépendances à partir de ce chemin, car les informations du chemin sont gérées par le contexte.</span><span class="sxs-lookup"><span data-stu-id="92039-133">It enables dependencies to be located and loaded from that path, because the path information is maintained by the context.</span></span> <span data-ttu-id="92039-134">En outre, les assemblys de ce contexte peuvent utiliser les dépendances qui sont chargées dans le contexte de chargement par défaut.</span><span class="sxs-lookup"><span data-stu-id="92039-134">In addition, assemblies in this context can use dependencies that are loaded into the default load context.</span></span>  
  
 <span data-ttu-id="92039-135">Le chargement des assemblys à l’aide de la méthode <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> ou de l’une des autres méthodes qui chargent via un chemin a les inconvénients suivants :</span><span class="sxs-lookup"><span data-stu-id="92039-135">Loading assemblies by using the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method, or one of the other methods that load by path, has the following disadvantages:</span></span>  
  
-   <span data-ttu-id="92039-136">Si un assembly avec la même identité est déjà chargé, <xref:System.Reflection.Assembly.LoadFrom%2A> retourne l’assembly chargé même si un autre chemin a été spécifié.</span><span class="sxs-lookup"><span data-stu-id="92039-136">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="92039-137">Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A> et qu’ultérieurement, un assembly du contexte de chargement par défaut essaie de charger le même assembly via le nom d’affichage, la tentative de chargement échoue.</span><span class="sxs-lookup"><span data-stu-id="92039-137">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the default load context tries to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="92039-138">Ceci peut se produire quand un assembly est désérialisé.</span><span class="sxs-lookup"><span data-stu-id="92039-138">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="92039-139">Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A> et que le chemin de recherche inclut un assembly avec la même identité mais à un emplacement différent, une <xref:System.InvalidCastException>, <xref:System.MissingMethodException> ou un autre comportement inattendu peut se produire.</span><span class="sxs-lookup"><span data-stu-id="92039-139">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but in a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="92039-140"><xref:System.Reflection.Assembly.LoadFrom%2A> demande <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> et <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, sur le chemin spécifié.</span><span class="sxs-lookup"><span data-stu-id="92039-140"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="92039-141">S’il existe une image native pour l’assembly, elle n’est pas utilisée.</span><span class="sxs-lookup"><span data-stu-id="92039-141">If a native image exists for the assembly, it is not used.</span></span>  
  
-   <span data-ttu-id="92039-142">L’assembly ne peut pas être chargé comme étant indépendant du domaine.</span><span class="sxs-lookup"><span data-stu-id="92039-142">The assembly cannot be loaded as domain-neutral.</span></span>  
  
-   <span data-ttu-id="92039-143">Dans les versions 1.0 et 1.1 du .NET Framework, la stratégie n’est pas appliquée.</span><span class="sxs-lookup"><span data-stu-id="92039-143">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
### <a name="no-context"></a><span data-ttu-id="92039-144">Pas de contexte</span><span class="sxs-lookup"><span data-stu-id="92039-144">No Context</span></span>  
 <span data-ttu-id="92039-145">Le chargement sans contexte est la seule option pour les assemblys transitoires générés avec l’émission par réflexion.</span><span class="sxs-lookup"><span data-stu-id="92039-145">Loading without context is the only option for transient assemblies that are generated with reflection emit.</span></span> <span data-ttu-id="92039-146">Le chargement sans contexte est la seule façon de charger plusieurs assemblys qui ont la même identité dans un même domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="92039-146">Loading without context is the only way to load multiple assemblies that have the same identity into one application domain.</span></span> <span data-ttu-id="92039-147">Ceci permet d’éviter le coût lié à la recherche.</span><span class="sxs-lookup"><span data-stu-id="92039-147">The cost of probing is avoided.</span></span>  
  
 <span data-ttu-id="92039-148">Les assemblys chargés à partir de tableaux d’octets sont chargés sans contexte, sauf si l’identité de l’assembly, qui est établie quand la stratégie est appliquée, correspond à l’identité d’un assembly dans le Global Assembly Cache. Dans ce cas, l’assembly est chargé à partir du Global Assembly Cache.</span><span class="sxs-lookup"><span data-stu-id="92039-148">Assemblies that are loaded from byte arrays are loaded without context unless the identity of the assembly, which is established when policy is applied, matches the identity of an assembly in the global assembly cache; in that case, the assembly is loaded from the global assembly cache.</span></span>  
  
 <span data-ttu-id="92039-149">Le chargement d’assemblys sans contexte a les inconvénients suivants :</span><span class="sxs-lookup"><span data-stu-id="92039-149">Loading assemblies without context has the following disadvantages:</span></span>  
  
-   <span data-ttu-id="92039-150">D’autres assemblys ne peuvent pas se lier aux assemblys qui sont chargés sans contexte, sauf si vous gérez l’événement <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="92039-150">Other assemblies cannot bind to assemblies that are loaded without context, unless you handle the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
-   <span data-ttu-id="92039-151">Les dépendances ne sont pas chargées automatiquement.</span><span class="sxs-lookup"><span data-stu-id="92039-151">Dependencies are not loaded automatically.</span></span> <span data-ttu-id="92039-152">Vous pouvez les précharger sans contexte, les précharger dans le contexte de chargement par défaut ou les charger en gérant l’événement <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="92039-152">You can preload them without context, preload them into the default load context, or load them by handling the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
-   <span data-ttu-id="92039-153">Le chargement de plusieurs assemblys avec la même identité sans contexte peut provoquer des problèmes d’identité de type similaires à ceux provoqués par le chargement d’assemblys avec la même identité dans plusieurs contextes.</span><span class="sxs-lookup"><span data-stu-id="92039-153">Loading multiple assemblies with the same identity without context can cause type identity problems similar to those caused by loading assemblies with the same identity into multiple contexts.</span></span> <span data-ttu-id="92039-154">Consultez [Éviter de charger un assembly dans plusieurs contextes](#avoid_loading_into_multiple_contexts).</span><span class="sxs-lookup"><span data-stu-id="92039-154">See [Avoid Loading an Assembly into Multiple Contexts](#avoid_loading_into_multiple_contexts).</span></span>  
  
-   <span data-ttu-id="92039-155">S’il existe une image native pour l’assembly, elle n’est pas utilisée.</span><span class="sxs-lookup"><span data-stu-id="92039-155">If a native image exists for the assembly, it is not used.</span></span>  
  
-   <span data-ttu-id="92039-156">L’assembly ne peut pas être chargé comme étant indépendant du domaine.</span><span class="sxs-lookup"><span data-stu-id="92039-156">The assembly cannot be loaded as domain-neutral.</span></span>  
  
-   <span data-ttu-id="92039-157">Dans les versions 1.0 et 1.1 du .NET Framework, la stratégie n’est pas appliquée.</span><span class="sxs-lookup"><span data-stu-id="92039-157">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
<a name="avoid_partial_names"></a>   
## <a name="avoid-binding-on-partial-assembly-names"></a><span data-ttu-id="92039-158">Éviter la liaison sur les noms d’assemblys partiels</span><span class="sxs-lookup"><span data-stu-id="92039-158">Avoid Binding on Partial Assembly Names</span></span>  
 <span data-ttu-id="92039-159">Une liaison de nom partiel se produit quand vous ne spécifiez qu’une partie du nom d’affichage de l’assembly (<xref:System.Reflection.Assembly.FullName%2A>) quand vous chargez un assembly.</span><span class="sxs-lookup"><span data-stu-id="92039-159">Partial name binding occurs when you specify only part of the assembly display name (<xref:System.Reflection.Assembly.FullName%2A>) when you load an assembly.</span></span> <span data-ttu-id="92039-160">Par exemple, vous pouvez appeler la méthode <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> avec seulement le nom simple de l’assembly, en omettant la version, la culture et le jeton de clé publique.</span><span class="sxs-lookup"><span data-stu-id="92039-160">For example, you might call the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method with only the simple name of the assembly, omitting the version, culture, and public key token.</span></span> <span data-ttu-id="92039-161">Vous pouvez aussi appeler la méthode <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>, qui appelle d’abord la méthode <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> et qui, en cas d’échec de la localisation de l’assembly, recherche dans le Global Assembly Cache et charge la dernière version disponible de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="92039-161">Or you might call the <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method, which first calls the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and, if that fails to locate the assembly, searches the global assembly cache and loads the latest available version of the assembly.</span></span>  
  
 <span data-ttu-id="92039-162">Une liaison de nom partiel peut provoquer de nombreux problèmes, notamment les suivants :</span><span class="sxs-lookup"><span data-stu-id="92039-162">Partial name binding can cause many problems, including the following:</span></span>  
  
-   <span data-ttu-id="92039-163">La méthode <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> peut charger un autre assembly portant le même nom simple.</span><span class="sxs-lookup"><span data-stu-id="92039-163">The <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method might load a different assembly with the same simple name.</span></span> <span data-ttu-id="92039-164">Par exemple, deux applications peuvent installer deux assemblys complètement différents qui ont tous deux le nom simple `GraphicsLibrary` dans le Global Assembly Cache.</span><span class="sxs-lookup"><span data-stu-id="92039-164">For example, two applications might install two completely different assemblies that both have the simple name `GraphicsLibrary` into the global assembly cache.</span></span>  
  
-   <span data-ttu-id="92039-165">L’assembly qui est actuellement chargé risque de ne pas être à compatibilité descendante.</span><span class="sxs-lookup"><span data-stu-id="92039-165">The assembly that is actually loaded might not be backward-compatible.</span></span> <span data-ttu-id="92039-166">Par exemple, le fait de ne pas spécifier la version risque d’aboutir au chargement d’une version beaucoup plus récente que la version pour laquelle votre programme a été écrit à l’origine.</span><span class="sxs-lookup"><span data-stu-id="92039-166">For example, not specifying the version might result in the loading of a much later version than the version your program was originally written to use.</span></span> <span data-ttu-id="92039-167">Des modifications dans la version plus récente peuvent provoquer des erreurs dans votre application.</span><span class="sxs-lookup"><span data-stu-id="92039-167">Changes in the later version might cause errors in your application.</span></span>  
  
-   <span data-ttu-id="92039-168">L’assembly qui est actuellement chargé risque de ne pas être à compatibilité ascendante.</span><span class="sxs-lookup"><span data-stu-id="92039-168">The assembly that is actually loaded might not be forward-compatible.</span></span> <span data-ttu-id="92039-169">Par exemple, vous pouvez avoir généré et testé votre application avec la version la plus récente d’un assembly, mais une liaison partielle peut charger une version beaucoup plus ancienne où des fonctionnalités utilisées par votre application sont absentes.</span><span class="sxs-lookup"><span data-stu-id="92039-169">For example, you might have built and tested your application with the latest version of an assembly, but partial binding might load a much earlier version that lacks features your application uses.</span></span>  
  
-   <span data-ttu-id="92039-170">L’installation de nouvelles applications peut endommager des applications existantes.</span><span class="sxs-lookup"><span data-stu-id="92039-170">Installing new applications can break existing applications.</span></span> <span data-ttu-id="92039-171">Une application qui utilise la méthode <xref:System.Reflection.Assembly.LoadWithPartialName%2A> peut être endommagée en raison de l’installation d’une version plus récente et incompatible d’un assembly partagé.</span><span class="sxs-lookup"><span data-stu-id="92039-171">An application that uses the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method can be broken by installing a newer, incompatible version of a shared assembly.</span></span>  
  
-   <span data-ttu-id="92039-172">Le chargement d’une dépendance inattendue peut se produire.</span><span class="sxs-lookup"><span data-stu-id="92039-172">Unexpected dependency loading can occur.</span></span> <span data-ttu-id="92039-173">Si vous chargez deux assemblys qui partagent une dépendance, leur chargement avec une liaison partielle peut aboutir à ce qu’un assembly utilise un composant avec lequel il n’a pas été généré ou testé.</span><span class="sxs-lookup"><span data-stu-id="92039-173">It you load two assemblies that share a dependency, loading them with partial binding might result in one assembly using a component that it was not built or tested with.</span></span>  
  
 <span data-ttu-id="92039-174">En raison des problèmes qu’elle peut provoquer, la méthode <xref:System.Reflection.Assembly.LoadWithPartialName%2A> a été marquée comme étant dépréciée.</span><span class="sxs-lookup"><span data-stu-id="92039-174">Because of the problems it can cause, the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method has been marked obsolete.</span></span> <span data-ttu-id="92039-175">Nous vous recommandons d’utiliser à la place la méthode <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> et de spécifier des noms d’affichage d’assemblys complets.</span><span class="sxs-lookup"><span data-stu-id="92039-175">We recommend that you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method instead, and specify full assembly display names.</span></span> <span data-ttu-id="92039-176">Consultez [Comprendre les avantages et les inconvénients des contextes de chargement](#load_contexts) et [Envisager de basculer vers le contexte de chargement par défaut](#switch_to_default).</span><span class="sxs-lookup"><span data-stu-id="92039-176">See [Understand the Advantages and Disadvantages of Load Contexts](#load_contexts) and [Consider Switching to the Default Load Context](#switch_to_default).</span></span>  
  
 <span data-ttu-id="92039-177">Si vous voulez utiliser la méthode <xref:System.Reflection.Assembly.LoadWithPartialName%2A> car elle facilite le chargement des assemblys, prenez en compte le fait que si votre application échoue avec un message d’erreur qui identifie l’assembly manquant, ceci est probablement susceptible de fournir une meilleure expérience utilisateur, au contraire de l’utilisation automatique d’une version inconnue de l’assembly, qui peut entraîner des failles de sécurité et un comportement imprévisible.</span><span class="sxs-lookup"><span data-stu-id="92039-177">If you want to use the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method because it makes assembly loading easy, consider that having your application fail with an error message that identifies the missing assembly is likely to provide a better user experience than automatically using an unknown version of the assembly, which might cause unpredictable behavior and security holes.</span></span>  
  
<a name="avoid_loading_into_multiple_contexts"></a>   
## <a name="avoid-loading-an-assembly-into-multiple-contexts"></a><span data-ttu-id="92039-178">Éviter de charger un assembly dans plusieurs contextes</span><span class="sxs-lookup"><span data-stu-id="92039-178">Avoid Loading an Assembly into Multiple Contexts</span></span>  
 <span data-ttu-id="92039-179">Le chargement d’un assembly dans plusieurs contextes peut provoquer des problèmes d’identités de type.</span><span class="sxs-lookup"><span data-stu-id="92039-179">Loading an assembly into multiple contexts can cause type identity problems.</span></span> <span data-ttu-id="92039-180">Si le même type est chargé à partir du même assembly dans deux contextes différents, c’est comme si deux types différents du même nom avaient été chargés.</span><span class="sxs-lookup"><span data-stu-id="92039-180">If the same type is loaded from the same assembly into two different contexts, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="92039-181">Une <xref:System.InvalidCastException> est levée si vous essayez d’effectuer un cast d’un type à l’autre, avec un message trompeur, selon lequel le type `MyType` ne peut pas être converti en type `MyType`.</span><span class="sxs-lookup"><span data-stu-id="92039-181">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="92039-182">Par exemple, supposons que l’interface `ICommunicate` est déclarée dans un assembly nommé `Utility`, qui est référencé par votre programme et aussi par d’autres assemblys chargés par votre programme.</span><span class="sxs-lookup"><span data-stu-id="92039-182">For example, suppose that the `ICommunicate` interface is declared in an assembly named `Utility`, which is referenced by your program and also by other assemblies that your program loads.</span></span> <span data-ttu-id="92039-183">Ces autres assemblys contiennent des types qui implémentent l’interface `ICommunicate`, permettant à votre programme de les utiliser.</span><span class="sxs-lookup"><span data-stu-id="92039-183">These other assemblies contain types that implement the `ICommunicate` interface, allowing your program to use them.</span></span>  
  
 <span data-ttu-id="92039-184">Considérez à présent ce qui se passe quand votre programme est exécuté.</span><span class="sxs-lookup"><span data-stu-id="92039-184">Now consider what happens when your program is run.</span></span> <span data-ttu-id="92039-185">Les assemblys référencés par votre programme sont chargés dans le contexte de chargement par défaut.</span><span class="sxs-lookup"><span data-stu-id="92039-185">Assemblies that are referenced by your program are loaded into the default load context.</span></span> <span data-ttu-id="92039-186">Si vous chargez un assembly cible via son identité en utilisant la méthode <xref:System.Reflection.Assembly.Load%2A>, elle sera dans le contexte de chargement par défaut, comme le seront ses dépendances.</span><span class="sxs-lookup"><span data-stu-id="92039-186">If you load a target assembly by its identity, using the <xref:System.Reflection.Assembly.Load%2A> method, it will be in the default load context, and so will its dependencies.</span></span> <span data-ttu-id="92039-187">Votre programme et l’assembly cible utilisent le même assembly `Utility`.</span><span class="sxs-lookup"><span data-stu-id="92039-187">Both your program and the target assembly will use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="92039-188">Supposez cependant que vous chargez l’assembly cible via son chemin de fichier en utilisant la méthode <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="92039-188">However, suppose you load the target assembly by its file path, using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="92039-189">L’assembly est chargé sans aucun contexte, et ses dépendances ne sont donc pas chargées automatiquement.</span><span class="sxs-lookup"><span data-stu-id="92039-189">The assembly is loaded without any context, so its dependencies are not automatically loaded.</span></span> <span data-ttu-id="92039-190">Vous pouvez avoir un gestionnaire pour l’événement <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> pour fournir la dépendance, et il peut charger l’assembly `Utility` sans contexte à l’aide de la méthode <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="92039-190">You might have a handler for the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event to supply the dependency, and it might load the `Utility` assembly with no context by using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="92039-191">Quand vous créez une instance d’un type qui est contenu dans l’assembly cible et que vous essayez de l’affecter à une variable de type `ICommunicate`, une <xref:System.InvalidCastException> est levée, car le runtime considère que les interfaces `ICommunicate` dans les deux copies de l’assembly `Utility` sont des types différents.</span><span class="sxs-lookup"><span data-stu-id="92039-191">Now when you create an instance of a type that is contained in the target assembly and try to assign it to a variable of type `ICommunicate`, an <xref:System.InvalidCastException> is thrown because the runtime considers the `ICommunicate` interfaces in the two copies of the `Utility` assembly to be different types.</span></span>  
  
 <span data-ttu-id="92039-192">Il existe de nombreux autres scénarios dans lesquels un assembly peut être chargé dans plusieurs contextes.</span><span class="sxs-lookup"><span data-stu-id="92039-192">There are many other scenarios in which an assembly can be loaded into multiple contexts.</span></span> <span data-ttu-id="92039-193">La meilleure approche consiste à éviter les conflits en déplaçant l’assembly cible dans le chemin de votre application et en utilisant la méthode <xref:System.Reflection.Assembly.Load%2A> avec le nom d’affichage complet.</span><span class="sxs-lookup"><span data-stu-id="92039-193">The best approach is to avoid conflicts by relocating the target assembly in your application path and using the <xref:System.Reflection.Assembly.Load%2A> method with the full display name.</span></span> <span data-ttu-id="92039-194">L’assembly est ensuite chargé dans le contexte de chargement par défaut, et les deux assemblys utilisent le même assembly `Utility`.</span><span class="sxs-lookup"><span data-stu-id="92039-194">The assembly is then loaded into the default load context, and both assemblies use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="92039-195">Si l’assembly cible doit rester en dehors du chemin de votre application, vous pouvez utiliser la méthode <xref:System.Reflection.Assembly.LoadFrom%2A> pour le charger dans le contexte de chargement source.</span><span class="sxs-lookup"><span data-stu-id="92039-195">If the target assembly must remain outside your application path, you can use the <xref:System.Reflection.Assembly.LoadFrom%2A> method to load it into the load-from context.</span></span> <span data-ttu-id="92039-196">Si l’assembly cible a été compilé avec une référence à l’assembly `Utility` de votre application, il utilisera l’assembly `Utility` que votre application a chargé dans le contexte de chargement par défaut.</span><span class="sxs-lookup"><span data-stu-id="92039-196">If the target assembly was compiled with a reference to your application's `Utility` assembly, it will use the `Utility` assembly that your application has loaded into the default load context.</span></span> <span data-ttu-id="92039-197">Notez que des problèmes peuvent se produire si l’assembly cible a une dépendance d’une copie de l’assembly `Utility` qui se trouve en dehors du chemin de votre application.</span><span class="sxs-lookup"><span data-stu-id="92039-197">Note that problems can occur if the target assembly has a dependency on a copy of the `Utility` assembly located outside your application path.</span></span> <span data-ttu-id="92039-198">Si cet assembly est chargé dans le contexte de chargement source avant que votre application ne charge l’assembly `Utility`, le chargement de votre application échoue.</span><span class="sxs-lookup"><span data-stu-id="92039-198">If that assembly is loaded into the load-from context before your application loads the `Utility` assembly, your application's load will fail.</span></span>  
  
 <span data-ttu-id="92039-199">La section [Envisager de basculer vers le contexte de chargement par défaut](#switch_to_default) traite des alternatives à l’utilisation des chargements via un chemin de fichier, comme <xref:System.Reflection.Assembly.LoadFile%2A> et <xref:System.Reflection.Assembly.LoadFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="92039-199">The [Consider Switching to the Default Load Context](#switch_to_default) section discusses alternatives to using file path loads such as <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A>.</span></span>  
  
<a name="avoid_loading_multiple_versions"></a>   
## <a name="avoid-loading-multiple-versions-of-an-assembly-into-the-same-context"></a><span data-ttu-id="92039-200">Éviter de charger plusieurs versions d’un assembly dans le même contexte</span><span class="sxs-lookup"><span data-stu-id="92039-200">Avoid Loading Multiple Versions of an Assembly into the Same Context</span></span>  
 <span data-ttu-id="92039-201">Le chargement de plusieurs versions d’un assembly dans un même contexte de chargement peut provoquer des problèmes d’identité de type.</span><span class="sxs-lookup"><span data-stu-id="92039-201">Loading multiple versions of an assembly into one load context can cause type identity problems.</span></span> <span data-ttu-id="92039-202">Si le même type est chargé à partir de deux versions du même assembly, c’est comme si deux types différents du même nom avaient été chargés.</span><span class="sxs-lookup"><span data-stu-id="92039-202">If the same type is loaded from two versions of the same assembly, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="92039-203">Une <xref:System.InvalidCastException> est levée si vous essayez d’effectuer un cast d’un type à l’autre, avec un message trompeur, selon lequel le type `MyType` ne peut pas être converti en type `MyType`.</span><span class="sxs-lookup"><span data-stu-id="92039-203">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="92039-204">Par exemple, votre programme peut charger directement une version de l’assembly `Utility`, et il peut charger ultérieurement un autre assembly qui charge une version différente de l’assembly `Utility`.</span><span class="sxs-lookup"><span data-stu-id="92039-204">For example, your program might load one version of the `Utility` assembly directly, and later it might load another assembly that loads a different version of the `Utility` assembly.</span></span> <span data-ttu-id="92039-205">De même, une erreur de codage peut faire que deux chemins de code différents dans votre application chargent des versions différentes d’un assembly.</span><span class="sxs-lookup"><span data-stu-id="92039-205">Or a coding error might cause two different code paths in your application to load different versions of an assembly.</span></span>  
  
 <span data-ttu-id="92039-206">Dans le contexte de chargement par défaut, ce problème peut se produire quand vous utilisez la méthode <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> et que vous spécifiez des noms d’affichage d’assemblys complets qui incluent des numéros de version différents.</span><span class="sxs-lookup"><span data-stu-id="92039-206">In the default load context, this problem can occur when you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and specify complete assembly display names that include different version numbers.</span></span> <span data-ttu-id="92039-207">Pour les assemblys chargés sans contexte, le problème peut être dû à l’utilisation de la méthode <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> pour charger le même assembly à partir de différents chemins.</span><span class="sxs-lookup"><span data-stu-id="92039-207">For assemblies that are loaded without context, the problem can be caused by using the <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> method to load the same assembly from different paths.</span></span> <span data-ttu-id="92039-208">Le runtime considère deux assemblys chargés à partir de chemins différents comme des assemblys différents, même si leurs identités sont les mêmes.</span><span class="sxs-lookup"><span data-stu-id="92039-208">The runtime considers two assemblies that are loaded from different paths to be different assemblies, even if their identities are the same.</span></span>  
  
 <span data-ttu-id="92039-209">En plus des problèmes d’identités de type, plusieurs versions d’un même assembly peuvent provoquer une <xref:System.MissingMethodException> si un type qui est chargé à partir d’une version de l’assembly est passé au code qui attend ce type d’une autre version.</span><span class="sxs-lookup"><span data-stu-id="92039-209">In addition to type identity problems, multiple versions of an assembly can cause a <xref:System.MissingMethodException> if a type that is loaded from one version of the assembly is passed to code that expects that type from a different version.</span></span> <span data-ttu-id="92039-210">Par exemple, le code peut attendre une méthode qui a été ajoutée à la version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="92039-210">For example, the code might expect a method that was added to the later version.</span></span>  
  
 <span data-ttu-id="92039-211">Des erreurs plus subtiles peuvent se produire si le comportement du type a changé entre les versions.</span><span class="sxs-lookup"><span data-stu-id="92039-211">More subtle errors can occur if the behavior of the type changed between versions.</span></span> <span data-ttu-id="92039-212">Par exemple, une méthode peut lever une exception inattendue ou retourner une valeur inattendue.</span><span class="sxs-lookup"><span data-stu-id="92039-212">For example, a method might throw an unexpected exception or return an unexpected value.</span></span>  
  
 <span data-ttu-id="92039-213">Examinez soigneusement votre code pour vérifier qu’une seule version d’un assembly est chargée.</span><span class="sxs-lookup"><span data-stu-id="92039-213">Carefully review your code to ensure that only one version of an assembly is loaded.</span></span> <span data-ttu-id="92039-214">Vous pouvez utiliser la méthode <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> pour déterminer quels assemblys sont chargés à un moment donné.</span><span class="sxs-lookup"><span data-stu-id="92039-214">You can use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> method to determine which assemblies are loaded at any given time.</span></span>  
  
<a name="switch_to_default"></a>   
## <a name="consider-switching-to-the-default-load-context"></a><span data-ttu-id="92039-215">Envisager de basculer vers le contexte de chargement par défaut</span><span class="sxs-lookup"><span data-stu-id="92039-215">Consider Switching to the Default Load Context</span></span>  
 <span data-ttu-id="92039-216">Examinez les modèles de chargement et de déploiement des assemblys de votre application.</span><span class="sxs-lookup"><span data-stu-id="92039-216">Examine your application's assembly loading and deployment patterns.</span></span> <span data-ttu-id="92039-217">Pouvez-vous éliminer des assemblys chargés à partir de tableaux d’octets ?</span><span class="sxs-lookup"><span data-stu-id="92039-217">Can you eliminate assemblies that are loaded from byte arrays?</span></span> <span data-ttu-id="92039-218">Pouvez-vous déplacer des assemblys dans le chemin de recherche ?</span><span class="sxs-lookup"><span data-stu-id="92039-218">Can you move assemblies into the probing path?</span></span> <span data-ttu-id="92039-219">Si les assemblys se trouvent dans le Global Assembly Cache ou dans le chemin de recherche du domaine d’application (autrement dit son <xref:System.AppDomainSetup.ApplicationBase%2A> et son <xref:System.AppDomainSetup.PrivateBinPath%2A>), vous pouvez charger l’assembly via son identité.</span><span class="sxs-lookup"><span data-stu-id="92039-219">If assemblies are located in the global assembly cache or in the application domain's probing path (that is, its <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A>), you can load the assembly by its identity.</span></span>  
  
 <span data-ttu-id="92039-220">S’il n’est pas possible de placer tous vos assemblys dans le chemin de recherche, considérez les solutions alternatives, comme utiliser le modèle de complément du .NET Framework, placer les assemblys dans le Global Assembly Cache ou créer des domaines d’application.</span><span class="sxs-lookup"><span data-stu-id="92039-220">If it is not possible to put all your assemblies in the probing path, consider alternatives such as using the .NET Framework add-in model, placing assemblies into the global assembly cache, or creating application domains.</span></span>  
  
### <a name="consider-using-the-net-framework-add-in-model"></a><span data-ttu-id="92039-221">Envisager d’utiliser le modèle de complément du .NET Framework</span><span class="sxs-lookup"><span data-stu-id="92039-221">Consider Using the .NET Framework Add-In Model</span></span>  
 <span data-ttu-id="92039-222">Si vous utilisez le contexte de chargement source pour implémenter des compléments, qui ne sont généralement pas installés dans la base de l’application, utilisez le modèle de complément du .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="92039-222">If you are using the load-from context to implement add-ins, which typically are not installed in the application base, use the .NET Framework add-in model.</span></span> <span data-ttu-id="92039-223">Ce modèle fournit une isolation au niveau du domaine d’application ou du processus, sans qu’il soit nécessaire de gérer vous-même les domaines d’application.</span><span class="sxs-lookup"><span data-stu-id="92039-223">This model provides isolation at the application domain or process level, without requiring you to manage application domains yourself.</span></span> <span data-ttu-id="92039-224">Pour plus d’informations sur le modèle de complément, consultez [Compléments et extensibilité](../../../docs/framework/add-ins/index.md).</span><span class="sxs-lookup"><span data-stu-id="92039-224">For information about the add-in model, see [Add-ins and Extensibility](../../../docs/framework/add-ins/index.md).</span></span>  
  
### <a name="consider-using-the-global-assembly-cache"></a><span data-ttu-id="92039-225">Envisager d’utiliser le Global Assembly Cache</span><span class="sxs-lookup"><span data-stu-id="92039-225">Consider Using the Global Assembly Cache</span></span>  
 <span data-ttu-id="92039-226">Placez les assemblys dans le Global Assembly Cache pour bénéficier d’un chemin d’assembly partagé qui est en dehors de l’application de base, sans perdre les avantages du contexte de chargement par défaut ou subir les inconvénients des autres contextes.</span><span class="sxs-lookup"><span data-stu-id="92039-226">Place assemblies in the global assembly cache to get the benefit of a shared assembly path that is outside the application base, without losing the advantages of the default load context or taking on the disadvantages of the other contexts.</span></span>  
  
### <a name="consider-using-application-domains"></a><span data-ttu-id="92039-227">Envisager d’utiliser des domaines d’application</span><span class="sxs-lookup"><span data-stu-id="92039-227">Consider Using Application Domains</span></span>  
 <span data-ttu-id="92039-228">Si vous déterminez que certains de vos assemblys ne peuvent pas être déployés dans le chemin de recherche de l’application, envisagez de créer un domaine d’application pour ces assemblys.</span><span class="sxs-lookup"><span data-stu-id="92039-228">If you determine that some of your assemblies cannot be deployed in the application's probing path, consider creating a new application domain for those assemblies.</span></span> <span data-ttu-id="92039-229">Utilisez <xref:System.AppDomainSetup> pour créer le domaine d’application, et utilisez <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> pour spécifier le chemin qui contient les assemblys que vous voulez charger.</span><span class="sxs-lookup"><span data-stu-id="92039-229">Use an <xref:System.AppDomainSetup> to create the new application domain, and use the <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> property to specify the path that contains the assemblies you want to load.</span></span> <span data-ttu-id="92039-230">Si vous avez plusieurs répertoires où rechercher, vous pouvez définir <xref:System.AppDomainSetup.ApplicationBase%2A> sur un répertoire racine et utiliser la propriété <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> pour identifier les sous-répertoires où rechercher.</span><span class="sxs-lookup"><span data-stu-id="92039-230">If you have multiple directories to probe, you can set the <xref:System.AppDomainSetup.ApplicationBase%2A> to a root directory and use the <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> property to identify the subdirectories to probe.</span></span> <span data-ttu-id="92039-231">Vous pouvez aussi créer plusieurs domaines d’application et définir <xref:System.AppDomainSetup.ApplicationBase%2A> pour chaque domaine d’application sur le chemin approprié pour ses assemblys.</span><span class="sxs-lookup"><span data-stu-id="92039-231">Alternatively, you can create multiple application domains and set the <xref:System.AppDomainSetup.ApplicationBase%2A> of each application domain to the appropriate path for its assemblies.</span></span>  
  
 <span data-ttu-id="92039-232">Notez que vous pouvez utiliser la méthode <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> pour charger ces assemblys.</span><span class="sxs-lookup"><span data-stu-id="92039-232">Note that you can use the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method to load these assemblies.</span></span> <span data-ttu-id="92039-233">Comme ils sont maintenant dans le chemin de recherche, ils seront chargés dans le contexte de chargement par défaut au lieu du contexte de chargement source.</span><span class="sxs-lookup"><span data-stu-id="92039-233">Because they are now in the probing path, they will be loaded into the default load context instead of the load-from context.</span></span> <span data-ttu-id="92039-234">Cependant, nous vous recommandons de passer à la méthode <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> et de spécifier des noms d’affichage d’assemblys complets pour garantir que les versions correctes sont toujours utilisées.</span><span class="sxs-lookup"><span data-stu-id="92039-234">However, we recommend that you switch to the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and supply full assembly display names to ensure that correct versions are always used.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="92039-235">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="92039-235">See Also</span></span>  
 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>  
 <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType>  
 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>  
 [<span data-ttu-id="92039-236">Compléments et extensibilité</span><span class="sxs-lookup"><span data-stu-id="92039-236">Add-ins and Extensibility</span></span>](../../../docs/framework/add-ins/index.md)
