---
title: "ICorProfilerInfo2::DoStackSnapshot, méthode"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: reference
api_name: ICorProfilerInfo2.DoStackSnapshot
api_location: mscorwks.dll
api_type: COM
f1_keywords: ICorProfilerInfo2::DoStackSnapshot
helpviewer_keywords:
- ICorProfilerInfo2::DoStackSnapshot method [.NET Framework profiling]
- DoStackSnapshot method [.NET Framework profiling]
ms.assetid: 287b11e9-7c52-4a13-ba97-751203fa97f4
topic_type: apiref
caps.latest.revision: "25"
author: mairaw
ms.author: mairaw
manager: wpickett
ms.openlocfilehash: 6a210fc0c1984ee9bc77114ba30c3287ae43b169
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/21/2017
---
# <a name="icorprofilerinfo2dostacksnapshot-method"></a><span data-ttu-id="62d8d-102">ICorProfilerInfo2::DoStackSnapshot, méthode</span><span class="sxs-lookup"><span data-stu-id="62d8d-102">ICorProfilerInfo2::DoStackSnapshot Method</span></span>
<span data-ttu-id="62d8d-103">Parcourt les frames managés sur la pile pour le thread spécifié et envoie des informations au profileur via un rappel.</span><span class="sxs-lookup"><span data-stu-id="62d8d-103">Walks the managed frames on the stack for the specified thread, and sends information to the profiler through a callback.</span></span>  
  
## <a name="syntax"></a><span data-ttu-id="62d8d-104">Syntaxe</span><span class="sxs-lookup"><span data-stu-id="62d8d-104">Syntax</span></span>  
  
```  
HRESULT DoStackSnapshot(  
    [in] ThreadID thread,  
    [in] StackSnapshotCallback *callback,  
    [in] ULONG32 infoFlags,  
    [in] void *clientData,  
    [in, size_is(contextSize), length_is(contextSize)] BYTE context[],  
    [in] ULONG32 contextSize);  
```  
  
#### <a name="parameters"></a><span data-ttu-id="62d8d-105">Paramètres</span><span class="sxs-lookup"><span data-stu-id="62d8d-105">Parameters</span></span>  
 `thread`  
 <span data-ttu-id="62d8d-106">[in] L’ID du thread cible.</span><span class="sxs-lookup"><span data-stu-id="62d8d-106">[in] The ID of the target thread.</span></span>  
  
 <span data-ttu-id="62d8d-107">En passant null dans `thread` produit un instantané du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="62d8d-107">Passing null in `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="62d8d-108">Si un `ThreadID` d’un autre thread est passé, le common language runtime (CLR) suspend ce thread, exécute l’instantané et reprend.</span><span class="sxs-lookup"><span data-stu-id="62d8d-108">If a `ThreadID` of a different thread is passed, the common language runtime (CLR) suspends that thread, performs the snapshot, and resumes.</span></span>  
  
 `callback`  
 <span data-ttu-id="62d8d-109">[in] Un pointeur vers l’implémentation de la [StackSnapshotCallback](../../../../docs/framework/unmanaged-api/profiling/stacksnapshotcallback-function.md) méthode, qui est appelée par le CLR pour fournir au profileur des informations sur chaque frame managé et chaque exécution de frames non managés.</span><span class="sxs-lookup"><span data-stu-id="62d8d-109">[in] A pointer to the implementation of the [StackSnapshotCallback](../../../../docs/framework/unmanaged-api/profiling/stacksnapshotcallback-function.md) method, which is called by the CLR to provide the profiler with information on each managed frame and each run of unmanaged frames.</span></span>  
  
 <span data-ttu-id="62d8d-110">Le `StackSnapshotCallback` méthode est implémentée par le writer de profileur.</span><span class="sxs-lookup"><span data-stu-id="62d8d-110">The `StackSnapshotCallback` method is implemented by the profiler writer.</span></span>  
  
 `infoFlags`  
 <span data-ttu-id="62d8d-111">[in] Une valeur de la [COR_PRF_SNAPSHOT_INFO](../../../../docs/framework/unmanaged-api/profiling/cor-prf-snapshot-info-enumeration.md) énumération qui spécifie la quantité de données à renvoyer pour chaque frame par `StackSnapshotCallback`.</span><span class="sxs-lookup"><span data-stu-id="62d8d-111">[in] A value of the [COR_PRF_SNAPSHOT_INFO](../../../../docs/framework/unmanaged-api/profiling/cor-prf-snapshot-info-enumeration.md) enumeration, which specifies the amount of data to be passed back for each frame by `StackSnapshotCallback`.</span></span>  
  
 `clientData`  
 <span data-ttu-id="62d8d-112">[in] Un pointeur vers les données client, qui sont transmises directement à la `StackSnapshotCallback` fonction de rappel.</span><span class="sxs-lookup"><span data-stu-id="62d8d-112">[in] A pointer to the client data, which is passed straight through to the `StackSnapshotCallback` callback function.</span></span>  
  
 `context`  
 <span data-ttu-id="62d8d-113">[in] Un pointeur vers un Win32 `CONTEXT` structure, qui est utilisé pour amorcer le parcours de pile.</span><span class="sxs-lookup"><span data-stu-id="62d8d-113">[in] A pointer to a Win32 `CONTEXT` structure, which is used to seed the stack walk.</span></span> <span data-ttu-id="62d8d-114">Win32 `CONTEXT` structure contient des valeurs des registres du processeur et représente l’état de l’UC à un moment donné dans le temps.</span><span class="sxs-lookup"><span data-stu-id="62d8d-114">The Win32 `CONTEXT` structure contains values of the CPU registers and represents the state of the CPU at a particular moment in time.</span></span>  
  
 <span data-ttu-id="62d8d-115">La valeur de départ aide le CLR à déterminer où commencer le parcours de pile, si le haut de la pile est un code non managé d’assistance ; Sinon, la valeur de départ est ignorée.</span><span class="sxs-lookup"><span data-stu-id="62d8d-115">The seed helps the CLR determine where to begin the stack walk, if the top of the stack is unmanaged helper code; otherwise, the seed is ignored.</span></span> <span data-ttu-id="62d8d-116">Une valeur de départ doit être fournie pour un parcours asynchrone.</span><span class="sxs-lookup"><span data-stu-id="62d8d-116">A seed must be supplied for an asynchronous walk.</span></span> <span data-ttu-id="62d8d-117">Si vous effectuez un parcours synchrone, aucune valeur de départ n’est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="62d8d-117">If you are doing a synchronous walk, no seed is necessary.</span></span>  
  
 <span data-ttu-id="62d8d-118">Le `context` paramètre est valide uniquement si l’indicateur COR_PRF_SNAPSHOT_CONTEXT a été passé dans le `infoFlags` paramètre.</span><span class="sxs-lookup"><span data-stu-id="62d8d-118">The `context` parameter is valid only if the COR_PRF_SNAPSHOT_CONTEXT flag was passed in the `infoFlags` parameter.</span></span>  
  
 `contextSize`  
 <span data-ttu-id="62d8d-119">[in] La taille de la `CONTEXT` structure, ce qui est référencé par le `context` paramètre.</span><span class="sxs-lookup"><span data-stu-id="62d8d-119">[in] The size of the `CONTEXT` structure, which is referenced by the `context` parameter.</span></span>  
  
## <a name="remarks"></a><span data-ttu-id="62d8d-120">Remarques</span><span class="sxs-lookup"><span data-stu-id="62d8d-120">Remarks</span></span>  
 <span data-ttu-id="62d8d-121">Le passage de null pour `thread` produit un instantané du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="62d8d-121">Passing null for `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="62d8d-122">Les instantanés peuvent provenir d’autres threads uniquement si le thread cible est interrompu à la fois.</span><span class="sxs-lookup"><span data-stu-id="62d8d-122">Snapshots can be taken of other threads only if the target thread is suspended at the time.</span></span>  
  
 <span data-ttu-id="62d8d-123">Lorsque le profileur souhaite parcourir la pile, il appelle `DoStackSnapshot`.</span><span class="sxs-lookup"><span data-stu-id="62d8d-123">When the profiler wants to walk the stack, it calls `DoStackSnapshot`.</span></span> <span data-ttu-id="62d8d-124">Avant que le CLR est retournée à partir de cet appel, il appelle votre `StackSnapshotCallback` plusieurs fois, une fois pour chaque frame managé (ou exécution de frames non managés) sur la pile.</span><span class="sxs-lookup"><span data-stu-id="62d8d-124">Before the CLR returns from that call, it calls your `StackSnapshotCallback` several times, once for each managed frame (or run of unmanaged frames) on the stack.</span></span> <span data-ttu-id="62d8d-125">Lorsque des frames non managés sont trouvés, vous devez vous-même les parcourir.</span><span class="sxs-lookup"><span data-stu-id="62d8d-125">When unmanaged frames are encountered, you must walk them yourself.</span></span>  
  
 <span data-ttu-id="62d8d-126">L’ordre dans lequel la pile est parcourue est l’inverse de la façon dont les images ont été placés sur la pile : Terminal (dernier push) en premier lieu, le principal (premier push) image dernier.</span><span class="sxs-lookup"><span data-stu-id="62d8d-126">The order in which the stack is walked is the reverse of how the frames were pushed onto the stack: leaf (last-pushed) frame first, main (first-pushed) frame last.</span></span>  
  
 <span data-ttu-id="62d8d-127">Pour plus d’informations sur la façon de programmer le profileur pour parcourir des piles managées, consultez [parcours de la pile du profileur dans .NET Framework 2.0 : notions de base et d’autres fonctionnalités](http://go.microsoft.com/fwlink/?LinkId=73638).</span><span class="sxs-lookup"><span data-stu-id="62d8d-127">For more information about how to program the profiler to walk managed stacks, see [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](http://go.microsoft.com/fwlink/?LinkId=73638).</span></span>  
  
 <span data-ttu-id="62d8d-128">Un parcours de pile peut être synchrone ou asynchrone, comme expliqué dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="62d8d-128">A stack walk can be synchronous or asynchronous, as explained in the following sections.</span></span>  
  
## <a name="synchronous-stack-walk"></a><span data-ttu-id="62d8d-129">Parcours de pile synchrone</span><span class="sxs-lookup"><span data-stu-id="62d8d-129">Synchronous Stack Walk</span></span>  
 <span data-ttu-id="62d8d-130">Un parcours de pile synchrone implique le parcours de la pile du thread actuel en réponse à un rappel.</span><span class="sxs-lookup"><span data-stu-id="62d8d-130">A synchronous stack walk involves walking the stack of the current thread in response to a callback.</span></span> <span data-ttu-id="62d8d-131">Il ne nécessite pas d’amorçage ou à suspendre.</span><span class="sxs-lookup"><span data-stu-id="62d8d-131">It does not require seeding or suspending.</span></span>  
  
 <span data-ttu-id="62d8d-132">Vous apportez synchrone, appelez en réponse à l’appel d’une de du votre profileur CLR [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) (ou [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)) méthodes, vous appelez `DoStackSnapshot` pour parcourir la pile de la thread en cours.</span><span class="sxs-lookup"><span data-stu-id="62d8d-132">You make a synchronous call when, in response to the CLR calling one of your profiler's [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) (or [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)) methods, you call `DoStackSnapshot` to walk the stack of the current thread.</span></span> <span data-ttu-id="62d8d-133">Cela est utile lorsque vous souhaitez voir à quoi la pile ressemble à une notification comme [ICorProfilerCallback::ObjectAllocated](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method.md).</span><span class="sxs-lookup"><span data-stu-id="62d8d-133">This is useful when you want to see what the stack looks like at a notification such as [ICorProfilerCallback::ObjectAllocated](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method.md).</span></span> <span data-ttu-id="62d8d-134">Vous appelez uniquement `DoStackSnapshot` depuis votre `ICorProfilerCallback` méthode, en passant null dans les `context` et `thread` paramètres.</span><span class="sxs-lookup"><span data-stu-id="62d8d-134">You just call `DoStackSnapshot` from within your `ICorProfilerCallback` method, passing null in the `context` and `thread` parameters.</span></span>  
  
## <a name="asynchronous-stack-walk"></a><span data-ttu-id="62d8d-135">Parcours de pile asynchrone</span><span class="sxs-lookup"><span data-stu-id="62d8d-135">Asynchronous Stack Walk</span></span>  
 <span data-ttu-id="62d8d-136">Un parcours de pile asynchrone implique le parcours de la pile d’un autre thread ou de parcourir la pile du thread actuel, pas en réponse à un rappel, mais par piratage du pointeur d’instruction du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="62d8d-136">An asynchronous stack walk entails walking the stack of a different thread, or walking the stack of the current thread, not in response to a callback, but by hijacking the current thread's instruction pointer.</span></span> <span data-ttu-id="62d8d-137">Un parcours asynchrone requiert une valeur initiale si le haut de la pile est le code non managé qui ne fait pas partie d’une plateforme de code non managé (PInvoke) ou appel COM, mais code d’assistance dans le CLR lui-même.</span><span class="sxs-lookup"><span data-stu-id="62d8d-137">An asynchronous walk requires a seed if the top of the stack is unmanaged code that is not part of a platform invoke (PInvoke) or COM call, but helper code in the CLR itself.</span></span> <span data-ttu-id="62d8d-138">Par exemple, le code qui effectue juste-à-temps (JIT) la compilation ou le garbage collection est code d’assistance.</span><span class="sxs-lookup"><span data-stu-id="62d8d-138">For example, code that does just-in-time (JIT) compiling or garbage collection is helper code.</span></span>  
  
 <span data-ttu-id="62d8d-139">Vous obtenez une valeur de départ en directement en suspendant le thread cible et parcourez sa pile vous-même, jusqu'à ce que vous trouviez le tout premier frame managé.</span><span class="sxs-lookup"><span data-stu-id="62d8d-139">You obtain a seed by directly suspending the target thread and walking its stack yourself, until you find the topmost managed frame.</span></span> <span data-ttu-id="62d8d-140">Une fois que le thread cible est suspendu, obtenir le contexte de Registre actuel du thread cible.</span><span class="sxs-lookup"><span data-stu-id="62d8d-140">After the target thread is suspended, get the target thread's current register context.</span></span> <span data-ttu-id="62d8d-141">Ensuite, déterminez si le contexte de Registre pointe au code non managé en appelant [ICorProfilerInfo::GetFunctionFromIP](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getfunctionfromip-method.md) , si elle retourne un `FunctionID` égale à zéro, le frame est de code non managé.</span><span class="sxs-lookup"><span data-stu-id="62d8d-141">Next, determine whether the register context points to unmanaged code by calling [ICorProfilerInfo::GetFunctionFromIP](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getfunctionfromip-method.md) — if it returns a `FunctionID` equal to zero, the frame is unmanaged code.</span></span> <span data-ttu-id="62d8d-142">Maintenant, parcourez la pile jusqu'à ce que le premier frame managé, puis calculez le contexte de la valeur initiale basé sur le contexte de Registre pour ce frame.</span><span class="sxs-lookup"><span data-stu-id="62d8d-142">Now, walk the stack until you reach the first managed frame, and then calculate the seed context based on the register context for that frame.</span></span>  
  
 <span data-ttu-id="62d8d-143">Appelez `DoStackSnapshot` avec votre contexte de valeur de départ pour commencer le parcours de pile asynchrone.</span><span class="sxs-lookup"><span data-stu-id="62d8d-143">Call `DoStackSnapshot` with your seed context to begin the asynchronous stack walk.</span></span> <span data-ttu-id="62d8d-144">Si vous ne fournissez pas d’une valeur initiale, `DoStackSnapshot` peut ignorer les frames managés en haut de la pile et, par conséquent, vous donne un parcours de pile incomplet.</span><span class="sxs-lookup"><span data-stu-id="62d8d-144">If you do not supply a seed, `DoStackSnapshot` might skip managed frames at the top of the stack and, consequently, will give you an incomplete stack walk.</span></span> <span data-ttu-id="62d8d-145">Si vous fournissez une valeur initiale, elle doit pointer vers la compilation JIT ou Native Image Generator (Ngen.exe)-généré le code ; dans le cas contraire, `DoStackSnapshot` renvoie le code d’échec CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span><span class="sxs-lookup"><span data-stu-id="62d8d-145">If you do supply a seed, it must point to JIT-compiled or Native Image Generator (Ngen.exe)-generated code; otherwise, `DoStackSnapshot` returns the failure code, CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span></span>  
  
 <span data-ttu-id="62d8d-146">Parcours de pile asynchrones peuvent facilement provoquer des blocages ou violations d’accès, sauf si vous suivez ces instructions :</span><span class="sxs-lookup"><span data-stu-id="62d8d-146">Asynchronous stack walks can easily cause deadlocks or access violations, unless you follow these guidelines:</span></span>  
  
-   <span data-ttu-id="62d8d-147">Lorsque vous interrompez directement des threads, n’oubliez pas que seul un thread qui n’a jamais exécuté du code managé peut suspendre un autre thread.</span><span class="sxs-lookup"><span data-stu-id="62d8d-147">When you directly suspend threads, remember that only a thread that has never run managed code can suspend another thread.</span></span>  
  
-   <span data-ttu-id="62d8d-148">Bloquez toujours dans votre [ICorProfilerCallback::ThreadDestroyed](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-threaddestroyed-method.md) rappel jusqu'à ce que le parcours de pile de ce thread est terminé.</span><span class="sxs-lookup"><span data-stu-id="62d8d-148">Always block in your [ICorProfilerCallback::ThreadDestroyed](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-threaddestroyed-method.md) callback until that thread's stack walk is complete.</span></span>  
  
-   <span data-ttu-id="62d8d-149">Ne contiennent pas un verrou pendant que votre profileur appelle une fonction CLR qui peut déclencher une garbage collection.</span><span class="sxs-lookup"><span data-stu-id="62d8d-149">Do not hold a lock while your profiler calls into a CLR function that can trigger a garbage collection.</span></span> <span data-ttu-id="62d8d-150">Autrement dit, ne détiennent pas de verrou si le thread propriétaire peut effectuer un appel qui déclenche un garbage collection.</span><span class="sxs-lookup"><span data-stu-id="62d8d-150">That is, do not hold a lock if the owning thread might make a call that triggers a garbage collection.</span></span>  
  
 <span data-ttu-id="62d8d-151">Il existe également un risque d’interblocage si vous appelez `DoStackSnapshot` à partir d’un thread que votre profileur a créé afin que vous pouvez parcourir la pile d’un thread cible distinct.</span><span class="sxs-lookup"><span data-stu-id="62d8d-151">There is also a risk of deadlock if you call `DoStackSnapshot` from a thread that your profiler has created so that you can walk the stack of a separate target thread.</span></span> <span data-ttu-id="62d8d-152">La première fois que le thread que vous avez créé entre certaines `ICorProfilerInfo*` méthodes (y compris `DoStackSnapshot`), le CLR exécute une initialisation par thread, spécifique au CLR sur ce thread.</span><span class="sxs-lookup"><span data-stu-id="62d8d-152">The first time the thread you created enters certain `ICorProfilerInfo*` methods (including `DoStackSnapshot`), the CLR will perform per-thread, CLR-specific initialization on that thread.</span></span> <span data-ttu-id="62d8d-153">Si votre profileur a interrompu le thread cible dont vous essayez de parcourir la pile, et si ce thread cible est produit qu’il possède un verrou nécessaires pour effectuer cette initialisation par thread, un interblocage se produit.</span><span class="sxs-lookup"><span data-stu-id="62d8d-153">If your profiler has suspended the target thread whose stack you are trying to walk, and if that target thread happened to own a lock necessary for performing this per-thread initialization, a deadlock will occur.</span></span> <span data-ttu-id="62d8d-154">Pour éviter cet interblocage, faites un appel initial à `DoStackSnapshot` depuis votre thread créés par le profileur pour parcourir thread cible distinct, mais n’interrompez pas le thread cible au préalable.</span><span class="sxs-lookup"><span data-stu-id="62d8d-154">To avoid this deadlock, make an initial call into `DoStackSnapshot` from your profiler-created thread to walk a separate target thread, but do not suspend the target thread first.</span></span> <span data-ttu-id="62d8d-155">Cet appel initial garantit que l’initialisation par thread peut s’effectuer sans blocage.</span><span class="sxs-lookup"><span data-stu-id="62d8d-155">This initial call ensures that the per-thread initialization can complete without deadlock.</span></span> <span data-ttu-id="62d8d-156">Si `DoStackSnapshot` réussit et signale au moins une frame, après ce point, il sera sécurisé pour interrompre tout thread cible et l’appel de ce thread créés par le Générateur de profils `DoStackSnapshot` pour parcourir la pile de ce thread cible.</span><span class="sxs-lookup"><span data-stu-id="62d8d-156">If `DoStackSnapshot` succeeds and reports at least one frame, after that point, it will be safe for that profiler-created thread to suspend any target thread and call `DoStackSnapshot` to walk the stack of that target thread.</span></span>  
  
## <a name="requirements"></a><span data-ttu-id="62d8d-157">Spécifications</span><span class="sxs-lookup"><span data-stu-id="62d8d-157">Requirements</span></span>  
 <span data-ttu-id="62d8d-158">**Plateformes :** consultez [requise](../../../../docs/framework/get-started/system-requirements.md).</span><span class="sxs-lookup"><span data-stu-id="62d8d-158">**Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md).</span></span>  
  
 <span data-ttu-id="62d8d-159">**En-tête :** CorProf.idl, CorProf.h</span><span class="sxs-lookup"><span data-stu-id="62d8d-159">**Header:** CorProf.idl, CorProf.h</span></span>  
  
 <span data-ttu-id="62d8d-160">**Bibliothèque :** CorGuids.lib</span><span class="sxs-lookup"><span data-stu-id="62d8d-160">**Library:** CorGuids.lib</span></span>  
  
 <span data-ttu-id="62d8d-161">**Versions du .NET framework :**[!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span><span class="sxs-lookup"><span data-stu-id="62d8d-161">**.NET Framework Versions:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="62d8d-162">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="62d8d-162">See Also</span></span>  
 [<span data-ttu-id="62d8d-163">ICorProfilerInfo (Interface)</span><span class="sxs-lookup"><span data-stu-id="62d8d-163">ICorProfilerInfo Interface</span></span>](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)  
 [<span data-ttu-id="62d8d-164">ICorProfilerInfo2 (Interface)</span><span class="sxs-lookup"><span data-stu-id="62d8d-164">ICorProfilerInfo2 Interface</span></span>](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)
