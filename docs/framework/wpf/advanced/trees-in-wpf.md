---
title: Arborescences dans WPF
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
caps.latest.revision: "20"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 56237bccb2bf61994c6114fa01d15c254267ca20
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/21/2017
---
# <a name="trees-in-wpf"></a>Arborescences dans WPF
Dans de nombreuses technologies, les éléments et les composants sont organisés en une arborescence, où les développeurs manipulent directement les nœuds d’objet dans l’arborescence pour modifier le rendu ou le comportement d’une application. [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] utilise également plusieurs métaphores d’arborescence pour définir des relations entre des éléments du programme. Pour la plupart, les développeurs WPF peuvent créer une application dans le code ou définir des parties de l’application en XAML, en se représentant mentalement la métaphore de l’arborescence des objets, mais en appelant pour cela une API spécifique ou en utilisant un balisage spécifique, au lieu d’utiliser une API générale de manipulation d’une arborescence d’objets, comme ce peut être le cas dans le modèle DOM XML. WPF expose deux classes d’assistance qui fournissent une vue de la métaphore de l’arborescence, <xref:System.Windows.LogicalTreeHelper> et <xref:System.Windows.Media.VisualTreeHelper>. Les termes « arborescence d’éléments visuels » et « arborescence logique » sont également utilisés dans la documentation WPF, car ils sont utiles pour comprendre le comportement de certaines fonctionnalités clés de WPF. Cette rubrique définit ce que l’arborescence d’éléments visuels et l’arborescence logique représentent, explique la relation de ces arborescences avec le concept d’arborescence d’un objet global et présente <xref:System.Windows.LogicalTreeHelper> et <xref:System.Windows.Media.VisualTreeHelper>s.  
  

  
<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a>Arborescences dans WPF  
 L’arborescence la plus complète dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] est l’arborescence d’objets. Si vous définissez une page d’application dans [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] puis que vous chargez le [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], l’arborescence est créée sur la base des relations d’imbrication des éléments dans le balisage. Si vous définissez une application ou une partie de l’application dans le code, l’arborescence est créée en fonction de la façon dont vous affectez les valeurs de propriété pour les propriétés qui implémentent le modèle de contenu d’un objet donné. Dans [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], vous pouvez conceptualiser et signaler l’arborescence à son API publique de deux façons : en tant qu’arborescence logique et en tant qu’arborescence d’éléments visuels. Les distinctions entre arborescence logique et arborescence d’éléments visuels ne sont pas toujours nécessairement importantes, mais elles peuvent parfois générer des problèmes avec certains sous-systèmes [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], et affecter vos choix dans le balisage ou le code.  
  
 Même si vous ne manipuliez pas toujours directement l’arborescence logique ou l’arborescence d’éléments visuels, la compréhension des concepts présidant à l’interaction des arborescences est utile pour comprendre la technologie WPF. Considérer WPF comme une métaphore d’une arborescence d’un certain type est également crucial pour comprendre le fonctionnement de l’héritage des propriétés et du routage des événements dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
> [!NOTE]
>  L’arborescence d’objets étant plus un concept qu’une API réelle, vous pouvez aussi vous représenter ce concept sous la forme d’un graphe d’objets. Dans la pratique, des relations existent entre les objets au moment de l’exécution, où la métaphore de l’arborescence cesse de fonctionner. Néanmoins, en particulier avec l’interface utilisateur définie en XAML, la métaphore de l’arborescence est suffisamment pertinente pour que la plus grande partie de la documentation WPF utilise le terme « arborescence d’objets » pour faire référence à ce concept général.  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a>L’arborescence logique  
 Dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], vous ajoutez du contenu aux éléments d’interface en définissant les propriétés des objets qui représentent ces éléments. Par exemple, vous ajoutez des éléments à un <xref:System.Windows.Controls.ListBox> contrôle en manipulant ses <xref:System.Windows.Controls.ItemsControl.Items%2A> propriété. Ce faisant, vous placez des éléments dans le <xref:System.Windows.Controls.ItemCollection> qui est le <xref:System.Windows.Controls.ItemsControl.Items%2A> valeur de propriété. De même, pour ajouter des objets à un <xref:System.Windows.Controls.DockPanel>, vous manipulez son <xref:System.Windows.Controls.Panel.Children%2A> valeur de propriété. Ici, vous ajoutez des objets à le <xref:System.Windows.Controls.UIElementCollection>. Pour obtenir un exemple de code, consultez [Ajouter dynamiquement un élément](http://msdn.microsoft.com/en-us/d00f258a-7973-4de7-bc54-a3fc1f638419).  
  
 Dans [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], lorsque vous placez des éléments de liste dans un <xref:System.Windows.Controls.ListBox> contrôles ou autres éléments d’interface utilisateur dans un <xref:System.Windows.Controls.DockPanel>, vous utilisez également le <xref:System.Windows.Controls.ItemsControl.Items%2A> et <xref:System.Windows.Controls.Panel.Children%2A> propriétés, explicitement ou implicitement, comme dans l’exemple suivant.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Si vous deviez traiter ce XAML en tant que XML dans un Document Object Model, et si vous aviez inclus les balises placées en commentaire comme étant implicites (ce qui est autorisé), l’arborescence DOM XML obtenue aurait inclus des éléments pour `<ListBox.Items>` et les autres éléments implicites. Mais XAML ne procède pas de cette façon quand vous lisez les balises et que vous écrivez dans les objets : le graphe d’objets obtenu n’inclut tout simplement pas `ListBox.Items`. Il a toutefois un <xref:System.Windows.Controls.ListBox> propriété nommée `Items` qui contient un <xref:System.Windows.Controls.ItemCollection>et qui <xref:System.Windows.Controls.ItemCollection> est initialisée mais vide lorsque le <xref:System.Windows.Controls.ListBox> XAML est traité. Ensuite, chaque élément d’objet enfant qui existe en tant que contenu pour le <xref:System.Windows.Controls.ListBox> est ajouté à la <xref:System.Windows.Controls.ItemCollection> par les appels de l’analyseur à `ItemCollection.Add`. Cet exemple de traitement du code XAML dans une arborescence d’objets semble jusqu’à présent être un exemple où l’arborescence d’objets créée est fondamentalement l’arborescence logique.  
  
 Cependant, l’arborescence logique n’est pas la totalité du graphe d’objets qui existe pour l’interface utilisateur de votre application au moment de l’exécution, même avec les éléments de syntaxe implicite de XAML pris en compte. La raison principale de ceci est liée aux éléments visuels et aux modèles. Par exemple, considérez le <xref:System.Windows.Controls.Button>. L’arborescence logique signale la <xref:System.Windows.Controls.Button> objet et également sa chaîne `Content`. Mais il y a plus que ce bouton dans l’arborescence d’objets à l’exécution. En particulier, le bouton n’apparaît sur l’écran comme il le fait, car un spécifique <xref:System.Windows.Controls.Button> du modèle de contrôle. Les éléments visuels qui proviennent d’un modèle appliqué (tels que définis par le modèle <xref:System.Windows.Controls.Border> de gris foncé autour du bouton visuel) ne sont pas signalés dans l’arborescence logique, même si vous examinez l’arborescence logique pendant l’exécution (telles que la gestion d’un événement d’entrée à partir de la l’interface utilisateur visible et ensuite la lecture de l’arborescence logique). Pour rechercher les éléments visuels du modèle, vous devez au lieu de cela examiner l’arborescence d’éléments visuels.  
  
 Pour plus d’informations sur la façon dont la syntaxe [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] est mappée au graphe d’objets créé et sur la syntaxe implicite en XAML, consultez [Syntaxe XAML en détail](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) ou [Vue d’ensemble de XAML (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a>Objectif de l’arborescence logique  
 L’arborescence logique existe pour que les modèles de contenu puissent facilement itérer sur leurs éventuels objets enfants, et pour que les modèles de contenu puissent être extensibles. De même, l’arborescence logique fournit un framework pour certaines notifications, comme quand tous les objets de l’arborescence logique sont chargés. En fait, l’arborescence logique est une approximation d’un graphe d’objets à l’exécution au niveau du framework, ce qui exclut les éléments visuels, mais convient pour de nombreuses opérations de requêtes sur la composition de votre propre application à l’exécution.  
  
 En outre, les deux références de ressources statiques et dynamiques sont résolues par la recherche vers le haut dans l’arborescence logique pour <xref:System.Windows.FrameworkElement.Resources%2A> collections sur l’objet demandeur initial, puis en continuant à remonter l’arborescence logique et chaque vérification <xref:System.Windows.FrameworkElement> (ou <xref:System.Windows.FrameworkContentElement>) pour une autre `Resources` valeur contenant un <xref:System.Windows.ResourceDictionary>, contenant éventuellement cette clé. L’arborescence logique est utilisée pour la recherche de ressources quand l’arborescence logique et l’arborescence d’éléments visuels sont présentes. Pour plus d’informations sur les dictionnaires et la recherche de ressources, consultez la page [Ressources XAML](../../../../docs/framework/wpf/advanced/xaml-resources.md).  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a>Composition de l’arborescence logique  
 L’arborescence logique est définie au niveau de l’infrastructure WPF, ce qui signifie que l’élément de base WPF est particulièrement importante pour les opérations de l’arborescence logique est soit <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement>. Toutefois, comme vous pouvez voir si vous utilisez en fait le <xref:System.Windows.LogicalTreeHelper> API, l’arborescence logique contient parfois des nœuds qui ne sont ni <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement>. Par exemple, l’arborescence logique signale la <xref:System.Windows.Controls.TextBlock.Text%2A> valeur d’un <xref:System.Windows.Controls.TextBlock>, qui est une chaîne.  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a>Remplacement de l’arborescence logique  
 Les créateurs de contrôles avancés peuvent remplacer l’arborescence logique en remplaçant plusieurs [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] qui définissent la façon dont un objet ou un modèle de contenu général ajoute ou supprime des objets dans l’arborescence logique. Pour obtenir un exemple montrant comment remplacer l’arborescence logique, consultez [Remplacer l’arborescence logique](../../../../docs/framework/wpf/advanced/how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a>Héritage de la valeur de propriété  
 L’héritage des valeurs de propriété fonctionne à travers une arborescence hybride. Les métadonnées qui contient le <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> propriété qui active l’héritage de propriété est de niveau infrastructure WPF <xref:System.Windows.FrameworkPropertyMetadata> classe. Par conséquent, le parent qui contient la valeur d’origine et l’objet enfant qui hérite de cette valeur doivent tous deux être <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement>, et ces deux éléments doivent faire partie d’une arborescence logique. Cependant, pour les propriétés WPF existantes qui prennent en charge l’héritage des propriétés, l’héritage de la valeur des propriétés peut se perpétuer à travers un objet intermédiaire qui ne se trouve pas dans l’arborescence logique. Ceci est principalement approprié pour avoir des éléments de modèle utilisant des valeurs de propriétés héritées définies sur l’instance changée en modèle ou à des niveaux néanmoins plus élevés de la composition de niveau page, et par conséquent plus haut dans l’arborescence logique. Pour que l’héritage des valeurs de propriétés fonctionne de manière cohérente dans cette limite, la propriété qui hérite doit être inscrite comme propriété attachée, et vous devez suivre ce modèle si vous prévoyez de définir une propriété de dépendance personnalisée avec un comportement d’héritage de propriété. L’arborescence exacte utilisée pour l’héritage de propriétés ne peut pas être entièrement anticipée par une méthode d’utilitaire de classe d’assistance, même au moment de l’exécution. Pour plus d’informations, consultez [Héritage de valeur de propriété](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a>L’arborescence d’éléments visuels  
 En plus du concept d’arborescence logique, il existe également le concept d’arborescence d’éléments visuels dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. L’arborescence d’éléments visuels décrit la structure des objets visuels, tel que représenté par la <xref:System.Windows.Media.Visual> classe de base. Quand vous écrivez un modèle pour un contrôle, vous définissez ou vous redéfinissez l’arborescence d’éléments visuels qui s’applique pour ce contrôle. L’arborescence d’éléments visuels est également intéressante pour les développeurs désireux un contrôle de plus bas niveau sur le dessin pour des raisons de performances et d’optimisation. Une exposition de l’arborescence d’éléments visuels dans le cadre d’une programmation conventionnelle [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] est que les routes d’événements pour un événement routé passent principalement le long de l’arborescence d’éléments visuels, et non pas le long de l’arborescence logique. Cette subtilité du comportement des événements routés peut ne pas être immédiatement apparente, sauf si vous êtes un créateur de contrôles. Le routage des événements à travers l’arborescence d’éléments visuel permet aux contrôles qui implémentent la composition au niveau de l’élément visuel de gérer les événements ou de créer des méthodes setter d’événement.  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a>Arborescences, éléments de contenu et hôtes de contenu  
 Éléments de contenu (classes qui dérivent <xref:System.Windows.ContentElement>) ne font pas partie de l’arborescence d’éléments visuels ; ils n’héritent pas de <xref:System.Windows.Media.Visual> et n’ont pas de représentation visuelle. Pour s’afficher dans une interface utilisateur, un <xref:System.Windows.ContentElement> doit être hébergé dans un hôte de contenu à la fois un <xref:System.Windows.Media.Visual> et un participant de l’arborescence logique. En règle générale un tel objet est un <xref:System.Windows.FrameworkElement>. Vous pouvez conceptualiser ce mécanisme de la façon suivante : l’hôte de contenu est comme un « navigateur » pour le contenu et il choisit comment afficher ce contenu dans la zone de l’écran contrôlée par l’hôte. Quand le contenu est hébergé, il peut devenir un participant à certains processus de l’arborescence qui sont normalement associés à l’arborescence d’éléments visuels. En règle générale, les <xref:System.Windows.FrameworkElement> classe d’hôte comprend le code d’implémentation qui ajoute tout hébergé <xref:System.Windows.ContentElement> vers l’itinéraire de l’événement via des sous-nœuds de l’arborescence logique de contenu, même si le contenu hébergé ne fait pas partie de l’arborescence visuelle true. Cela est nécessaire afin qu’un <xref:System.Windows.ContentElement> pouvez source d’un événement routé qui route vers n’importe quel élément autre que lui-même.  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a>Parcours des arborescences  
 Le <xref:System.Windows.LogicalTreeHelper> classe fournit le <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>, et <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> méthodes pour parcourir l’arborescence logique. Dans la plupart des cas, vous n’avez pas à parcourir l’arborescence logique des contrôles existants, car ces contrôles exposent presque toujours leurs éléments enfants logiques comme une propriété de collection dédiée qui prend en charge les accès à la collection, comme `Add`, un indexeur, etc. Parcours d’arborescence est principalement un scénario qui est utilisé par les auteurs de contrôle qui vous choisissent de ne pas dériver à partir de modèles de contrôle prévus, tels que <xref:System.Windows.Controls.ItemsControl> ou <xref:System.Windows.Controls.Panel> lorsque les propriétés de la collection sont déjà définies, et qui veulent fournir leur propre collection prise en charge de la propriété.  
  
 L’arborescence visuelle prend également en charge une classe d’assistance pour le parcours de l’arborescence d’éléments visuels, <xref:System.Windows.Media.VisualTreeHelper>. L’arborescence visuelle n’est pas exposée aussi aisément via des propriétés de contrôle, afin que la <xref:System.Windows.Media.VisualTreeHelper> classe est la méthode recommandée pour parcourir l’arborescence d’éléments visuels si cela est nécessaire pour votre scénario de programmation. Pour plus d’informations, consultez [Vue d’ensemble du rendu graphique WPF](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
>  Il est parfois nécessaire d’examiner l’arborescence d’éléments visuels d’un modèle appliqué. Vous devez être prudent quand vous utilisez cette technique. Même si vous parcourez une arborescence d’éléments visuels d’un contrôle dans lequel vous définissez le modèle, les consommateurs de votre contrôle peuvent toujours modifier le modèle en définissant le <xref:System.Windows.Controls.Control.Template%2A> propriété sur les instances et même l’utilisateur final peut influencer le modèle appliqué en modifiant le thème du système.  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a>Routes pour les événements routés en tant qu’« arborescence »  
 Comme mentionné précédemment, la route de tout événement routé donné suit un chemin unique et prédéterminé d’une arborescence qui est un hybride de représentations de l’arborescence d’éléments visuels et de l’arborescence logique. La route d’événements peut suivre des directions vers le haut ou vers le bas de l’arborescence, selon qu’il s’agit d’une route d’événements de tunneling ou de propagation. Le concept de route d’événements n’a pas de prise en charge directe par une classe d’assistance qui pourrait être utilisée pour parcourir la route d’événements indépendamment du déclenchement d’un événement qui routerait effectivement. Il existe une classe qui représente l’itinéraire, <xref:System.Windows.EventRoute>, mais les méthodes de cette classe sont généralement à un usage interne uniquement.  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a>Dictionnaires et arborescences de ressources  
 La recherche dans le dictionnaire de ressources pour toutes les `Resources` définies dans une page parcourt l’arborescence logique. Les objets qui ne sont pas dans l’arborescence logique peuvent référencer des ressources avec des clés, mais la séquence de recherche des ressources commence à l’endroit où cet objet est connecté à l’arborescence logique. Dans WPF, seuls les nœuds d’arborescence logique peuvent avoir un `Resources` propriété contenant un <xref:System.Windows.ResourceDictionary>, par conséquent, il n’existe aucun avantage en parcourant l’arborescence visuelle, recherchez des ressources indexées à partir d’un <xref:System.Windows.ResourceDictionary>.  
  
 Cependant, la recherche de ressources peut également s’étendre au-delà de l’arborescence logique immédiate. Pour le balisage de l’application, la recherche de ressources peut continuer ensuite dans les dictionnaires de ressources de niveau application, puis dans la prise en charge des thèmes et les valeurs système qui sont référencées en tant que clés ou propriétés statiques. Les thèmes eux-mêmes peuvent également référencer des valeurs système en dehors de l’arborescence logique des thèmes si les références de ressource sont dynamiques. Pour plus d’informations sur les dictionnaires de ressources et la logique de la recherche, consultez [Ressources XAML](../../../../docs/framework/wpf/advanced/xaml-resources.md).  
  
## <a name="see-also"></a>Voir aussi  
 [Vue d’ensemble des entrées](../../../../docs/framework/wpf/advanced/input-overview.md)  
 [Vue d’ensemble du rendu graphique de WPF](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md)  
 [Vue d’ensemble des événements routés](../../../../docs/framework/wpf/advanced/routed-events-overview.md)  
 [Initialisation d’éléments objet ne figurant pas dans une arborescence d’objets](../../../../docs/framework/wpf/advanced/initialization-for-object-elements-not-in-an-object-tree.md)  
 [Architecture de WPF](../../../../docs/framework/wpf/advanced/wpf-architecture.md)
