---
title: "Modèle de thread"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
caps.latest.revision: "33"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: f0badceeb9ce085dc68fce2c59ec6c42877f2622
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/22/2017
---
# <a name="threading-model"></a><span data-ttu-id="3fad0-102">Modèle de thread</span><span class="sxs-lookup"><span data-stu-id="3fad0-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="3fad0-103"> est conçu pour épargner aux développeurs les difficultés d’utilisation des threads.</span><span class="sxs-lookup"><span data-stu-id="3fad0-103"> is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="3fad0-104">Par conséquent, la majorité des [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] n’auront pas les développeurs à écrire une interface qui utilise plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="3fad0-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="3fad0-105">Comme les programmes multithreads sont complexes et difficiles à déboguer, il est préférable de les éviter quand des solutions à thread unique existent.</span><span class="sxs-lookup"><span data-stu-id="3fad0-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>  
  
 <span data-ttu-id="3fad0-106">Aucune question correctement mise en œuvre, toutefois, aucune [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework sera jamais en mesure de fournir une solution monothread pour chaque type de problème.</span><span class="sxs-lookup"><span data-stu-id="3fad0-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="3fad0-107">s’en rapproche, mais il existe toujours des situations où plusieurs threads améliorent [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] performances ou la réactivité des applications.</span><span class="sxs-lookup"><span data-stu-id="3fad0-107"> comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="3fad0-108">Après avoir présenté des informations d’ordre général, ce document explore certaines de ces situations puis se termine par une présentation de certaines informations de bas niveau.</span><span class="sxs-lookup"><span data-stu-id="3fad0-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>  
  

  
> [!NOTE]
>  <span data-ttu-id="3fad0-109">Cette rubrique traite des threads à l’aide de la <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> méthode pour les appels asynchrones.</span><span class="sxs-lookup"><span data-stu-id="3fad0-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="3fad0-110">Vous pouvez également effectuer des appels asynchrones en appelant le <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> (méthode), qui prennent un <xref:System.Action> ou <xref:System.Func%601> en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="3fad0-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="3fad0-111">Le <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> méthode retourne un <xref:System.Windows.Threading.DispatcherOperation> ou <xref:System.Windows.Threading.DispatcherOperation%601>, qui a un <xref:System.Windows.Threading.DispatcherOperation.Task%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="3fad0-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="3fad0-112">Vous pouvez utiliser la `await` mot clé avec l’option le <xref:System.Windows.Threading.DispatcherOperation> ou associé <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="3fad0-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="3fad0-113">Si vous avez besoin d’attente de façon synchrone de la <xref:System.Threading.Tasks.Task> qui est retourné par une <xref:System.Windows.Threading.DispatcherOperation> ou <xref:System.Windows.Threading.DispatcherOperation%601>, appelez le <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> méthode d’extension.</span><span class="sxs-lookup"><span data-stu-id="3fad0-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="3fad0-114">Appel de <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> entraîne un blocage.</span><span class="sxs-lookup"><span data-stu-id="3fad0-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="3fad0-115">Pour plus d’informations sur l’utilisation d’un <xref:System.Threading.Tasks.Task> pour effectuer des opérations asynchrones, consultez le parallélisme des tâches.</span><span class="sxs-lookup"><span data-stu-id="3fad0-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="3fad0-116">Le <xref:System.Windows.Threading.Dispatcher.Invoke%2A> méthode présente également des surcharges qui prennent un <xref:System.Action> ou <xref:System.Func%601> en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="3fad0-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="3fad0-117">Vous pouvez utiliser la <xref:System.Windows.Threading.Dispatcher.Invoke%2A> des appels de méthode pour rendre synchrones en passant un délégué, <xref:System.Action> ou <xref:System.Func%601>.</span><span class="sxs-lookup"><span data-stu-id="3fad0-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>  
  
<a name="threading_overview"></a>   
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="3fad0-118">Vue d’ensemble du répartiteur</span><span class="sxs-lookup"><span data-stu-id="3fad0-118">Overview and the Dispatcher</span></span>  
 <span data-ttu-id="3fad0-119">En règle générale, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications démarrent avec deux threads : un pour gérer le rendu et un autre pour gérer les [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="3fad0-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="3fad0-120">Le thread de rendu s’exécute efficacement masqué en arrière-plan lors de la [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread reçoit l’entrée, gère les événements, peint l’écran et exécute le code d’application.</span><span class="sxs-lookup"><span data-stu-id="3fad0-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="3fad0-121">La plupart des applications utilisent une seule [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, bien que dans certaines situations, il est préférable d’utiliser plusieurs.</span><span class="sxs-lookup"><span data-stu-id="3fad0-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="3fad0-122">Nous traitons de cet aspect plus loin avec un exemple.</span><span class="sxs-lookup"><span data-stu-id="3fad0-122">We’ll discuss this with an example later.</span></span>  
  
 <span data-ttu-id="3fad0-123">Le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] files d’attente du thread de travail des éléments à l’intérieur d’un objet appelé un <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="3fad0-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="3fad0-124">Le <xref:System.Windows.Threading.Dispatcher> sélectionne des éléments de travail en fonction de l'ordre de priorité et exécute chacun d'eux jusqu'à leur achèvement.</span><span class="sxs-lookup"><span data-stu-id="3fad0-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="3fad0-125">Chaque [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread doit avoir au moins un <xref:System.Windows.Threading.Dispatcher>et chaque <xref:System.Windows.Threading.Dispatcher> peut exécuter les éléments de travail dans un seul thread.</span><span class="sxs-lookup"><span data-stu-id="3fad0-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>  
  
 <span data-ttu-id="3fad0-126">L’astuce pour générer des applications conviviales et réactives est d’optimiser la <xref:System.Windows.Threading.Dispatcher> débit en conservant les éléments de travail petit.</span><span class="sxs-lookup"><span data-stu-id="3fad0-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="3fad0-127">Cette façon dont les éléments jamais périmés dans la <xref:System.Windows.Threading.Dispatcher> file d’attente de traitement.</span><span class="sxs-lookup"><span data-stu-id="3fad0-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="3fad0-128">Tout délai perceptible entre une entrée et sa réponse peut frustrer un utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3fad0-128">Any perceivable delay between input and response can frustrate a user.</span></span>  
  
 <span data-ttu-id="3fad0-129">Comment sont [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposées pour gérer les opérations volumineuses ?</span><span class="sxs-lookup"><span data-stu-id="3fad0-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="3fad0-130">Que se passe-t-il si votre code implique un grand calcul ou doit interroger une base de données sur un serveur distant ?</span><span class="sxs-lookup"><span data-stu-id="3fad0-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="3fad0-131">En règle générale, la réponse est pour gérer l’opération volumineuse dans un thread séparé, en laissant le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread libre pour gérer les éléments dans le <xref:System.Windows.Threading.Dispatcher> file d’attente.</span><span class="sxs-lookup"><span data-stu-id="3fad0-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="3fad0-132">Lorsque l’opération volumineuse est terminée, il peut indiquer son résultat à le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread pour l’affichage.</span><span class="sxs-lookup"><span data-stu-id="3fad0-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>  
  
 <span data-ttu-id="3fad0-133">Historiquement, [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] permet [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] éléments accessibles uniquement par le thread qui les a créés.</span><span class="sxs-lookup"><span data-stu-id="3fad0-133">Historically, [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="3fad0-134">Cela signifie qu’un thread d’arrière-plan chargé des tâches d’exécution longue ne peut pas mettre à jour une zone de texte quand il est terminé.</span><span class="sxs-lookup"><span data-stu-id="3fad0-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="3fad0-135">Pour cela, pour garantir l’intégrité de [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] composants.</span><span class="sxs-lookup"><span data-stu-id="3fad0-135"> does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="3fad0-136">Une zone de liste pourrait sembler étrange si son contenu était mis à jour par un thread d’arrière-plan pendant la phase de dessin.</span><span class="sxs-lookup"><span data-stu-id="3fad0-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="3fad0-137"> a un mécanisme d’exclusion mutuelle intégré qui applique cette coordination.</span><span class="sxs-lookup"><span data-stu-id="3fad0-137"> has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="3fad0-138">La plupart des classes dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dérivent <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="3fad0-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="3fad0-139">Lors de la construction, un <xref:System.Windows.Threading.DispatcherObject> stocke une référence à la <xref:System.Windows.Threading.Dispatcher> lié au thread en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="3fad0-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="3fad0-140">En effet, le <xref:System.Windows.Threading.DispatcherObject> associe au thread qui le crée.</span><span class="sxs-lookup"><span data-stu-id="3fad0-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="3fad0-141">Pendant l’exécution du programme, un <xref:System.Windows.Threading.DispatcherObject> peut appeler son public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3fad0-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="3fad0-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>examine la <xref:System.Windows.Threading.Dispatcher> associé au thread actuel et le compare à la <xref:System.Windows.Threading.Dispatcher> stockée pendant la construction de référence.</span><span class="sxs-lookup"><span data-stu-id="3fad0-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="3fad0-143">Si elles ne correspondent pas, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> lève une exception.</span><span class="sxs-lookup"><span data-stu-id="3fad0-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="3fad0-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>est destiné à être appelé au début de chaque méthode qui appartient à un <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="3fad0-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>  
  
 <span data-ttu-id="3fad0-145">Si seul un thread peut modifier le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], comment interagir les threads d’arrière-plan avec l’utilisateur ?</span><span class="sxs-lookup"><span data-stu-id="3fad0-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="3fad0-146">Un thread d’arrière-plan peut demander le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread pour effectuer une opération sur son nom.</span><span class="sxs-lookup"><span data-stu-id="3fad0-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="3fad0-147">Pour ce faire, il enregistre un élément de travail avec le <xref:System.Windows.Threading.Dispatcher> de la [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="3fad0-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="3fad0-148">Le <xref:System.Windows.Threading.Dispatcher> classe fournit deux méthodes d’enregistrement des éléments de travail : <xref:System.Windows.Threading.Dispatcher.Invoke%2A> et <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="3fad0-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="3fad0-149">Ces deux méthodes planifient un délégué pour l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3fad0-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="3fad0-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>est un appel synchrone, autrement dit, il ne retourne pas jusqu'à ce que le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread réellement termine l’exécution du délégué.</span><span class="sxs-lookup"><span data-stu-id="3fad0-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="3fad0-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>est asynchrone et retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="3fad0-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>  
  
 <span data-ttu-id="3fad0-152">Le <xref:System.Windows.Threading.Dispatcher> trie les éléments dans sa file d’attente par priorité.</span><span class="sxs-lookup"><span data-stu-id="3fad0-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="3fad0-153">Il existe dix niveaux qui peuvent être spécifiées lors de l’ajout d’un élément à la <xref:System.Windows.Threading.Dispatcher> file d’attente.</span><span class="sxs-lookup"><span data-stu-id="3fad0-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="3fad0-154">Ces priorités sont maintenues dans le <xref:System.Windows.Threading.DispatcherPriority> énumération.</span><span class="sxs-lookup"><span data-stu-id="3fad0-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="3fad0-155">Informations détaillées sur <xref:System.Windows.Threading.DispatcherPriority> niveaux se trouvent dans le [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] documentation.</span><span class="sxs-lookup"><span data-stu-id="3fad0-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] documentation.</span></span>  
  
<a name="samples"></a>   
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="3fad0-156">Threads en action : les exemples</span><span class="sxs-lookup"><span data-stu-id="3fad0-156">Threads in Action: The Samples</span></span>  
  
<a name="prime_number"></a>   
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="3fad0-157">Une application à thread unique avec un calcul de longue durée</span><span class="sxs-lookup"><span data-stu-id="3fad0-157">A Single-Threaded Application with a Long-Running Calculation</span></span>  
 <span data-ttu-id="3fad0-158">La plupart des [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] passent à une grande partie de leur temps inactif en attendant des événements qui sont générés en réponse aux interactions de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3fad0-158">Most [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="3fad0-159">Programmation prudence cette durée d’inactivité peut être utilisée de manière constructive, sans affecter la réactivité de le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="3fad0-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="3fad0-160">Le [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] modèle de thread n’autorise pas l’entrée d’interrompre une opération qui se passe dans le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="3fad0-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="3fad0-161">Cela signifie que vous devez être sûr de revenir à la <xref:System.Windows.Threading.Dispatcher> régulièrement au processus en attente d’événements d’entrée avant de pouvoir obsolètes.</span><span class="sxs-lookup"><span data-stu-id="3fad0-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>  
  
 <span data-ttu-id="3fad0-162">Prenons l'exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="3fad0-162">Consider the following example:</span></span>  
  
 <span data-ttu-id="3fad0-163">![Capture d’écran : nombres premiers](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG "ThreadingPrimeNumberScreenShot")</span><span class="sxs-lookup"><span data-stu-id="3fad0-163">![Prime numbers screen shot](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG "ThreadingPrimeNumberScreenShot")</span></span>  
  
 <span data-ttu-id="3fad0-164">Cette application simple compte à partir de trois de façon croissante, en recherchant les nombres premiers.</span><span class="sxs-lookup"><span data-stu-id="3fad0-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="3fad0-165">Lorsque l’utilisateur clique sur le **Démarrer** bouton, la recherche commence.</span><span class="sxs-lookup"><span data-stu-id="3fad0-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="3fad0-166">Quand le programme trouve un nombre premier, il met à jour l’interface utilisateur avec sa découverte.</span><span class="sxs-lookup"><span data-stu-id="3fad0-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="3fad0-167">À tout moment, l’utilisateur peut arrêter la recherche.</span><span class="sxs-lookup"><span data-stu-id="3fad0-167">At any point, the user can stop the search.</span></span>  
  
 <span data-ttu-id="3fad0-168">Bien qu’assez simple, la recherche des nombres premiers peut être illimitée dans le temps, ce qui présente quelques difficultés.</span><span class="sxs-lookup"><span data-stu-id="3fad0-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="3fad0-169">Si nous avions géré l’intégralité de la recherche à l’intérieur du Gestionnaire d’événements click du bouton, nous n’aurions jamais le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] une chance de traiter d’autres événements de thread.</span><span class="sxs-lookup"><span data-stu-id="3fad0-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="3fad0-170">Le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] ne pourra pas répondre à l’entrée ou de traiter les messages.</span><span class="sxs-lookup"><span data-stu-id="3fad0-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="3fad0-171">Elle ne redessinerait jamais l’interface et ne répondrait jamais aux clics sur le bouton.</span><span class="sxs-lookup"><span data-stu-id="3fad0-171">It would never repaint and never respond to button clicks.</span></span>  
  
 <span data-ttu-id="3fad0-172">Nous aurions pu effectuer la recherche des nombres premiers dans un thread distinct, mais nous devrions alors faire face à des problèmes de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="3fad0-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="3fad0-173">Avec une approche à thread unique, nous pouvons directement mettre à jour le libellé qui indique le plus grand nombre premier trouvé.</span><span class="sxs-lookup"><span data-stu-id="3fad0-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>  
  
 <span data-ttu-id="3fad0-174">Si nous arrêter la tâche de calcul en segments maniables, nous pouvons périodiquement retourner à la <xref:System.Windows.Threading.Dispatcher> et traiter les événements.</span><span class="sxs-lookup"><span data-stu-id="3fad0-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="3fad0-175">Nous pouvons [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] une opportunité pour redessiner et traiter l’entrée.</span><span class="sxs-lookup"><span data-stu-id="3fad0-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>  
  
 <span data-ttu-id="3fad0-176">La meilleure façon de fractionner le traitement entre calcul et la gestion des événements consiste à gérer le calcul à partir de la <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="3fad0-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="3fad0-177">À l’aide de la <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (méthode), nous pouvons planifier des vérifications de nombres premiers dans la même file d’attente qui [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] proviennent des événements.</span><span class="sxs-lookup"><span data-stu-id="3fad0-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="3fad0-178">Dans notre exemple, nous planifions une seule vérification de nombre premier à la fois.</span><span class="sxs-lookup"><span data-stu-id="3fad0-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="3fad0-179">Une fois la vérification de nombre premier terminée, nous planifions immédiatement la vérification suivante.</span><span class="sxs-lookup"><span data-stu-id="3fad0-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="3fad0-180">Cette vérification se déroule uniquement après avoir en attente [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] événements ont été traités.</span><span class="sxs-lookup"><span data-stu-id="3fad0-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>  
  
 <span data-ttu-id="3fad0-181">![Illustration de la file d’attente du répartiteur](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG "ThreadingDispatcherQueue")</span><span class="sxs-lookup"><span data-stu-id="3fad0-181">![Dispatcher queue illustration](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG "ThreadingDispatcherQueue")</span></span>  
  
 [!INCLUDE[TLA#tla_word](../../../../includes/tlasharptla-word-md.md)]<span data-ttu-id="3fad0-182"> effectue la vérification orthographique à l’aide de ce mécanisme.</span><span class="sxs-lookup"><span data-stu-id="3fad0-182"> accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="3fad0-183">La correction orthographique est effectuée en arrière-plan à l’aide de la durée d’inactivité de le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="3fad0-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="3fad0-184">Regardons ce code.</span><span class="sxs-lookup"><span data-stu-id="3fad0-184">Let's take a look at the code.</span></span>  
  
 <span data-ttu-id="3fad0-185">L’exemple suivant montre le code XAML qui crée l’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3fad0-185">The following example shows the XAML that creates the user interface.</span></span>  
  
 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]  
  
 <span data-ttu-id="3fad0-186">L’exemple suivant montre le code-behind.</span><span class="sxs-lookup"><span data-stu-id="3fad0-186">The following example shows the code-behind.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]  
  
 <span data-ttu-id="3fad0-187">L’exemple suivant montre le Gestionnaire d’événements pour le <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="3fad0-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]  
  
 <span data-ttu-id="3fad0-188">Outre la mise à jour le texte sur le <xref:System.Windows.Controls.Button>, ce gestionnaire est chargé de planifier le premier nombre premier en ajoutant un délégué pour la <xref:System.Windows.Threading.Dispatcher> file d’attente.</span><span class="sxs-lookup"><span data-stu-id="3fad0-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="3fad0-189">Après que ce gestionnaire d’événements a terminé son travail, le <xref:System.Windows.Threading.Dispatcher> sélectionne ce délégué pour l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3fad0-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>  
  
 <span data-ttu-id="3fad0-190">Comme mentionné précédemment, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> est la <xref:System.Windows.Threading.Dispatcher> membre utilisé pour planifier un délégué pour l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3fad0-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="3fad0-191">Dans ce cas, nous choisissons le <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priorité.</span><span class="sxs-lookup"><span data-stu-id="3fad0-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="3fad0-192">Le <xref:System.Windows.Threading.Dispatcher> exécutera ce délégué uniquement lorsqu’il n’y a aucuns événements importants à traiter.</span><span class="sxs-lookup"><span data-stu-id="3fad0-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> <span data-ttu-id="3fad0-193">La réactivité de l’[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] est plus importante que la vérification des nombres.</span><span class="sxs-lookup"><span data-stu-id="3fad0-193">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] responsiveness is more important than number checking.</span></span> <span data-ttu-id="3fad0-194">Nous passons également un nouveau délégué qui représente la routine de vérification des nombres.</span><span class="sxs-lookup"><span data-stu-id="3fad0-194">We also pass a new delegate representing the number-checking routine.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]  
  
 <span data-ttu-id="3fad0-195">Cette méthode vérifie si le nombre impair suivant est un nombre premier.</span><span class="sxs-lookup"><span data-stu-id="3fad0-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="3fad0-196">Si c’est le principal, la méthode met à jour directement le `bigPrime` <xref:System.Windows.Controls.TextBlock> pour refléter sa découverte.</span><span class="sxs-lookup"><span data-stu-id="3fad0-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="3fad0-197">Nous pouvons procéder ainsi, car le calcul est effectué dans le même thread que celui utilisé pour créer le composant.</span><span class="sxs-lookup"><span data-stu-id="3fad0-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="3fad0-198">Si nous avions choisi d’utiliser un thread séparé pour le calcul, nous aurait utiliser un mécanisme de synchronisation plus compliqué et exécuter la mise à jour dans le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="3fad0-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="3fad0-199">Nous montrerons cette situation plus loin.</span><span class="sxs-lookup"><span data-stu-id="3fad0-199">We’ll demonstrate this situation next.</span></span>  
  
 <span data-ttu-id="3fad0-200">Pour le code source complet de cet exemple, consultez la [Single-Threaded Application avec l’exemple de calcul de longue](http://go.microsoft.com/fwlink/?LinkID=160038)</span><span class="sxs-lookup"><span data-stu-id="3fad0-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038)</span></span>  
  
<a name="weather_sim"></a>   
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="3fad0-201">Gestion d’une opération bloquante avec un thread d’arrière-plan</span><span class="sxs-lookup"><span data-stu-id="3fad0-201">Handling a Blocking Operation with a Background Thread</span></span>  
 <span data-ttu-id="3fad0-202">La gestion des opérations bloquantes dans une application graphique peuvent être difficile.</span><span class="sxs-lookup"><span data-stu-id="3fad0-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="3fad0-203">Nous ne voulons pas appeler des méthodes bloquantes à partir de gestionnaires d’événements, car l’application apparaîtra figée.</span><span class="sxs-lookup"><span data-stu-id="3fad0-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="3fad0-204">Nous pouvons utiliser un thread séparé pour gérer ces opérations, mais lorsque nous avons terminé, nous devons effectuer une synchronisation avec la [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, car nous ne pouvons pas modifier directement le [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] de notre thread de travail.</span><span class="sxs-lookup"><span data-stu-id="3fad0-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] from our worker thread.</span></span> <span data-ttu-id="3fad0-205">Nous pouvons utiliser <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ou <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> pour insérer des délégués dans le <xref:System.Windows.Threading.Dispatcher> de la [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="3fad0-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="3fad0-206">Finalement, ces délégués seront exécutés avec l’autorisation Modifier [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] éléments.</span><span class="sxs-lookup"><span data-stu-id="3fad0-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>  
  
 <span data-ttu-id="3fad0-207">Dans cet exemple, nous simulons un appel de procédure distante qui récupère une prévision météorologique.</span><span class="sxs-lookup"><span data-stu-id="3fad0-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="3fad0-208">Nous utilisons un thread de travail distinct pour exécuter cet appel, et nous planifions une méthode de mise à jour dans le <xref:System.Windows.Threading.Dispatcher> de la [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread lorsque nous avons fini.</span><span class="sxs-lookup"><span data-stu-id="3fad0-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>  
  
 <span data-ttu-id="3fad0-209">![Capture d’écran de l’interface utilisateur de la météo](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG "ThreadingWeatherUIScreenShot")</span><span class="sxs-lookup"><span data-stu-id="3fad0-209">![Weather UI screen shot](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG "ThreadingWeatherUIScreenShot")</span></span>  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]  
  
 <span data-ttu-id="3fad0-210">Voici quelques-uns des détails à noter.</span><span class="sxs-lookup"><span data-stu-id="3fad0-210">The following are some of the details to be noted.</span></span>  
  
-   <span data-ttu-id="3fad0-211">Création du gestionnaire de bouton</span><span class="sxs-lookup"><span data-stu-id="3fad0-211">Creating the Button Handler</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]  
  
 <span data-ttu-id="3fad0-212">Quand l’utilisateur clique sur le bouton, nous affichons le dessin de l’horloge et nous commençons son animation.</span><span class="sxs-lookup"><span data-stu-id="3fad0-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="3fad0-213">Nous désactivons le bouton.</span><span class="sxs-lookup"><span data-stu-id="3fad0-213">We disable the button.</span></span> <span data-ttu-id="3fad0-214">Nous appeler le `FetchWeatherFromServer` méthode dans un nouveau thread, puis nous retour, ce qui permet la <xref:System.Windows.Threading.Dispatcher> pour traiter les événements pendant que nous attendons pour collecter les prévisions météorologiques.</span><span class="sxs-lookup"><span data-stu-id="3fad0-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>  
  
-   <span data-ttu-id="3fad0-215">Récupération de la météo</span><span class="sxs-lookup"><span data-stu-id="3fad0-215">Fetching the Weather</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]  
  
 <span data-ttu-id="3fad0-216">Pour simplifier les choses, nous n’ajoutons pas de code pour la mise en réseau dans cet exemple.</span><span class="sxs-lookup"><span data-stu-id="3fad0-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="3fad0-217">Au lieu de cela, nous simulons le délai d’accès réseau en plaçant notre nouveau thread en veille pendant quatre secondes.</span><span class="sxs-lookup"><span data-stu-id="3fad0-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="3fad0-218">Pendant ce temps, la version d’origine [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread est toujours en cours d’exécution et répondre aux événements.</span><span class="sxs-lookup"><span data-stu-id="3fad0-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="3fad0-219">Pour illustrer ceci, nous avons laissé une animation en cours d’exécution, et les boutons pour réduire et pour agrandir continuent également de fonctionner.</span><span class="sxs-lookup"><span data-stu-id="3fad0-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>  
  
 <span data-ttu-id="3fad0-220">Lorsque le délai est terminé et que nous avons aléatoirement sélectionné nos prévisions météorologiques, il est temps de rapport à la [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="3fad0-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="3fad0-221">Pour ce faire, nous planifions un appel à `UpdateUserInterface` dans les [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread à l’aide de ce thread <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="3fad0-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="3fad0-222">Nous passons une chaîne décrivant la météo à cet appel de méthode planifié.</span><span class="sxs-lookup"><span data-stu-id="3fad0-222">We pass a string describing the weather to this scheduled method call.</span></span>  
  
-   <span data-ttu-id="3fad0-223">Mise à jour le[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="3fad0-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]  
  
 <span data-ttu-id="3fad0-224">Lorsque le <xref:System.Windows.Threading.Dispatcher> dans les [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread ait le temps, il exécute l’appel planifié pour `UpdateUserInterface`.</span><span class="sxs-lookup"><span data-stu-id="3fad0-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="3fad0-225">Cette méthode arrête l’animation de l’horloge et choisit une image pour décrire le temps.</span><span class="sxs-lookup"><span data-stu-id="3fad0-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="3fad0-226">Il affiche cette image et restaure le bouton de récupération des prévisions météo (« fetch forecast »).</span><span class="sxs-lookup"><span data-stu-id="3fad0-226">It displays this image and restores the "fetch forecast" button.</span></span>  
  
<a name="multi_browser"></a>   
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="3fad0-227">Plusieurs fenêtres, plusieurs threads</span><span class="sxs-lookup"><span data-stu-id="3fad0-227">Multiple Windows, Multiple Threads</span></span>  
 <span data-ttu-id="3fad0-228">Certains [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications requièrent plusieurs fenêtres de niveau supérieur.</span><span class="sxs-lookup"><span data-stu-id="3fad0-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="3fad0-229">Il est parfaitement acceptable pour un seul Thread /<xref:System.Windows.Threading.Dispatcher> combinaison de gérer plusieurs fenêtres, mais plusieurs threads parfois préférables.</span><span class="sxs-lookup"><span data-stu-id="3fad0-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="3fad0-230">Ceci est particulièrement vrai s’il y a un risque que l’une des fenêtres monopolise le thread.</span><span class="sxs-lookup"><span data-stu-id="3fad0-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>  
  
 <span data-ttu-id="3fad0-231">L’Explorateur [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] fonctionne de cette manière.</span><span class="sxs-lookup"><span data-stu-id="3fad0-231">[!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] Explorer works in this fashion.</span></span> <span data-ttu-id="3fad0-232">Chaque nouvelle fenêtre de l’Explorateur appartient au processus d’origine, mais elle est créée sous le contrôle d’un thread indépendant.</span><span class="sxs-lookup"><span data-stu-id="3fad0-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>  
  
 <span data-ttu-id="3fad0-233">En utilisant un [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Controls.Frame> (contrôle), nous pouvons afficher des pages Web.</span><span class="sxs-lookup"><span data-stu-id="3fad0-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="3fad0-234">Nous pouvons facilement créer un simple [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] remplacer.</span><span class="sxs-lookup"><span data-stu-id="3fad0-234">We can easily create a simple [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] substitute.</span></span> <span data-ttu-id="3fad0-235">Nous commençons par une fonctionnalité importante : la possibilité d’ouvrir une nouvelle fenêtre d’explorateur.</span><span class="sxs-lookup"><span data-stu-id="3fad0-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="3fad0-236">Quand l’utilisateur clique sur le bouton « new window » (nouvelle fenêtre), nous lançons une copie de notre fenêtre dans un thread distinct.</span><span class="sxs-lookup"><span data-stu-id="3fad0-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="3fad0-237">De cette façon, les opérations longues ou bloquantes dans une des fenêtres ne verrouillent pas toutes les autres fenêtres.</span><span class="sxs-lookup"><span data-stu-id="3fad0-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>  
  
 <span data-ttu-id="3fad0-238">En réalité, le modèle de navigateur web a son propre modèle de thread complexe.</span><span class="sxs-lookup"><span data-stu-id="3fad0-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="3fad0-239">Nous l’avons choisi, car la plupart des lecteurs le connaissent probablement bien.</span><span class="sxs-lookup"><span data-stu-id="3fad0-239">We’ve chosen it because it should be familiar to most readers.</span></span>  
  
 <span data-ttu-id="3fad0-240">L’exemple suivant montre le code.</span><span class="sxs-lookup"><span data-stu-id="3fad0-240">The following example shows the code.</span></span>  
  
 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]  
  
 <span data-ttu-id="3fad0-241">Les segments suivants relatifs à la mise en œuvre des threads dans ce code sont les plus intéressants pour nous dans ce contexte :</span><span class="sxs-lookup"><span data-stu-id="3fad0-241">The following threading segments of this code are the most interesting to us in this context:</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]  
  
 <span data-ttu-id="3fad0-242">Cette méthode est appelée quand l’utilisateur clique sur le bouton « new window ».</span><span class="sxs-lookup"><span data-stu-id="3fad0-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="3fad0-243">Elle crée un nouveau thread et le démarre de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="3fad0-243">It creates a new thread and starts it asynchronously.</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]  
  
 <span data-ttu-id="3fad0-244">Cette méthode est le point de départ pour le nouveau thread.</span><span class="sxs-lookup"><span data-stu-id="3fad0-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="3fad0-245">Nous créons une nouvelle fenêtre sous le contrôle de ce thread.</span><span class="sxs-lookup"><span data-stu-id="3fad0-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="3fad0-246">crée automatiquement une nouvelle <xref:System.Windows.Threading.Dispatcher> pour gérer le nouveau thread.</span><span class="sxs-lookup"><span data-stu-id="3fad0-246"> automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="3fad0-247">Il nous suffit pour rendre la fenêtre fonctionnelle consiste à démarrer le <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="3fad0-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>  
  
<a name="stumbling_points"></a>   
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="3fad0-248">Détails techniques et difficultés</span><span class="sxs-lookup"><span data-stu-id="3fad0-248">Technical Details and Stumbling Points</span></span>  
  
### <a name="writing-components-using-threading"></a><span data-ttu-id="3fad0-249">Écriture de composants avec des threads</span><span class="sxs-lookup"><span data-stu-id="3fad0-249">Writing Components Using Threading</span></span>  
 <span data-ttu-id="3fad0-250">Le [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] Guide du développeur décrit un modèle expliquant comment un composant peut exposer un comportement asynchrone à ses clients (voir [Event-based Asynchronous Pattern Overview](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="3fad0-250">The [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="3fad0-251">Par exemple, supposons que nous voulions empaqueter le `FetchWeatherFromServer` méthode dans un composant réutilisable non graphique.</span><span class="sxs-lookup"><span data-stu-id="3fad0-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="3fad0-252">La norme [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] modèle, il se présente comme suit.</span><span class="sxs-lookup"><span data-stu-id="3fad0-252">Following the standard [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] pattern, this would look something like the following.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]  
  
 <span data-ttu-id="3fad0-253">`GetWeatherAsync` utiliserait une des techniques décrites précédemment, comme la création d’un thread d’arrière-plan, pour faire le travail de façon asynchrone, sans bloquer le thread appelant.</span><span class="sxs-lookup"><span data-stu-id="3fad0-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>  
  
 <span data-ttu-id="3fad0-254">Une des parties plus importantes de ce modèle appelle la *MethodName* `Completed` méthode sur le même thread que celui qui a appelé le *MethodName* `Async` méthode doit commencer.</span><span class="sxs-lookup"><span data-stu-id="3fad0-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="3fad0-255">Vous pouvez effectuer ceci à l’aide de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] assez facilement, en stockant <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>, mais ensuite le composant non graphique peut uniquement être utilisé dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, pas dans [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] ou [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programmes.</span><span class="sxs-lookup"><span data-stu-id="3fad0-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programs.</span></span>  
  
 <span data-ttu-id="3fad0-256">Le <xref:System.Windows.Threading.DispatcherSynchronizationContext> classe répond à ce besoin, considérez-le comme une version simplifiée de <xref:System.Windows.Threading.Dispatcher> qui fonctionne avec d’autres [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks.</span><span class="sxs-lookup"><span data-stu-id="3fad0-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]  
  
### <a name="nested-pumping"></a><span data-ttu-id="3fad0-257">Pompage imbriqué</span><span class="sxs-lookup"><span data-stu-id="3fad0-257">Nested Pumping</span></span>  
 <span data-ttu-id="3fad0-258">Parfois, il n’est pas complètement verrouiller le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="3fad0-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="3fad0-259">Prenons l’exemple du <xref:System.Windows.MessageBox.Show%2A> méthode de la <xref:System.Windows.MessageBox> classe.</span><span class="sxs-lookup"><span data-stu-id="3fad0-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="3fad0-260"><xref:System.Windows.MessageBox.Show%2A>ne retourne pas jusqu'à ce que l’utilisateur clique sur le bouton OK.</span><span class="sxs-lookup"><span data-stu-id="3fad0-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="3fad0-261">Il peut cependant créer une fenêtre qui doit avoir une boucle de messages pour être interactive.</span><span class="sxs-lookup"><span data-stu-id="3fad0-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="3fad0-262">Pendant que nous attendons que l’utilisateur clique sur OK, la fenêtre d’application d’origine ne répond pas aux entrées utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3fad0-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="3fad0-263">Elle continue cependant de traiter les messages concernant le dessin.</span><span class="sxs-lookup"><span data-stu-id="3fad0-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="3fad0-264">La fenêtre d’origine se redessine elle-même quand elle est couverte et découverte.</span><span class="sxs-lookup"><span data-stu-id="3fad0-264">The original window redraws itself when covered and revealed.</span></span>  
  
 <span data-ttu-id="3fad0-265">![MessageBox avec un bouton « OK »](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png "ThreadingNestedPumping")</span><span class="sxs-lookup"><span data-stu-id="3fad0-265">![MessageBox with an "OK" button](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png "ThreadingNestedPumping")</span></span>  
  
 <span data-ttu-id="3fad0-266">Un thread doit être chargé de la fenêtre de la boîte de message.</span><span class="sxs-lookup"><span data-stu-id="3fad0-266">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="3fad0-267"> pourrait créer un thread seulement pour la fenêtre de la boîte de message, mais ce thread ne pourrait pas dessiner les éléments désactivés dans la fenêtre d’origine (rappelez-vous de ce qui a été indiqué plus haut sur l’exclusion mutuelle).</span><span class="sxs-lookup"><span data-stu-id="3fad0-267"> could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="3fad0-268">Au lieu de cela, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] utilise un système de traitement de message imbriqué.</span><span class="sxs-lookup"><span data-stu-id="3fad0-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="3fad0-269">Le <xref:System.Windows.Threading.Dispatcher> classe inclut une méthode spéciale appelée <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, qui stocke les point d’exécution actuel d’une application, puis commence à une nouvelle boucle de message.</span><span class="sxs-lookup"><span data-stu-id="3fad0-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="3fad0-270">Lorsque la boucle de messages imbriquée se termine, l’exécution reprend après l’original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> appeler.</span><span class="sxs-lookup"><span data-stu-id="3fad0-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>  
  
 <span data-ttu-id="3fad0-271">Dans ce cas, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintient le contexte du programme dans un appel à <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, et il commence une nouvelle boucle de message pour repeindre la fenêtre d’arrière-plan et gérer l’entrée dans la fenêtre de message.</span><span class="sxs-lookup"><span data-stu-id="3fad0-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="3fad0-272">Lorsque l’utilisateur clique sur OK et efface la fenêtre indépendante, la boucle imbriquée s’arrête et le contrôle reprend après l’appel à <xref:System.Windows.MessageBox.Show%2A>.</span><span class="sxs-lookup"><span data-stu-id="3fad0-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>  
  
### <a name="stale-routed-events"></a><span data-ttu-id="3fad0-273">Événements routés périmés</span><span class="sxs-lookup"><span data-stu-id="3fad0-273">Stale Routed Events</span></span>  
 <span data-ttu-id="3fad0-274">Le système d’événements routés dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifie des arborescences entières lorsque les événements sont déclenchés.</span><span class="sxs-lookup"><span data-stu-id="3fad0-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>  
  
 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]  
  
 <span data-ttu-id="3fad0-275">Lorsque le bouton gauche de la souris est enfoncé sur l’ellipse, `handler2` est exécutée.</span><span class="sxs-lookup"><span data-stu-id="3fad0-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="3fad0-276">Après avoir `handler2` se termine, l’événement est passé à la <xref:System.Windows.Controls.Canvas> objet, qui utilise `handler1` pour le traiter.</span><span class="sxs-lookup"><span data-stu-id="3fad0-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="3fad0-277">Cela se produit uniquement si `handler2` ne sont pas explicitement marque l’objet d’événement comme géré.</span><span class="sxs-lookup"><span data-stu-id="3fad0-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>  
  
 <span data-ttu-id="3fad0-278">Il est possible que `handler2` prendra beaucoup de temps pour le traitement de cet événement.</span><span class="sxs-lookup"><span data-stu-id="3fad0-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="3fad0-279">`handler2`peut utiliser <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> pour commencer une boucle de messages imbriqués qui ne retourne pas pour les heures.</span><span class="sxs-lookup"><span data-stu-id="3fad0-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="3fad0-280">Si `handler2` ne marque pas l’événement comme géré lorsque cette boucle de message est terminer, l’événement est passé dans l’arborescence de la même s’il est très ancien.</span><span class="sxs-lookup"><span data-stu-id="3fad0-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>  
  
### <a name="reentrancy-and-locking"></a><span data-ttu-id="3fad0-281">Réentrance et verrouillage</span><span class="sxs-lookup"><span data-stu-id="3fad0-281">Reentrancy and Locking</span></span>  
 <span data-ttu-id="3fad0-282">Le mécanisme de verrouillage de la [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] ne se comporte exactement comme l’imaginer ; attendre un thread cesse complètement l’opération lors de la demande un verrou.</span><span class="sxs-lookup"><span data-stu-id="3fad0-282">The locking mechanism of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="3fad0-283">En fait, le thread continue à recevoir et à traiter les messages de priorité élevée.</span><span class="sxs-lookup"><span data-stu-id="3fad0-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="3fad0-284">Ceci permet d’éviter les blocages et de rendre les interfaces un minimum réactives, mais introduit la possibilité de bogues subtils.</span><span class="sxs-lookup"><span data-stu-id="3fad0-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="3fad0-285">La plupart du temps, vous n’avez pas besoin de connaître quoi que ce soit à ce sujet, mais dans de rares circonstances (impliquant généralement [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] messages de fenêtre ou des composants COM STA) cela peut s’avérer utile.</span><span class="sxs-lookup"><span data-stu-id="3fad0-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window messages or COM STA components) this can be worth knowing.</span></span>  
  
 <span data-ttu-id="3fad0-286">La plupart des interfaces ne sont pas générés avec la sécurité des threads à l’esprit, car les développeurs partent du principe qu’un [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] n’est jamais accessibles par plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="3fad0-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="3fad0-287">Dans ce cas, ce thread unique peut apporter des modifications d’ordre environnemental à des moments inattendus, provoquant des effets négatifs qui le <xref:System.Windows.Threading.DispatcherObject> mécanisme d’exclusion mutuelle est supposé pour résoudre.</span><span class="sxs-lookup"><span data-stu-id="3fad0-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="3fad0-288">Considérez le pseudocode suivant :</span><span class="sxs-lookup"><span data-stu-id="3fad0-288">Consider the following pseudocode:</span></span>  
  
 <span data-ttu-id="3fad0-289">![Diagramme de réentrance des threads](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="3fad0-289">![Threading reentrancy diagram](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png "ThreadingReentrancy")</span></span>  
  
 <span data-ttu-id="3fad0-290">La plupart du temps, qui est la meilleure, mais il existe des cas dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] où ce réentrance inattendue risque des problèmes.</span><span class="sxs-lookup"><span data-stu-id="3fad0-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="3fad0-291">C’est le cas, à certains moments clés, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] appels <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, qui modifie l’instruction lock pour ce thread afin d’utiliser le [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] verrou exempt de réentrance, au lieu de classiques [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] verrou.</span><span class="sxs-lookup"><span data-stu-id="3fad0-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] lock.</span></span>  
  
 <span data-ttu-id="3fad0-292">Raison pour laquelle c’est le cas a la [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] équipe choisi ce comportement ?</span><span class="sxs-lookup"><span data-stu-id="3fad0-292">So why did the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team choose this behavior?</span></span> <span data-ttu-id="3fad0-293">Elle devait tenir compte des objets STA COM et du thread de finalisation.</span><span class="sxs-lookup"><span data-stu-id="3fad0-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="3fad0-294">Lorsqu’un objet par le garbage collecté, sa `Finalize` méthode est exécutée sur le thread finaliseur dédié, pas le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="3fad0-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="3fad0-295">Et qui y réside le problème, car un objet COM STA qui a été créé sur le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread ne peut être supprimé sur le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span><span class="sxs-lookup"><span data-stu-id="3fad0-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="3fad0-296">Le [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] fait l’équivalent d’un <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (dans ce cas à l’aide de Win32 `SendMessage`).</span><span class="sxs-lookup"><span data-stu-id="3fad0-296">The [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="3fad0-297">Toutefois, si le [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread est occupé, le thread finaliseur est bloqué et l’objet COM STA ne peut pas être supprimé, ce qui crée une fuite de mémoire grave.</span><span class="sxs-lookup"><span data-stu-id="3fad0-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="3fad0-298">Par conséquent, le [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] équipe pris la décision difficile pour rendre les verrous fonctionnent comme ils le font.</span><span class="sxs-lookup"><span data-stu-id="3fad0-298">So the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team made the tough call to make locks work the way they do.</span></span>  
  
 <span data-ttu-id="3fad0-299">La tâche pour [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] consiste à éviter la réentrance inattendue sans réintroduction de la fuite de mémoire, c’est pourquoi nous ne bloquons pas la réentrance partout.</span><span class="sxs-lookup"><span data-stu-id="3fad0-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3fad0-300">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="3fad0-300">See Also</span></span>  
 [<span data-ttu-id="3fad0-301">Application à thread unique avec un exemple de calcul de longue</span><span class="sxs-lookup"><span data-stu-id="3fad0-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](http://go.microsoft.com/fwlink/?LinkID=160038)
