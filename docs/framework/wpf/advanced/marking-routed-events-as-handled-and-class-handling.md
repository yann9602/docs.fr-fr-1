---
title: "Marquage des événements routés comme étant gérés et gestion de classe"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
caps.latest.revision: "19"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: b2c9a550e1423acb37da9645d09cdb4ccefcea66
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/22/2017
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Marquage des événements routés comme étant gérés et gestion de classe
Les gestionnaires d’un événement routé peuvent marquer l’événement comme étant géré dans les données d’événement. La gestion de l’événement a pour effet de raccourcir efficacement l’itinéraire. La gestion de classe est un concept de programmation pris en charge par les événements routés. Un gestionnaire de classe peut gérer un événement routé particulier au niveau d’une classe à l’aide d’un gestionnaire appelé avant tout gestionnaire d’instance sur une instance de la classe.  
  

  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Prérequis  
 Cette rubrique décrit plus en détail les concepts introduits dans [Vue d’ensemble des événements routés](../../../../docs/framework/wpf/advanced/routed-events-overview.md).  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Quand marquer des événements comme étant gérés  
 Lorsque vous définissez la valeur de la <xref:System.Windows.RoutedEventArgs.Handled%2A> propriété `true` événements dans les données pour un événement routé, cela est appelé « marquage de l’événement géré ». Que vous soyez auteur d’une application ou auteur d’un contrôle qui répond à des événements routés existants ou qui implémente de nouveaux événements routés, il n’existe aucune règle absolue qui indique à quel moment marquer les événements routés comme étant gérés. Globalement, le concept « géré », tel qu’il est indiqué dans les données de l’événement routé, doit être utilisé comme un protocole limité pour les réponses de votre propre application aux divers événements routés exposés dans les [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], ainsi que pour les événements routés personnalisés. Une autre façon d’envisager la question du marquage « géré » est que vous devez généralement marquer un événement routé comme étant géré si votre code a répondu à l’événement routé d’une manière significative et relativement complète. En règle générale, il ne doit pas exister plus d’une réponse significative à exiger des implémentations de gestionnaire distinctes pour une même occurrence d’événement routé. Si plusieurs réponses sont nécessaires, le code correspondant doit être implémenté à travers la logique d’application intégrée à un gestionnaire unique plutôt qu’en utilisant le système d’événement routé pour le transfert. L’idée de ce qui est « significatif » revêt aussi une dimension subjective et dépend de votre application ou de votre code. À titre d’indication générale, voici quelques exemples de « réponses significatives » : définition du focus, modification de l’état public, définition des propriétés qui affectent la représentation visuelle et déclenchement d’autres événements nouveaux. À l’inverse, la modification de l’état privé (sans impact visuel ni représentation de programmation), la journalisation d’événements ou la consultation des arguments d’un événement et la décision de ne pas y répondre sont des exemples de réponses non significatives.  
  
 Le comportement de système d’événement routé renforce ce modèle de « réponse significative » pour l’utilisation de l’état géré d’un événement routé, car les gestionnaires ajoutés dans [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] ou la signature commune de <xref:System.Windows.UIElement.AddHandler%2A> ne sont pas appelés en réponse à un événement routé où l’événement données sont déjà marqué comme gérées. Vous devez suivre l’effort supplémentaire de l’ajout d’un gestionnaire avec la `handledEventsToo` version de paramètre (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) afin de gérer les événements routés sont marqués comme gérés par les participants antérieures acheminer de l’événement.  
  
 Dans certains cas, les contrôles proprement dits marquent certains événements routés comme étant gérés. Un événement routé géré représente une décision de la part des auteurs d’un contrôle [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] que les actions du contrôle en réponse à l’événement routé sont significatives ou terminées dans le cadre de l’implémentation du contrôle, et l’événement n’a plus besoin d’être géré. Cela consiste généralement à ajouter un gestionnaire de classe pour un événement ou à remplacer l’un des virtuels de gestionnaire de classe qui existent dans une classe de base. Vous pouvez toujours contourner cette gestion d’événement, si nécessaire ; consultez la page [Résolution des problèmes liés à la suppression d’événements par des contrôles](#WorkingAroundEventSuppressionByControls) plus loin dans cette rubrique.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>Événements Preview (tunneling) versus événements de propagation et gestion des événements  
 Les événements routés Preview sont des événements qui suivent un itinéraire de tunneling dans l’arborescence des éléments. « Preview », exprimé dans la convention de nommage, est révélateur du principe général des événements d’entrée selon lequel les événements routés Preview (tunneling) sont déclenchés avant l’événement routé de propagation équivalent. Par ailleurs, les événements routés d’entrée associés à une paire de tunneling et de propagation ont une logique de gestion distincte. Si l’événement routé de tunneling/preview est marqué comme étant géré par un écouteur d’événements, l’événement routé de propagation est alors marqué comme étant géré, avant même qu’un écouteur de l’événement routé de propagation l’ait reçu. Les événements routés de tunneling et de propagation sont des événements techniquement distincts, mais ils partagent délibérément la même instance de données d’événement pour autoriser ce comportement.  
  
 La connexion entre les événements routés de tunneling et de propagation est établie par l’implémentation interne du mode de déclenchement des événements routés déclarés d’une classe [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] donnée, et cela s’applique aux événements routés d’entrée associés. Cependant, à moins que cette implémentation au niveau de la classe existe, aucune connexion n’est établie entre un événement routé de tunneling et un événement routé de propagation qui partagent le modèle de nommage : sans cette implémentation, ils deviendraient deux événements routés totalement distincts et ne seraient pas déclenchés dans l’ordre, ni ne partageraient les données d’événement.  
  
 Pour plus d’informations sur l’implémentation des paires d’événements routés d’entrée de tunneling/propagation dans une classe personnalisée, consultez [Créer un événement routé personnalisé](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Gestionnaires de classe et gestionnaires d’instance  
 Les événements routés reconnaissent deux types d’écouteur d’événement : les écouteurs de classe et les écouteurs d’instance. Écouteurs de classe existent, car les types ont appelé un particulier <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, dans leur constructeur statique, ou vous l’avez substituée une méthode virtuelle de gestionnaire de classe à partir d’une classe de base d’élément. Écouteurs d’instance sont des éléments/instances de classe particulier où un ou plusieurs gestionnaires ont été associés à cet événement routé par un appel à <xref:System.Windows.UIElement.AddHandler%2A>. Existant [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] événements routés effectuent des appels vers <xref:System.Windows.UIElement.AddHandler%2A> dans le cadre de la [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] wrapper d’événement ajouter {} et supprimer des implémentations {} de l’événement, qui est également comment simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mécanisme de gestionnaires d’événements via un attribut syntaxe est activée. Par conséquent, même la simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] utilisation finalement équivaut à un <xref:System.Windows.UIElement.AddHandler%2A> appeler.  
  
 Les éléments de l’arborescence d’éléments visuels sont vérifiés pour déterminer s’ils comportent des implémentations de gestionnaire enregistré. Les gestionnaires sont potentiellement appelés tout au long de l’itinéraire, dans l’ordre inhérent au type de la stratégie de routage pour cet événement routé. Par exemple, les événements routés de propagation appellent d’abord les gestionnaires associés à l’élément qui a déclenché l’événement routé. Les événements routés sont ensuite « propagés » au prochain élément parent, et ainsi de suite jusqu’à ce que l’élément racine de l’application soit atteint.  
  
 Du point de vue de l’élément racine d’un itinéraire de propagation, si la gestion de classe ou tout élément plus proche de la source de l’événement routé appelle des gestionnaires qui marquent les arguments d’événement comme étant gérés, les gestionnaires des éléments racine ne sont pas appelés, et l’itinéraire de l’événement est raccourci efficacement avant d’atteindre l’élément racine en question. Cependant, l’itinéraire n’est pas complètement arrêté, car il est possible d’ajouter des gestionnaires à l’aide d’un conditionnel spécial qui exige qu’ils soient tout de même appelés, même si un gestionnaire de classe ou d’instance a marqué l’événement routé comme étant géré. Cet aspect est détaillé plus loin dans cette rubrique dans [Ajout de gestionnaires d’instance déclenchés y compris quand les événements sont marqués comme étant gérés](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled).  
  
 À un niveau plus approfondi que l’itinéraire d’événement se trouvent également des gestionnaires de classe potentiellement multiples qui agissent sur une instance donnée d’une classe. Cela est dû au fait que le modèle de gestion de classe des événements routés permet à toutes les classes possibles d’une hiérarchie de classes d’enregistrer chacune son propre gestionnaire de classe pour chaque événement routé. Chaque gestionnaire de classe est ajouté à un magasin interne, et quand l’itinéraire d’événement d’une application est construit, les gestionnaires de classe sont tous ajoutés à l’itinéraire d’événement. Les gestionnaires de classe sont ajoutés à l’itinéraire de sorte que le gestionnaire de classe le plus dérivé soit appelé en premier et que les gestionnaires de chaque classe de base consécutive soient appelés ensuite. En règle générale, les gestionnaires de classe ne sont pas enregistrés de sorte qu’ils répondent aussi aux événements routés qui étaient déjà marqués comme étant gérés. Par conséquent, ce mécanisme de gestion de classe permet d’opter pour l’un des deux choix suivants :  
  
-   Les classes dérivées peuvent compléter la gestion de classe héritée de la classe de base en ajoutant un gestionnaire qui ne marque pas l’événement routé comme étant géré, car le gestionnaire de classe de base sera appelé peu de temps après le gestionnaire de classe dérivé.  
  
-   Les classes dérivées peuvent remplacer la gestion de classe à partir de la classe de base en ajoutant un gestionnaire de classe qui marque l’événement routé comme étant géré. Vous devez être prudent avec cette approche, car elle est susceptible de changer la conception du contrôle de base prévu dans des domaines tels que l’apparence visuelle, la logique d’état, la gestion des entrées et la gestion des commandes.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Gestion de classe des événements routés par les classes de base de contrôle  
 Sur chaque nœud d’élément donné au sein d’un itinéraire d’événement, les écouteurs de classe peuvent répondre à l’événement routé avant n’importe quel écouteur d’instance de l’élément. C’est pourquoi les gestionnaires de classe sont parfois utilisés pour supprimer les événements routés qu’une implémentation de classe de contrôle particulière ne souhaite pas propager davantage, ou pour assurer une gestion spéciale de l’événement routé qui compte parmi les fonctionnalités de la classe. Par exemple, une classe peut déclencher son propre événement spécifique qui contient davantage de détails sur la signification de la condition d’entrée utilisateur dans le contexte de cette classe particulière. L’implémentation de classe peut ensuite marquer l’événement routé plus général comme étant géré. Gestionnaires de classe sont généralement ajoutés sorte qu’ils ne sont pas appelés pour routé où les données d’événement partagées était déjà marquées les événements gérés, mais pour les cas atypiques il existe également un <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature qui inscrit des gestionnaires de classe pour appeler la même lorsque les événements routés sont marqué comme géré.  
  
### <a name="class-handler-virtuals"></a>Virtuels de gestionnaire de classe  
 Certains éléments, notamment les éléments de base tels que <xref:System.Windows.UIElement>, exposent » sur * événements » et « OnPreview\*événement » des méthodes virtuelles qui correspondent à leur liste d’événements routés publics. Ces méthodes virtuelles peuvent être remplacées de façon à implémenter un gestionnaire de classe pour l’événement routé en question. Les classes d’élément de base enregistrent ces méthodes virtuelles comme leur gestionnaire de classe pour chacun de ces routés à l’aide de l’événement <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> comme décrit précédemment. Les méthodes virtuelles On\*Event facilitent considérablement l’implémentation de la gestion de classe pour les événements routés correspondants, sans nécessiter d’initialisation spéciale dans les constructeurs statiques de chaque type. Par exemple, vous pouvez ajouter la gestion de classe pour le <xref:System.Windows.UIElement.DragEnter> événement dans les <xref:System.Windows.UIElement> classe dérivée en substituant la <xref:System.Windows.UIElement.OnDragEnter%2A> méthode virtuelle. Au cours de ce remplacement, vous pouvez gérer l’événement routé, déclencher d’autres événements, initialiser la logique spécifique à la classe qui pourrait changer des propriétés d’élément dans les instances, ou toute combinaison de ces actions. En règle générale, dans ce type de modification, vous devez appeler l’implémentation de base même si vous marquez l’événement comme étant géré. Il est vivement recommandé d’appeler l’implémentation de base, car la méthode virtuelle se trouve au niveau de la classe de base. Dans l’absolu, le modèle virtuel protégé standard mis en œuvre pour appeler les implémentations de base à partir de chaque virtuel remplace et met en parallèle un mécanisme similaire natif de la gestion des classes d’événements routés, au moyen duquel sont appelés les gestionnaires de toutes les classes d’une hiérarchie de classes d’une instance donnée, en commençant par le gestionnaire de classe le plus dérivé pour ensuite passer au gestionnaire de classe de base. Vous ne devez omettre l’appel à l’implémentation de base que si votre classe exige délibérément de changer la logique de gestion de classe de base. C’est la nature de votre implémentation qui détermine si vous appelez l’implémentation de base avant ou après votre code de substitution.  
  
#### <a name="input-event-class-handling"></a>Gestion des classes d’événements d’entrée  
 Les méthodes virtuelles des gestionnaires de classe sont toutes enregistrées pour faire en sorte qu’elles ne soient appelées que si les données d’événement partagées ne sont pas déjà marquées comme étant gérées. Par ailleurs, pour les événements d’entrée uniquement, les versions de tunneling et de propagation sont généralement déclenchées dans l’ordre et partagent les données d’événement. Par conséquent, pour une paire donnée de gestionnaires de classe d’événements d’entrée, où l’un correspond à la version de tunneling et l’autre à la version de propagation, vous pouvez ne pas marquer immédiatement l’événement comme étant géré. Si vous implémentez la méthode virtuelle de gestion de classe par tunneling pour marquer l’événement comme étant géré, le gestionnaire de classe de propagation ne pourra pas être appelé (ni même les gestionnaires d’instance enregistrés normalement pour l’événement de tunneling ou de propagation).  
  
 Une fois que la gestion de classe est terminée sur un nœud, les écouteurs d’instance sont pris en considération.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Ajout de gestionnaires d’instance déclenchés y compris quand les événements sont marqués comme étant gérés  
 Le <xref:System.Windows.UIElement.AddHandler%2A> méthode fournit une surcharge particulière qui vous permet d’ajouter des gestionnaires qui seront appelés par le système d’événement chaque fois qu’un événement atteint l’élément de gestion dans l’itinéraire, même si un autre gestionnaire a déjà ajusté pour indiquer que les données d’événement événement comme géré. Il ne s’agit pas de la procédure courante. En général, des gestionnaires peuvent être écrits pour ajuster toutes les zones de code d’application susceptibles d’être influencées par un événement, indépendamment de l’emplacement où il a été géré dans une arborescence d’éléments, même si plusieurs résultats finaux sont souhaités. De plus, seul un élément est généralement chargé véritablement de répondre à cet événement, et la logique d’application appropriée s’est déjà exécutée. Cependant, la surcharge `handledEventsToo` est disponible pour les cas exceptionnels où un autre élément d’une arborescence d’éléments ou une composition de contrôles a déjà marqué un événement comme étant géré, mais que d’autres éléments situés plus haut ou plus bas dans l’arborescence d’éléments (en fonction de l’itinéraire) demandent toujours à ce que leurs propres gestionnaires soient appelés.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Quand marquer des événements gérés comme étant non gérés  
 En règle générale, les événements routés sont marqués comme gérés ne doivent pas être marqués non gérées (<xref:System.Windows.RoutedEventArgs.Handled%2A> rétablir `false`) même par les gestionnaires qui agissent sur `handledEventsToo`. Cependant, certains événements d’entrée ont des représentations d’événement de haut niveau et de bas niveau qui peuvent se chevaucher quand l’événement de haut niveau et l’événement de bas niveau ne se trouvent pas à la même position dans l’arborescence. Par exemple, prenons le cas où un élément enfant écoute un événement de touche haut niveau tels que <xref:System.Windows.UIElement.TextInput> pendant qu’un élément parent écoute un événement de niveau inférieur tel que <xref:System.Windows.UIElement.KeyDown>. Si l’élément parent gère l’événement de bas niveau, l’événement de haut niveau peut être supprimé même dans l’élément enfant qui logiquement devrait être le premier à pouvoir gérer l’événement.  
  
 Dans ce cas, il peut s’avérer nécessaire d’ajouter des gestionnaires aux éléments parents et enfants pour l’événement de bas niveau. L’implémentation du gestionnaire d’éléments enfants peut marquer l’événement de bas niveau comme étant géré, mais l’implémentation du gestionnaire d’éléments parents le redéfinirait comme étant non géré, si bien que les éléments de niveau supérieur de l’arborescence (ainsi que l’événement de haut niveau) peuvent avoir l’occasion de répondre. Ce cas de figure devrait être assez rare.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Suppression délibérée d’événements d’entrée pour la composition de contrôles  
 La gestion de classe d’événements routés est principalement utilisée pour les événements d’entrée et les contrôles composés. Un contrôle composé est par définition composé de plusieurs contrôles pratiques ou classes de base de contrôle. Souvent, l’intention de l’auteur du contrôle est d’amalgamer tous les événements d’entrée possibles que chaque sous-composant peut déclencher, de façon à signaler l’ensemble du contrôle comme étant la source singulière des événements. Dans certains cas, l’auteur du contrôle peut souhaiter supprimer totalement les événements des composants ou remplacer un événement défini par un composant qui contient davantage d’informations ou implique un comportement plus spécifique. L’exemple canonique est immédiatement visible pour tout auteur de composant est comment un [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> gère tout événement de souris qui se résoudra finalement à l’événement intuitif que tous les boutons ont : un <xref:System.Windows.Controls.Primitives.ButtonBase.Click> événement.  
  
 Le <xref:System.Windows.Controls.Button> classe de base (<xref:System.Windows.Controls.Primitives.ButtonBase>) dérive <xref:System.Windows.Controls.Control> qui dérive à son tour <xref:System.Windows.FrameworkElement> et <xref:System.Windows.UIElement>et une grande partie de l’infrastructure d’événements nécessaire pour contrôler le traitement d’entrée n’est disponible à la <xref:System.Windows.UIElement> niveau. En particulier, <xref:System.Windows.UIElement> traite général <xref:System.Windows.Input.Mouse> les événements qui gèrent les tests de positionnement de la souris dans ses limites et fournit des événements distincts pour les plus courants tels que des actions, de bouton <xref:System.Windows.UIElement.MouseLeftButtonDown>. <xref:System.Windows.UIElement>fournit également un virtuel vide <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> en tant que gestionnaire de classe préenregistré pour <xref:System.Windows.UIElement.MouseLeftButtonDown>, et <xref:System.Windows.Controls.Primitives.ButtonBase> se substitue à elle. De même, <xref:System.Windows.Controls.Primitives.ButtonBase> utilise gestionnaires de classe pour <xref:System.Windows.UIElement.MouseLeftButtonUp>. Dans les substitutions qui sont passées les données d’événement, les implémentations qui marquent <xref:System.Windows.RoutedEventArgs> comme géré en affectant l’instance <xref:System.Windows.RoutedEventArgs.Handled%2A> à `true`, et que les mêmes données d’événement sont ce qui se poursuit sur le reste de l’itinéraire à d’autres gestionnaires de classe et également pour les gestionnaires d’instance ou les méthodes setter d’événement. En outre, le <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> remplacement déclenchera ensuite le <xref:System.Windows.Controls.Primitives.ButtonBase.Click> événement. Le résultat final pour la plupart des écouteurs qui sera le <xref:System.Windows.UIElement.MouseLeftButtonDown> et <xref:System.Windows.UIElement.MouseLeftButtonUp> événements « disparaissent » et sont remplacés par <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, un événement plus significatif, car il est connu que cet événement provient d’un bouton de valeur est true et pas certains composite entièrement la pièce du bouton ou à partir d’un autre élément.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Résolution des problèmes liés à la suppression d’événements par des contrôles  
 Ce comportement de suppression d’événements au sein des contrôles individuels peut parfois interférer avec certaines intentions plus générales de la logique de gestion des événements de votre application. Par exemple, si pour une raison quelconque, votre application avait un gestionnaire pour <xref:System.Windows.UIElement.MouseLeftButtonDown> situé à l’élément racine d’application, vous noterez qu’un clic de souris sur un bouton appelle pas <xref:System.Windows.UIElement.MouseLeftButtonDown> ou <xref:System.Windows.UIElement.MouseLeftButtonUp> gestionnaires au niveau racine. L’événement proprement dit s’est bien propagé (encore une fois, les itinéraires d’événements ne se terminent pas véritablement, mais le système d’événements routés change leur comportement d’appel de gestionnaire après qu’ils ont été marqués comme étant gérés). Lorsque l’événement routé a atteint le bouton, le <xref:System.Windows.Controls.Primitives.ButtonBase> la gestion de classe marquée le <xref:System.Windows.UIElement.MouseLeftButtonDown> gérées, car il a souhaité remplacer le <xref:System.Windows.Controls.Primitives.ButtonBase.Click> événement avec plus de sens. Par conséquent, une norme <xref:System.Windows.UIElement.MouseLeftButtonDown> Gestionnaire davantage de l’itinéraire ne sera pas appelé. Vous avez le choix entre deux techniques pour faire en sorte que vos gestionnaires soient appelés dans ce cas.  
  
 La première technique consiste à ajouter délibérément le gestionnaire à l’aide de la `handledEventsToo` signature de <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>. La limite de cette approche vient du fait que le gestionnaire d’événements ne peut être joint qu’à partir du code et non du balisage. La syntaxe simple de spécification du nom du gestionnaire d’événements en tant que valeur d’attribut d’événement via [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] n’active pas ce comportement.  
  
 La deuxième technique vaut uniquement pour les événements d’entrée où les versions de tunneling et de propagation de l’événement routé sont associées. Pour ces événements routés, vous pouvez plutôt ajouter des gestionnaires à l’événement routé équivalent preview/tunneling équivalent. Cet événement routé crée un tunnel le long de l’itinéraire en partant de la racine, si bien que le code de gestion de classe Button ne l’intercepte pas, présumant que vous avez joint le gestionnaire Preview au niveau d’un élément ancêtre dans l’arborescence d’éléments de l’application. Si vous utilisez cette approche, faites attention quand il s’agit de marquer un événement Preview comment étant géré. Dans l’exemple donné avec <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> géré au niveau de l’élément racine, si vous avez marqué l’événement comme <xref:System.Windows.RoutedEventArgs.Handled%2A> dans l’implémentation du gestionnaire, vous serez réellement supprimer le <xref:System.Windows.Controls.Primitives.ButtonBase.Click> événement. Ce comportement n’est généralement pas souhaitable.  
  
## <a name="see-also"></a>Voir aussi  
 <xref:System.Windows.EventManager>  
 [Événements Preview](../../../../docs/framework/wpf/advanced/preview-events.md)  
 [Créer un événement routé personnalisé](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)  
 [Vue d’ensemble des événements routés](../../../../docs/framework/wpf/advanced/routed-events-overview.md)
