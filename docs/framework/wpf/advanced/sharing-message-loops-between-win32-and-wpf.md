---
title: Partage de boucles de messages entre Win32 et WPF
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
caps.latest.revision: "10"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: d3122100f93d15c04c109564e1abd2dc13f37990
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/22/2017
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="eca1d-102">Partage de boucles de messages entre Win32 et WPF</span><span class="sxs-lookup"><span data-stu-id="eca1d-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="eca1d-103">Cette rubrique décrit comment implémenter une boucle de messages pour l’interopérabilité avec [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], à l’aide d’existant message exposition de boucle dans <xref:System.Windows.Threading.Dispatcher> ou en créant une boucle de messages distincte sur la [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] de votre code d’interopérabilité.</span><span class="sxs-lookup"><span data-stu-id="eca1d-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="eca1d-104">ComponentDispatcher et la boucle de messages</span><span class="sxs-lookup"><span data-stu-id="eca1d-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="eca1d-105">Un scénario normal pour l’interopérabilité et le clavier pris en charge consiste à implémenter <xref:System.Windows.Interop.IKeyboardInputSink>, ou à sous-classer à partir de classes qui implémentent déjà <xref:System.Windows.Interop.IKeyboardInputSink>, tel que <xref:System.Windows.Interop.HwndSource> ou <xref:System.Windows.Interop.HwndHost>.</span><span class="sxs-lookup"><span data-stu-id="eca1d-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="eca1d-106">Toutefois, la prise en charge du récepteur de clavier ne traite pas tous les besoins de boucle de message possibles que peut-être envoyer et recevoir des messages entre les limites d’interopérabilité.</span><span class="sxs-lookup"><span data-stu-id="eca1d-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="eca1d-107">Pour aider à formaliser une architecture de boucle de message application [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] fournit le <xref:System.Windows.Interop.ComponentDispatcher> (classe), qui définit un protocole simple pour une boucle de message à suivre.</span><span class="sxs-lookup"><span data-stu-id="eca1d-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="eca1d-108"><xref:System.Windows.Interop.ComponentDispatcher>est une classe statique qui expose plusieurs membres.</span><span class="sxs-lookup"><span data-stu-id="eca1d-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="eca1d-109">La portée de chaque méthode est implicitement liée au thread appelant.</span><span class="sxs-lookup"><span data-stu-id="eca1d-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="eca1d-110">Une boucle de messages doit appeler certaines de ces [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] à des moments critiques (comme défini dans la section suivante).</span><span class="sxs-lookup"><span data-stu-id="eca1d-110">A message loop must call some of those [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="eca1d-111"><xref:System.Windows.Interop.ComponentDispatcher>Fournit des événements que d’autres composants (par exemple, le récepteur de clavier) peuvent écouter.</span><span class="sxs-lookup"><span data-stu-id="eca1d-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="eca1d-112">Le <xref:System.Windows.Threading.Dispatcher> appelle tous les contrôles de la classe <xref:System.Windows.Interop.ComponentDispatcher> méthodes dans une séquence appropriée.</span><span class="sxs-lookup"><span data-stu-id="eca1d-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="eca1d-113">Si vous implémentez votre propre boucle de messages, votre code est chargé d’appeler <xref:System.Windows.Interop.ComponentDispatcher> méthodes de la même manière.</span><span class="sxs-lookup"><span data-stu-id="eca1d-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="eca1d-114">Appel de <xref:System.Windows.Interop.ComponentDispatcher> méthodes sur un thread n’appellera que les gestionnaires d’événements qui ont été enregistrés sur ce thread.</span><span class="sxs-lookup"><span data-stu-id="eca1d-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="eca1d-115">Boucles de messages de l’écriture</span><span class="sxs-lookup"><span data-stu-id="eca1d-115">Writing Message Loops</span></span>  
 <span data-ttu-id="eca1d-116">Voici une liste de vérification de <xref:System.Windows.Interop.ComponentDispatcher> membres que vous utiliserez si vous écrivez votre propre boucle de messages :</span><span class="sxs-lookup"><span data-stu-id="eca1d-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
-   <span data-ttu-id="eca1d-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: votre boucle de messages doit appeler pour indiquer que le thread est modal.</span><span class="sxs-lookup"><span data-stu-id="eca1d-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
-   <span data-ttu-id="eca1d-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>: votre boucle de messages doit appeler pour indiquer que le thread a été rétabli à l’état non modal.</span><span class="sxs-lookup"><span data-stu-id="eca1d-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
-   <span data-ttu-id="eca1d-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: votre boucle de messages doit appeler pour indiquer que <xref:System.Windows.Interop.ComponentDispatcher> doit déclencher le <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> événement.</span><span class="sxs-lookup"><span data-stu-id="eca1d-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="eca1d-120"><xref:System.Windows.Interop.ComponentDispatcher>ne génère pas de <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> si <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> est `true`, mais les boucles de messages peuvent choisir d’appeler <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> même si <xref:System.Windows.Interop.ComponentDispatcher> ne peut pas y répondre en état modal.</span><span class="sxs-lookup"><span data-stu-id="eca1d-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
-   <span data-ttu-id="eca1d-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: votre boucle de messages doit appeler pour indiquer qu’un nouveau message est disponible.</span><span class="sxs-lookup"><span data-stu-id="eca1d-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="eca1d-122">La valeur de retour indique si un écouteur pour un <xref:System.Windows.Interop.ComponentDispatcher> événement géré le message.</span><span class="sxs-lookup"><span data-stu-id="eca1d-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="eca1d-123">Si <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> retourne `true` (géré), le répartiteur ne doit rien faire davantage avec le message.</span><span class="sxs-lookup"><span data-stu-id="eca1d-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="eca1d-124">Si la valeur de retour est `false`, le répartiteur est censé appeler le [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] fonction `TranslateMessage`, puis appelez `DispatchMessage`.</span><span class="sxs-lookup"><span data-stu-id="eca1d-124">If the return value is `false`, the dispatcher is expected to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="eca1d-125">Utilisation de ComponentDispatcher et gestion des messages existants</span><span class="sxs-lookup"><span data-stu-id="eca1d-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="eca1d-126">Voici une liste de vérification de <xref:System.Windows.Interop.ComponentDispatcher> membres que vous utiliserez si vous comptez sur les [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] boucle de message.</span><span class="sxs-lookup"><span data-stu-id="eca1d-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
-   <span data-ttu-id="eca1d-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: indique si l’application est passée modale (par exemple, une boucle de messages modale ont été envoyée).</span><span class="sxs-lookup"><span data-stu-id="eca1d-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="eca1d-128"><xref:System.Windows.Interop.ComponentDispatcher>permet de suivre cet état, car la classe maintient un nombre de <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> et <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> appels à partir de la boucle de messages.</span><span class="sxs-lookup"><span data-stu-id="eca1d-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
-   <span data-ttu-id="eca1d-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>et <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> événements suivent les règles standards pour les appels de délégués.</span><span class="sxs-lookup"><span data-stu-id="eca1d-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="eca1d-130">Les délégués sont appelés dans un ordre non spécifié, et tous les délégués sont appelés même si le premier marque le message comme étant géré.</span><span class="sxs-lookup"><span data-stu-id="eca1d-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
-   <span data-ttu-id="eca1d-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indique un moment approprié et efficace pour le traitement inactivité (il n’existe pas d’autres messages en attente pour le thread).</span><span class="sxs-lookup"><span data-stu-id="eca1d-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="eca1d-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>ne sera pas déclenchée si le thread est modal.</span><span class="sxs-lookup"><span data-stu-id="eca1d-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
-   <span data-ttu-id="eca1d-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: déclenché pour tous les messages qui traite de la pompe de messages.</span><span class="sxs-lookup"><span data-stu-id="eca1d-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
-   <span data-ttu-id="eca1d-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: déclenché pour tous les messages qui n’ont pas été gérés pendant <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span><span class="sxs-lookup"><span data-stu-id="eca1d-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="eca1d-135">Un message est considéré géré si après la <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> événement ou <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> événement, le `handled` paramètre passé par référence dans les données d’événement est `true`.</span><span class="sxs-lookup"><span data-stu-id="eca1d-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="eca1d-136">Gestionnaires d’événements doivent ignorer le message si `handled` est `true`, car cela signifie que le gestionnaire différent géré le message en premier.</span><span class="sxs-lookup"><span data-stu-id="eca1d-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="eca1d-137">Gestionnaires d’événements pour les deux événements peuvent modifier le message.</span><span class="sxs-lookup"><span data-stu-id="eca1d-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="eca1d-138">Le répartiteur doit distribuer le message modifié et non le message inchangé d’origine.</span><span class="sxs-lookup"><span data-stu-id="eca1d-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="eca1d-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>est remis à tous les écouteurs, mais l’intention architecturale est que seule la fenêtre de niveau supérieur contenant le HWND à laquelle les messages destinés doivent appeler le code en réponse au message.</span><span class="sxs-lookup"><span data-stu-id="eca1d-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="eca1d-140">Comment HwndSource traite des événements ComponentDispatcher</span><span class="sxs-lookup"><span data-stu-id="eca1d-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="eca1d-141">Si le <xref:System.Windows.Interop.HwndSource> est une fenêtre de niveau supérieur (pas de HWND parent), il sera enregistré avec <xref:System.Windows.Interop.ComponentDispatcher>.</span><span class="sxs-lookup"><span data-stu-id="eca1d-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="eca1d-142">Si <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> est déclenché, et si le message est destiné le <xref:System.Windows.Interop.HwndSource> ou fenêtres enfants, <xref:System.Windows.Interop.HwndSource> appelle son <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> séquence de récepteur de clavier.</span><span class="sxs-lookup"><span data-stu-id="eca1d-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="eca1d-143">Si le <xref:System.Windows.Interop.HwndSource> n’est pas une fenêtre de niveau supérieur (possède un HWND parent), il n’y aura aucune gestion.</span><span class="sxs-lookup"><span data-stu-id="eca1d-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="eca1d-144">Seule la fenêtre de niveau supérieur est attendue pour effectuer la gestion et il est censé être une fenêtre de niveau supérieur avec prise en charge du récepteur de clavier dans le cadre d’un scénario d’interopérabilité.</span><span class="sxs-lookup"><span data-stu-id="eca1d-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="eca1d-145">Si <xref:System.Windows.Interop.HwndHost.WndProc%2A> sur une <xref:System.Windows.Interop.HwndSource> est appelée sans une méthode de récepteur de clavier appropriés qui est appelée en premier, votre application reçoit les événements du clavier du niveau supérieur tels que <xref:System.Windows.UIElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="eca1d-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="eca1d-146">Toutefois, aucune méthode de récepteur de clavier n’est appelé, ce qui permet de contourner des fonctionnalités du modèle d’entrée clavier souhaitables comme clé prise en charge de l’accès.</span><span class="sxs-lookup"><span data-stu-id="eca1d-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="eca1d-147">Cela peut se produire si la boucle de message n’a pas notifié correctement le thread pertinent sur le <xref:System.Windows.Interop.ComponentDispatcher>, ou parce que le parent HWND n’a pas appelé les réponses de récepteur de clavier appropriée.</span><span class="sxs-lookup"><span data-stu-id="eca1d-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="eca1d-148">Un message atteint le récepteur de clavier ne peut pas être envoyé à HWND si vous avez ajouté des raccordements pour ce message à l’aide de la <xref:System.Windows.Interop.HwndSource.AddHook%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="eca1d-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="eca1d-149">Le message a été géré au niveau de pompe de message directement et non soumis à la `DispatchMessage` (fonction).</span><span class="sxs-lookup"><span data-stu-id="eca1d-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="eca1d-150">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="eca1d-150">See Also</span></span>  
 <xref:System.Windows.Interop.ComponentDispatcher>  
 <xref:System.Windows.Interop.IKeyboardInputSink>  
 [<span data-ttu-id="eca1d-151">Interopérabilité WPF et Win32</span><span class="sxs-lookup"><span data-stu-id="eca1d-151">WPF and Win32 Interoperation</span></span>](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)  
 [<span data-ttu-id="eca1d-152">Modèle de thread</span><span class="sxs-lookup"><span data-stu-id="eca1d-152">Threading Model</span></span>](../../../../docs/framework/wpf/advanced/threading-model.md)  
 [<span data-ttu-id="eca1d-153">Vue d’ensemble des entrées</span><span class="sxs-lookup"><span data-stu-id="eca1d-153">Input Overview</span></span>](../../../../docs/framework/wpf/advanced/input-overview.md)
