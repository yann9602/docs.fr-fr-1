---
title: Options de fusion en PLINQ
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: PLINQ queries, merge options
ms.assetid: e8f7be3b-88de-4f33-ab14-dc008e76c1ba
caps.latest.revision: "10"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: e9bf586c1805fc5b5f1cc5f96f4e6b08d80c199a
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/21/2017
---
# <a name="merge-options-in-plinq"></a><span data-ttu-id="2aff0-102">Options de fusion en PLINQ</span><span class="sxs-lookup"><span data-stu-id="2aff0-102">Merge Options in PLINQ</span></span>
<span data-ttu-id="2aff0-103">Lorsqu’une requête s’exécute en parallèle, PLINQ partitionne la séquence source afin que plusieurs threads puissent fonctionner sur différentes parties simultanément, en général sur des threads distincts.</span><span class="sxs-lookup"><span data-stu-id="2aff0-103">When a query is executing as parallel, PLINQ partitions the source sequence so that multiple threads can work on different parts concurrently, typically on separate threads.</span></span> <span data-ttu-id="2aff0-104">Si les résultats doivent être consommés sur un thread, par exemple, dans un `foreach` (`For Each` dans [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)]) de boucle, puis les résultats de chaque thread doivent être fusionnés en une séquence.</span><span class="sxs-lookup"><span data-stu-id="2aff0-104">If the results are to be consumed on one thread, for example, in a `foreach` (`For Each` in [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)]) loop, then the results from every thread must be merged back into one sequence.</span></span> <span data-ttu-id="2aff0-105">Le type de fusion que PLINQ exécute dépend des opérateurs présents dans la requête.</span><span class="sxs-lookup"><span data-stu-id="2aff0-105">The kind of merge that PLINQ performs depends on the operators that are present in the query.</span></span> <span data-ttu-id="2aff0-106">Par exemple, les opérateurs qui imposent un nouvel ordre des résultats doivent mettre en mémoire tampon tous les éléments de tous les threads.</span><span class="sxs-lookup"><span data-stu-id="2aff0-106">For example, operators that impose a new order on the results must buffer all elements from all threads.</span></span> <span data-ttu-id="2aff0-107">Du point de vue du thread consommateur (qui est également celui de l’utilisateur de l’application), une requête entièrement mis en mémoire tampon peut s’exécuter pendant une certaine durée avant qu’il génère son premier résultat.</span><span class="sxs-lookup"><span data-stu-id="2aff0-107">From the perspective of the consuming thread (which is also that of the application user) a fully buffered query might run for a noticeable period of time before it produces its first result.</span></span> <span data-ttu-id="2aff0-108">Autres opérateurs, par défaut, sont partiellement mis en mémoire tampon ; ils produisent leurs résultats par lots.</span><span class="sxs-lookup"><span data-stu-id="2aff0-108">Other operators, by default, are partially buffered; they yield their results in batches.</span></span> <span data-ttu-id="2aff0-109">Un opérateur, <xref:System.Linq.ParallelEnumerable.ForAll%2A> n’est pas mis en mémoire tampon par défaut.</span><span class="sxs-lookup"><span data-stu-id="2aff0-109">One operator, <xref:System.Linq.ParallelEnumerable.ForAll%2A> is not buffered by default.</span></span> <span data-ttu-id="2aff0-110">Il transmet immédiatement tous les éléments de tous les threads.</span><span class="sxs-lookup"><span data-stu-id="2aff0-110">It yields all elements from all threads immediately.</span></span>  
  
 <span data-ttu-id="2aff0-111">À l’aide de la <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> (méthode), comme indiqué dans l’exemple suivant, vous pouvez fournir un indicateur à PLINQ indiquant quel genre de fusion exécuter.</span><span class="sxs-lookup"><span data-stu-id="2aff0-111">By using the <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> method, as shown in the following example, you can provide a hint to PLINQ that indicates what kind of merging to perform.</span></span>  
  
 [!code-csharp[PLINQ#26](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#26)]
 [!code-vb[PLINQ#26](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#26)]  
  
 <span data-ttu-id="2aff0-112">Pour obtenir un exemple complet, consultez [Comment : spécifier les Options de fusion en PLINQ](../../../docs/standard/parallel-programming/how-to-specify-merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="2aff0-112">For the complete example, see [How to: Specify Merge Options in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-merge-options-in-plinq.md).</span></span>  
  
 <span data-ttu-id="2aff0-113">Si la requête ne peut pas prendre en charge l’option demandée, l’option sera simplement ignorée.</span><span class="sxs-lookup"><span data-stu-id="2aff0-113">If the particular query cannot support the requested option, then the option will just be ignored.</span></span> <span data-ttu-id="2aff0-114">Dans la plupart des cas, il est inutile de spécifier une option de fusion pour une requête PLINQ.</span><span class="sxs-lookup"><span data-stu-id="2aff0-114">In most cases, you do not have to specify a merge option for a PLINQ query.</span></span> <span data-ttu-id="2aff0-115">Toutefois, dans certains cas vous trouver en testant et en mesure une requête s’exécute mieux dans un mode non définis par défaut.</span><span class="sxs-lookup"><span data-stu-id="2aff0-115">However, in some cases you may find by testing and measurement that a query executes best in a non-default mode.</span></span> <span data-ttu-id="2aff0-116">Une utilisation courante de cette option est pour forcer un opérateur de fusion de segment pour diffuser ses résultats afin de fournir une interface utilisateur plus réactive.</span><span class="sxs-lookup"><span data-stu-id="2aff0-116">A common use of this option is to force a chunk-merging operator to stream its results in order to provide a more responsive user interface.</span></span>  
  
## <a name="parallelmergeoptions"></a><span data-ttu-id="2aff0-117">ParallelMergeOptions</span><span class="sxs-lookup"><span data-stu-id="2aff0-117">ParallelMergeOptions</span></span>  
 <span data-ttu-id="2aff0-118">Le <xref:System.Linq.ParallelMergeOptions> énumération inclut les options suivantes qui spécifient, pour les formes de requête prises en charge, la manière dont la sortie finale de la requête est transmise lorsque les résultats sont consommés sur un thread :</span><span class="sxs-lookup"><span data-stu-id="2aff0-118">The <xref:System.Linq.ParallelMergeOptions> enumeration includes the following options that specify, for supported query shapes, how the final output of the query is yielded when the results are consumed on one thread:</span></span>  
  
-   `Not Buffered`  
  
     <span data-ttu-id="2aff0-119">La <xref:System.Linq.ParallelMergeOptions.NotBuffered> option, chaque élément traité à retourner à partir de chaque thread dès qu’il est généré.</span><span class="sxs-lookup"><span data-stu-id="2aff0-119">The <xref:System.Linq.ParallelMergeOptions.NotBuffered> option causes each processed element to be returned from each thread as soon as it is produced.</span></span> <span data-ttu-id="2aff0-120">Ce comportement est similaire à « streaming » de la sortie.</span><span class="sxs-lookup"><span data-stu-id="2aff0-120">This behavior is analogous to "streaming" the output.</span></span> <span data-ttu-id="2aff0-121">Si le <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> opérateur n’est présent dans la requête, `NotBuffered` conserve l’ordre des éléments de la source.</span><span class="sxs-lookup"><span data-stu-id="2aff0-121">If the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator is present in the query, `NotBuffered` preserves the order of the source elements.</span></span> <span data-ttu-id="2aff0-122">Bien que `NotBuffered` commence à transmettre les résultats dès qu’elles sont disponibles, la durée totale de la production de tous les résultats pourront toujours être supérieure à l’aide d’une des autres options de fusion.</span><span class="sxs-lookup"><span data-stu-id="2aff0-122">Although `NotBuffered` starts yielding results as soon as they're available,, the total time to produce all the results might still be longer than using one of the other merge options.</span></span>  
  
-   `Auto Buffered`  
  
     <span data-ttu-id="2aff0-123">Le <xref:System.Linq.ParallelMergeOptions.AutoBuffered> option entraîne la requête à regrouper des éléments dans une mémoire tampon, puis générer régulièrement le contenu de la mémoire tampon à la fois pour le thread consommateur.</span><span class="sxs-lookup"><span data-stu-id="2aff0-123">The <xref:System.Linq.ParallelMergeOptions.AutoBuffered> option causes the query to collect elements into a buffer and then periodically yield the buffer contents all at once to the consuming thread.</span></span> <span data-ttu-id="2aff0-124">Cela est analogue à transmettre les données sources dans « blocs » au lieu d’utiliser le comportement « diffusion en continu » de `NotBuffered`.</span><span class="sxs-lookup"><span data-stu-id="2aff0-124">This is analogous to yielding the source data in "chunks" instead of using the "streaming" behavior of `NotBuffered`.</span></span> <span data-ttu-id="2aff0-125">`AutoBuffered`peut prendre plus de `NotBuffered` à disposition le premier élément sur le thread consommateur.</span><span class="sxs-lookup"><span data-stu-id="2aff0-125">`AutoBuffered` may take longer than `NotBuffered` to make the first element available on the consuming thread.</span></span> <span data-ttu-id="2aff0-126">La taille de la mémoire tampon et le comportement de transmission exact ne sont pas configurable et peuvent varier en fonction de différents facteurs qui se rapportent à la requête.</span><span class="sxs-lookup"><span data-stu-id="2aff0-126">The size of the buffer and the exact yielding behavior are not configurable and may vary, depending on various factors that relate to the query.</span></span>  
  
-   `FullyBuffered`  
  
     <span data-ttu-id="2aff0-127">La <xref:System.Linq.ParallelMergeOptions.FullyBuffered> option, la sortie de la requête entière à être mis en mémoire tampon avant qu’un des éléments sont transmis.</span><span class="sxs-lookup"><span data-stu-id="2aff0-127">The <xref:System.Linq.ParallelMergeOptions.FullyBuffered> option causes the output of the whole query to be buffered before any of the elements are yielded.</span></span> <span data-ttu-id="2aff0-128">Lorsque vous utilisez cette option, il peut prendre plus de temps avant le premier élément est disponible sur le thread consommateur, mais les résultats complets peuvent être produits plus rapidement qu’avec les autres options.</span><span class="sxs-lookup"><span data-stu-id="2aff0-128">When you use this option, it can take longer before the first element is available on the consuming thread, but the complete results might still be produced faster than by using the other options.</span></span>  
  
## <a name="query-operators-that-support-merge-options"></a><span data-ttu-id="2aff0-129">Opérateurs de requête qui prennent en charge les Options de fusion</span><span class="sxs-lookup"><span data-stu-id="2aff0-129">Query Operators that Support Merge Options</span></span>  
 <span data-ttu-id="2aff0-130">Le tableau suivant répertorie les opérateurs qui prennent en charge tous les modes de l’option de fusion, soumis aux restrictions spécifiées.</span><span class="sxs-lookup"><span data-stu-id="2aff0-130">The following table lists the operators that support all merge option modes, subject to the specified restrictions.</span></span>  
  
|<span data-ttu-id="2aff0-131">Opérateur</span><span class="sxs-lookup"><span data-stu-id="2aff0-131">Operator</span></span>|<span data-ttu-id="2aff0-132">Restrictions</span><span class="sxs-lookup"><span data-stu-id="2aff0-132">Restrictions</span></span>|  
|--------------|------------------|  
|<xref:System.Linq.ParallelEnumerable.AsEnumerable%2A>|<span data-ttu-id="2aff0-133">Aucune</span><span class="sxs-lookup"><span data-stu-id="2aff0-133">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Cast%2A>|<span data-ttu-id="2aff0-134">Aucune</span><span class="sxs-lookup"><span data-stu-id="2aff0-134">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Concat%2A>|<span data-ttu-id="2aff0-135">Requêtes non classées qui ont uniquement un tableau ou une liste source.</span><span class="sxs-lookup"><span data-stu-id="2aff0-135">Non-ordered queries that have an Array or List source only.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.DefaultIfEmpty%2A>|<span data-ttu-id="2aff0-136">Aucune</span><span class="sxs-lookup"><span data-stu-id="2aff0-136">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.OfType%2A>|<span data-ttu-id="2aff0-137">Aucune</span><span class="sxs-lookup"><span data-stu-id="2aff0-137">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Reverse%2A>|<span data-ttu-id="2aff0-138">Requêtes non classées qui ont uniquement un tableau ou une liste source.</span><span class="sxs-lookup"><span data-stu-id="2aff0-138">Non-ordered queries that have an Array or List source only.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Select%2A>|<span data-ttu-id="2aff0-139">Aucune</span><span class="sxs-lookup"><span data-stu-id="2aff0-139">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SelectMany%2A>|<span data-ttu-id="2aff0-140">None</span><span class="sxs-lookup"><span data-stu-id="2aff0-140">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Skip%2A>|<span data-ttu-id="2aff0-141">None</span><span class="sxs-lookup"><span data-stu-id="2aff0-141">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Take%2A>|<span data-ttu-id="2aff0-142">None</span><span class="sxs-lookup"><span data-stu-id="2aff0-142">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Where%2A>|<span data-ttu-id="2aff0-143">Aucune</span><span class="sxs-lookup"><span data-stu-id="2aff0-143">None</span></span>|  
  
 <span data-ttu-id="2aff0-144">Tous les autres opérateurs de requête PLINQ peuvent ignorer les options de fusion fournis par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="2aff0-144">All other PLINQ query operators might ignore user-provided merge options.</span></span> <span data-ttu-id="2aff0-145">Certains opérateurs de requête, par exemple, <xref:System.Linq.ParallelEnumerable.Reverse%2A> et <xref:System.Linq.ParallelEnumerable.OrderBy%2A>, Impossible de générer des éléments jusqu'à ce que tous les produits et réorganisés.</span><span class="sxs-lookup"><span data-stu-id="2aff0-145">Some query operators, for example, <xref:System.Linq.ParallelEnumerable.Reverse%2A> and <xref:System.Linq.ParallelEnumerable.OrderBy%2A>, cannot yield any elements until all have been produced and reordered.</span></span> <span data-ttu-id="2aff0-146">Par conséquent, lorsque <xref:System.Linq.ParallelMergeOptions> est utilisé dans une requête qui contient également un opérateur tel que <xref:System.Linq.ParallelEnumerable.Reverse%2A>, le comportement de fusion n’est pas appliqué dans la requête jusqu'à ce que cet opérateur a produit ses résultats.</span><span class="sxs-lookup"><span data-stu-id="2aff0-146">Therefore, when <xref:System.Linq.ParallelMergeOptions> is used in a query that also contains an operator such as <xref:System.Linq.ParallelEnumerable.Reverse%2A>, the merge behavior will not be applied in the query until after that operator has produced its results.</span></span>  
  
 <span data-ttu-id="2aff0-147">La capacité de certains opérateurs à gérer les options de fusion varie selon le type de la séquence source et si le <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> opérateur a été utilisé précédemment dans la requête.</span><span class="sxs-lookup"><span data-stu-id="2aff0-147">The ability of some operators to handle merge options depends on the type of the source sequence, and whether the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator was used earlier in the query.</span></span> <span data-ttu-id="2aff0-148"><xref:System.Linq.ParallelEnumerable.ForAll%2A>est toujours <xref:System.Linq.ParallelMergeOptions.NotBuffered> ; il transmet immédiatement ses éléments.</span><span class="sxs-lookup"><span data-stu-id="2aff0-148"><xref:System.Linq.ParallelEnumerable.ForAll%2A> is always <xref:System.Linq.ParallelMergeOptions.NotBuffered> ; it yields its elements immediately.</span></span> <span data-ttu-id="2aff0-149"><xref:System.Linq.ParallelEnumerable.OrderBy%2A>est toujours <xref:System.Linq.ParallelMergeOptions.FullyBuffered>; il doit trier l’intégralité de la liste avant la transmission.</span><span class="sxs-lookup"><span data-stu-id="2aff0-149"><xref:System.Linq.ParallelEnumerable.OrderBy%2A> is always <xref:System.Linq.ParallelMergeOptions.FullyBuffered>; it must sort the whole list before it yields.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2aff0-150">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="2aff0-150">See Also</span></span>  
 [<span data-ttu-id="2aff0-151">Parallel LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="2aff0-151">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)  
 [<span data-ttu-id="2aff0-152">Comment : spécifier des options de fusion en PLINQ</span><span class="sxs-lookup"><span data-stu-id="2aff0-152">How to: Specify Merge Options in PLINQ</span></span>](../../../docs/standard/parallel-programming/how-to-specify-merge-options-in-plinq.md)
