---
title: "Gestion des exceptions (bibliothèque parallèle de tâches)"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: tasks, exceptions
ms.assetid: beb51e50-9061-4d3d-908c-56a4f7c2e8c1
caps.latest.revision: "21"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: e62498376d321d8ff22a53315b9d5f18a8865056
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/18/2017
---
# <a name="exception-handling-task-parallel-library"></a><span data-ttu-id="30987-102">Gestion des exceptions (bibliothèque parallèle de tâches)</span><span class="sxs-lookup"><span data-stu-id="30987-102">Exception Handling (Task Parallel Library)</span></span>
<span data-ttu-id="30987-103">Les exceptions non gérées levées par le code utilisateur s’exécutant à l’intérieur d’une tâche sont propagées vers le thread appelant, sauf dans certains scénarios décrits plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="30987-103">Unhandled exceptions that are thrown by user code that is running inside a task are propagated back to the calling thread, except in certain scenarios that are described later in this topic.</span></span> <span data-ttu-id="30987-104">Les exceptions sont propagées lorsque vous utilisez la méthode statique ou d’instance <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> ou <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` méthodes et que vous les gérez en incluant l’appel dans un `try` / `catch` instruction.</span><span class="sxs-lookup"><span data-stu-id="30987-104">Exceptions are propagated when you use one of the static or instance <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> or <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` methods, and you handle them by enclosing the call in a `try`/`catch` statement.</span></span> <span data-ttu-id="30987-105">Si une tâche est le parent de tâches enfants attachées ou si vous attendez plusieurs tâches, plusieurs exceptions peuvent être levées.</span><span class="sxs-lookup"><span data-stu-id="30987-105">If a task is the parent of attached child tasks, or if you are waiting on multiple tasks, multiple exceptions could be thrown.</span></span>  
  
 <span data-ttu-id="30987-106">Pour propager toutes les exceptions vers le thread appelant, l’infrastructure de la tâche les encapsule dans une instance <xref:System.AggregateException> .</span><span class="sxs-lookup"><span data-stu-id="30987-106">To propagate all the exceptions back to the calling thread, the Task infrastructure wraps them in an <xref:System.AggregateException> instance.</span></span> <span data-ttu-id="30987-107">L’exception <xref:System.AggregateException> possède une propriété <xref:System.AggregateException.InnerExceptions%2A> qu’il est possible d’énumérer pour examiner toutes les exceptions d’origine levées et gérer (ou non) individuellement chacune d’elles.</span><span class="sxs-lookup"><span data-stu-id="30987-107">The <xref:System.AggregateException> exception has an <xref:System.AggregateException.InnerExceptions%2A> property that can be enumerated to examine all the original exceptions that were thrown, and handle (or not handle) each one individually.</span></span> <span data-ttu-id="30987-108">Vous pouvez également gérer les exceptions d’origine à l’aide de la <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="30987-108">You can also handle the original exceptions by using the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="30987-109">Même si une seule exception est levée, elle est encapsulée dans une exception <xref:System.AggregateException> , comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="30987-109">Even if only one exception is thrown, it is still wrapped in an <xref:System.AggregateException> exception, as the following example shows.</span></span>  
  
 [!code-csharp[TPL_Exceptions#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling21.cs#21)]
 [!code-vb[TPL_Exceptions#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling21.vb#21)]  
  
 <span data-ttu-id="30987-110">Vous pouvez éviter une exception non gérée en interceptant l’exception <xref:System.AggregateException> et en n’observant aucune des exceptions internes.</span><span class="sxs-lookup"><span data-stu-id="30987-110">You could avoid an unhandled exception by just catching the <xref:System.AggregateException> and not observing any of the inner exceptions.</span></span> <span data-ttu-id="30987-111">Toutefois, cela n’est pas recommandé car cela revient à intercepter le type <xref:System.Exception> de base dans des scénarios non parallèles.</span><span class="sxs-lookup"><span data-stu-id="30987-111">However, we recommend that you do not do this because it is analogous to catching the base <xref:System.Exception> type in non-parallel scenarios.</span></span> <span data-ttu-id="30987-112">Intercepter une exception sans prendre de mesures spécifiques de récupération peut laisser votre programme dans un état indéterminé.</span><span class="sxs-lookup"><span data-stu-id="30987-112">To catch an exception without taking specific actions to recover from it can leave your program in an indeterminate state.</span></span>  
  
 <span data-ttu-id="30987-113">Si vous ne voulez pas appeler le <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> ou <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` méthode pour attendre la fin d’une tâche, vous pouvez également récupérer la <xref:System.AggregateException> exception à partir de la tâche <xref:System.Threading.Tasks.Task.Exception%2A> propriété, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="30987-113">If you do not want to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> or <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` method to wait for a task's completion, you can also retrieve the <xref:System.AggregateException> exception from the task's <xref:System.Threading.Tasks.Task.Exception%2A> property, as the following example shows.</span></span> <span data-ttu-id="30987-114">Pour plus d’informations, consultez la section [Observation d’exceptions à l’aide de la propriété Task.Exception](#ExceptionProp) dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="30987-114">For more information, see the [Observing Exceptions By Using the Task.Exception Property](#ExceptionProp) section in this topic.</span></span>  
  
 [!code-csharp[TPL_Exceptions#29](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling22.cs#29)]
 [!code-vb[TPL_Exceptions#29](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling22.vb#29)]  
  
 <span data-ttu-id="30987-115">Si vous n’attendez pas une tâche qui propage une exception ou accédez à sa propriété <xref:System.Threading.Tasks.Task.Exception%2A> , l’exception est transmise d’après la stratégie de l’exception .NET lorsque la tâche est récupérée par le garbage collector.</span><span class="sxs-lookup"><span data-stu-id="30987-115">If you do not wait on a task that propagates an exception, or access its <xref:System.Threading.Tasks.Task.Exception%2A> property, the exception is escalated according to the .NET exception policy when the task is garbage-collected.</span></span>  
  
 <span data-ttu-id="30987-116">Lorsque les exceptions sont autorisées à se propager vers le thread joint, il est possible qu’une tâche continue à traiter des éléments après que l’exception a été levée.</span><span class="sxs-lookup"><span data-stu-id="30987-116">When exceptions are allowed to bubble up back to the joining thread, it is possible that a task may continue to process some items after the exception is raised.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30987-117">Quand l'option Uniquement mon code est activée, Visual Studio, dans certains cas, peut s'arrêter sur la ligne qui lève l'exception et afficher un message d'erreur indiquant que l'exception n'est pas gérée par le code utilisateur.</span><span class="sxs-lookup"><span data-stu-id="30987-117">When "Just My Code" is enabled, Visual Studio in some cases will break on the line that throws the exception and display an error message that says "exception not handled by user code."</span></span> <span data-ttu-id="30987-118">Cette erreur est sans gravité.</span><span class="sxs-lookup"><span data-stu-id="30987-118">This error is benign.</span></span> <span data-ttu-id="30987-119">Vous pouvez appuyer sur F5 pour continuer et voir le comportement de gestion des exceptions qui est illustré dans ces exemples.</span><span class="sxs-lookup"><span data-stu-id="30987-119">You can press F5 to continue and see the exception-handling behavior that is demonstrated in these examples.</span></span> <span data-ttu-id="30987-120">Pour empêcher Visual Studio de s’arrêter sur la première erreur, il suffit de désactiver la case à cocher **Autoriser uniquement mon code** sous **Outils, Options, Débogage, Général**.</span><span class="sxs-lookup"><span data-stu-id="30987-120">To prevent Visual Studio from breaking on the first error, just uncheck the **Enable Just My Code** checkbox under **Tools, Options, Debugging, General**.</span></span>  
  
## <a name="attached-child-tasks-and-nested-aggregateexceptions"></a><span data-ttu-id="30987-121">Tâches enfants attachées et exceptions AggregateException imbriquées</span><span class="sxs-lookup"><span data-stu-id="30987-121">Attached Child Tasks and Nested AggregateExceptions</span></span>  
 <span data-ttu-id="30987-122">Si une tâche a une tâche enfant attachée qui lève une exception, cette exception est encapsulée dans une exception <xref:System.AggregateException> avant d’être propagée vers la tâche parent, qui encapsule cette exception dans sa propre exception <xref:System.AggregateException> avant de la propager vers le thread appelant.</span><span class="sxs-lookup"><span data-stu-id="30987-122">If a task has an attached child task that throws an exception, that exception is wrapped in an <xref:System.AggregateException> before it is propagated to the parent task, which wraps that exception in its own <xref:System.AggregateException> before it propagates it back to the calling thread.</span></span> <span data-ttu-id="30987-123">Dans ce cas, le <xref:System.AggregateException.InnerExceptions%2A> propriété de la <xref:System.AggregateException> exception interceptée à la <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> ou <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` ou <xref:System.Threading.Tasks.Task.WaitAny%2A> ou <xref:System.Threading.Tasks.Task.WaitAll%2A> méthode contient un ou plusieurs <xref:System.AggregateException> instances, pas le exceptions d’origine ayant provoqué l’erreur.</span><span class="sxs-lookup"><span data-stu-id="30987-123">In such cases, the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> exception that is caught at the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> or <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` or <xref:System.Threading.Tasks.Task.WaitAny%2A> or <xref:System.Threading.Tasks.Task.WaitAll%2A> method contains one or more <xref:System.AggregateException> instances, not the original exceptions that caused the fault.</span></span> <span data-ttu-id="30987-124">Pour éviter d’avoir à itérer imbriqués <xref:System.AggregateException> des exceptions, vous pouvez utiliser la <xref:System.AggregateException.Flatten%2A> méthode pour supprimer tous les imbriqué <xref:System.AggregateException> des exceptions, afin que le <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> propriété contient les exceptions d’origine.</span><span class="sxs-lookup"><span data-stu-id="30987-124">To avoid having to iterate over nested <xref:System.AggregateException> exceptions, you can use the <xref:System.AggregateException.Flatten%2A> method to remove all the nested <xref:System.AggregateException> exceptions, so that the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains the original exceptions.</span></span> <span data-ttu-id="30987-125">Dans l’exemple suivant, les instances <xref:System.AggregateException> imbriquées sont aplaties et gérées en une seule boucle.</span><span class="sxs-lookup"><span data-stu-id="30987-125">In the following example, nested <xref:System.AggregateException> instances are flattened and handled in just one loop.</span></span>  
  
 [!code-csharp[TPL_Exceptions#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/flatten2.cs#22)]
 [!code-vb[TPL_Exceptions#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/flatten2.vb#22)]  
  
 <span data-ttu-id="30987-126">Vous pouvez également utiliser le <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> méthode lever les exceptions internes de multiples à <xref:System.AggregateException> levées par plusieurs tâches dans une seule des instances <xref:System.AggregateException> instance, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="30987-126">You can also use the <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> method to rethrow the inner exceptions from multiple <xref:System.AggregateException> instances thrown by multiple tasks in a single <xref:System.AggregateException> instance, as the following example shows.</span></span>  
  
 [!code-csharp[TPL_Exceptions#13](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions2.cs#13)]
 [!code-vb[TPL_Exceptions#13](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions2.vb#13)]  
  
## <a name="exceptions-from-detached-child-tasks"></a><span data-ttu-id="30987-127">Exceptions des tâches enfants détachées</span><span class="sxs-lookup"><span data-stu-id="30987-127">Exceptions from Detached Child Tasks</span></span>  
 <span data-ttu-id="30987-128">Par défaut, les tâches enfants sont créées détachées.</span><span class="sxs-lookup"><span data-stu-id="30987-128">By default, child tasks are created as detached.</span></span> <span data-ttu-id="30987-129">Les exceptions levées depuis des tâches détachées doivent être gérées ou levées à nouveau dans la tâche parent immédiate. Elles ne sont pas propagées vers le thread appelant de la même façon que les tâches enfants attachées.</span><span class="sxs-lookup"><span data-stu-id="30987-129">Exceptions thrown from detached tasks must be handled or rethrown in the immediate parent task; they are not propagated back to the calling thread in the same way as attached child tasks propagated back.</span></span> <span data-ttu-id="30987-130">Le parent le plus haut peut lever à nouveau manuellement une exception à partir d’un enfant détaché pour l’encapsuler dans une exception <xref:System.AggregateException> et la propager vers le thread appelant.</span><span class="sxs-lookup"><span data-stu-id="30987-130">The topmost parent can manually rethrow an exception from a detached child to cause it to be wrapped in an <xref:System.AggregateException> and propagated back to the calling thread.</span></span>  
  
 [!code-csharp[TPL_Exceptions#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/detached21.cs#23)]
 [!code-vb[TPL_Exceptions#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/detached21.vb#23)]  
  
 <span data-ttu-id="30987-131">Même si vous utilisez une continuation pour observer une exception dans une tâche enfant, l’exception doit toujours être observée par la tâche parent.</span><span class="sxs-lookup"><span data-stu-id="30987-131">Even if you use a continuation to observe an exception in a child task, the exception still must be observed by the parent task.</span></span>  
  
## <a name="exceptions-that-indicate-cooperative-cancellation"></a><span data-ttu-id="30987-132">Exceptions indiquant une annulation coopérative</span><span class="sxs-lookup"><span data-stu-id="30987-132">Exceptions That Indicate Cooperative Cancellation</span></span>  
 <span data-ttu-id="30987-133">Lorsque le code utilisateur d’une tâche répond à une demande d’annulation, la procédure correcte consiste à lever une exception <xref:System.OperationCanceledException> qui passe le jeton d’annulation sur lequel la demande a été communiquée.</span><span class="sxs-lookup"><span data-stu-id="30987-133">When user code in a task responds to a cancellation request, the correct procedure is to throw an <xref:System.OperationCanceledException> passing in the cancellation token on which the request was communicated.</span></span> <span data-ttu-id="30987-134">Avant d’essayer de propager l’exception, l’instance de tâche compare le jeton de l’exception à celui qui lui a été passé lors de sa création.</span><span class="sxs-lookup"><span data-stu-id="30987-134">Before it attempts to propagate the exception, the task instance compares the token in the exception to the one that was passed to it when it was created.</span></span> <span data-ttu-id="30987-135">S’ils sont identiques, la tâche propage une exception <xref:System.Threading.Tasks.TaskCanceledException> encapsulée dans l’exception <xref:System.AggregateException>, et cette dernière peut être affichée au moment d’examiner les exceptions internes.</span><span class="sxs-lookup"><span data-stu-id="30987-135">If they are the same, the task propagates a <xref:System.Threading.Tasks.TaskCanceledException> wrapped in the <xref:System.AggregateException>, and it can be seen when the inner exceptions are examined.</span></span> <span data-ttu-id="30987-136">Toutefois, si le thread appelant n’est pas en attente sur la tâche, cette exception spécifique n’est pas propagée.</span><span class="sxs-lookup"><span data-stu-id="30987-136">However, if the calling thread is not waiting on the task, this specific exception will not be propagated.</span></span> <span data-ttu-id="30987-137">Pour plus d'informations, consultez [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md).</span><span class="sxs-lookup"><span data-stu-id="30987-137">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
 [!code-csharp[TPL_Exceptions#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptions.cs#4)]
 [!code-vb[TPL_Exceptions#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/tpl_exceptions.vb#4)]  
  
## <a name="using-the-handle-method-to-filter-inner-exceptions"></a><span data-ttu-id="30987-138">Utilisation de la méthode Handle pour filtrer les exceptions internes</span><span class="sxs-lookup"><span data-stu-id="30987-138">Using the Handle Method to Filter Inner Exceptions</span></span>  
 <span data-ttu-id="30987-139">Vous pouvez utiliser la <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> méthode pour filtrer les exceptions que vous pouvez traiter comme « gérées » sans utiliser d’autre logique.</span><span class="sxs-lookup"><span data-stu-id="30987-139">You can use the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to filter out exceptions that you can treat as "handled" without using any further logic.</span></span> <span data-ttu-id="30987-140">Dans le délégué utilisateur fourni à la <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> (méthode), vous pouvez examiner le type d’exception, son <xref:System.Exception.Message%2A> propriété, ou toute autre information le concernant qui vous permettra de déterminer si elle est sans gravité.</span><span class="sxs-lookup"><span data-stu-id="30987-140">In the user delegate that is supplied to the <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> method, you can examine the exception type, its <xref:System.Exception.Message%2A> property, or any other information about it that will let you determine whether it is benign.</span></span> <span data-ttu-id="30987-141">Toutes les exceptions pour lesquelles le délégué retourne `false` sont levées dans une nouvelle <xref:System.AggregateException> instance immédiatement après le <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> le retour de méthode.</span><span class="sxs-lookup"><span data-stu-id="30987-141">Any exceptions for which the delegate returns `false` are rethrown in a new <xref:System.AggregateException> instance immediately after the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method returns.</span></span>  
  
 <span data-ttu-id="30987-142">L’exemple suivant est fonctionnellement équivalent au premier exemple dans cette rubrique, qui examine chaque exception de la <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> collection.</span><span class="sxs-lookup"><span data-stu-id="30987-142">The following example is functionally equivalent to the first example in this topic, which examines each exception in the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> collection.</span></span>  <span data-ttu-id="30987-143">Au lieu de cela, ce gestionnaire d’exceptions appelle la <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> objet de méthode pour chaque exception et les seules exceptions levées qui ne sont pas `CustomException` instances.</span><span class="sxs-lookup"><span data-stu-id="30987-143">Instead, this exception handler calls the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method object for each exception, and only rethrows exceptions that are not `CustomException` instances.</span></span>  
  
 [!code-csharp[TPL_Exceptions#26](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handlemethod21.cs#26)]
 [!code-vb[TPL_Exceptions#26](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handlemethod21.vb#26)]  
  
 <span data-ttu-id="30987-144">Voici un exemple plus complet qui utilise le <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> méthode pour fournir une gestion spéciale pour un <xref:System.UnauthorizedAccessException> exception lors de l’énumération des fichiers.</span><span class="sxs-lookup"><span data-stu-id="30987-144">The following is a more complete example that uses the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to provide special handling for an <xref:System.UnauthorizedAccessException> exception when enumerating files.</span></span>  
  
 [!code-csharp[TPL_Exceptions#12](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions.cs#12)]
 [!code-vb[TPL_Exceptions#12](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions.vb#12)]  
  
<a name="ExceptionProp"></a>   
## <a name="observing-exceptions-by-using-the-taskexception-property"></a><span data-ttu-id="30987-145">Observation d’exceptions à l’aide de la propriété Task.Exception</span><span class="sxs-lookup"><span data-stu-id="30987-145">Observing Exceptions by Using the Task.Exception Property</span></span>  
 <span data-ttu-id="30987-146">Si une tâche se termine dans le <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> état, son <xref:System.Threading.Tasks.Task.Exception%2A> propriété peut être examinée pour découvrir quelle exception a provoqué l’erreur.</span><span class="sxs-lookup"><span data-stu-id="30987-146">If a task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its <xref:System.Threading.Tasks.Task.Exception%2A> property can be examined to discover which specific exception caused the fault.</span></span> <span data-ttu-id="30987-147">Un bon moyen d’observer la propriété <xref:System.Threading.Tasks.Task.Exception%2A> consiste à utiliser une continuation qui s’exécute uniquement en cas d’erreur de la tâche antérieure, comme indiqué dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="30987-147">A good way to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property is to use a continuation that runs only if the antecedent task faults, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Exceptions#27](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptionprop21.cs#27)]
 [!code-vb[TPL_Exceptions#27](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/exceptionprop21.vb#27)]  
  
 <span data-ttu-id="30987-148">Dans une application réelle, le délégué de continuation peut consigner des informations détaillées sur l’exception et générer de nouvelles tâches pour se remettre de l’exception.</span><span class="sxs-lookup"><span data-stu-id="30987-148">In a real application, the continuation delegate could log detailed information about the exception and possibly spawn new tasks to recover from the exception.</span></span>  
  
## <a name="unobservedtaskexception-event"></a><span data-ttu-id="30987-149">Événement UnobservedTaskException</span><span class="sxs-lookup"><span data-stu-id="30987-149">UnobservedTaskException Event</span></span>  
 <span data-ttu-id="30987-150">Dans certains scénarios, tels que l’hébergement de plug-ins non approuvés, des exceptions sans gravité sont courantes. Il peut s’avérer trop difficile de toutes les observer manuellement.</span><span class="sxs-lookup"><span data-stu-id="30987-150">In some scenarios, such as when hosting untrusted plug-ins, benign exceptions might be common, and it might be too difficult to manually observe them all.</span></span> <span data-ttu-id="30987-151">Dans ce cas, vous pouvez gérer le <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> événement.</span><span class="sxs-lookup"><span data-stu-id="30987-151">In these cases, you can handle the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="30987-152">Le <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> instance qui est passé à votre gestionnaire peut être utilisée pour empêcher l’exception non prise en charge soient propagées vers le thread joint.</span><span class="sxs-lookup"><span data-stu-id="30987-152">The <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> instance that is passed to your handler can be used to prevent the unobserved exception from being propagated back to the joining thread.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="30987-153">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="30987-153">See Also</span></span>  
 [<span data-ttu-id="30987-154">La bibliothèque parallèle de tâches</span><span class="sxs-lookup"><span data-stu-id="30987-154">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)
