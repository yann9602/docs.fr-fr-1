---
title: "Flux de données (bibliothèque parallèle de tâches)"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
caps.latest.revision: "22"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 73933c5f171881b5b3a2479aabdb26d1abd58cfc
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/18/2017
---
# <a name="dataflow-task-parallel-library"></a>Flux de données (bibliothèque parallèle de tâches)
<a name="top"></a> La bibliothèque parallèle de tâches (TPL) fournit des composants de flux de données destinés à augmenter la robustesse des applications prenant en charge l’accès concurrentiel. Ces composants de flux de données sont regroupés sous le nom de *bibliothèque de flux de données TPL*. Ce modèle de flux de données favorise la programmation basée sur les acteurs en fournissant une transmission de messages in-process pour les flux de données à granularité grossière et les tâches de traitement "pipeline". Les composants de flux de données reposent sur les types et l'infrastructure de planification de la bibliothèque parallèle de tâches, et s'intègrent à la prise en charge des langages C#, [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)] et F# de la programmation asynchrone. Ces composants de flux de données sont utiles quand vous avez plusieurs opérations qui doivent communiquer entre elles de façon asynchrone ou quand vous voulez traiter les données à mesure qu'elles deviennent disponibles. Prenons par exemple une application qui traite les données d'image d'une webcam. En utilisant le modèle de flux de données, l'application peut traiter les trames d'images à mesure qu'elles deviennent disponibles. Si l’application améliore les trames d’images, par exemple, en effectuant la correction de la lumière ou des yeux rouges, vous pouvez créer un *pipeline* de composants de flux de données. Chaque étape du pipeline peut utiliser plusieurs fonctionnalités de parallélisme à granularité grossière, telles que les fonctionnalités fournies par la bibliothèque TPL qui permettent de transformer les images.  
  
 Ce document fournit une vue d'ensemble de la bibliothèque de flux de données TPL. Il décrit le modèle de programmation et les types de blocs de flux de données prédéfinis, et explique comment configurer des blocs de flux de données pour répondre aux besoins de vos applications.  
  
> [!TIP]
>  La bibliothèque de flux de données TPL (espace de noms <xref:System.Threading.Tasks.Dataflow?displayProperty=nameWithType>) n'est pas distribuée avec le [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Pour installer l'espace de noms <xref:System.Threading.Tasks.Dataflow>, ouvrez votre projet dans [!INCLUDE[vs_dev11_long](../../../includes/vs-dev11-long-md.md)], dans le menu Projet choisissez **Gérer les packages NuGet**, puis recherchez en ligne le package `Microsoft.Tpl.Dataflow`.  
  
 Ce document contient les sections suivantes :  
  
-   [Modèle de programmation](#model)  
  
-   [Types de blocs de flux de données prédéfinis](#predefined_types)  
  
-   [Configuration du comportement des blocs de flux de données](#behavior)  
  
-   [Blocs de flux de données personnalisés](#custom)  
  
<a name="model"></a>   
## <a name="programming-model"></a>Modèle de programmation  
 La bibliothèque de flux de données TPL constitue une base pour la transmission de messages et la parallélisation des applications nécessitant une utilisation importante du processeur et des E/S, et ayant un débit élevé et une faible latence. Elle permet également de contrôler explicitement la manière dont les données sont mises en mémoire tampon et se déplacent sur le système. Pour mieux comprendre le modèle de programmation de flux de données, imaginez une application qui charge des images à partir du disque de manière asynchrone et crée un composite de ces images. Les modèles de programmation traditionnels requièrent généralement l'utilisation de rappels et d'objets de synchronisation, tels que des verrous, pour coordonner les tâches et accéder aux données partagées. À l'aide du modèle de programmation de flux de données, vous pouvez créer des objets de flux de données qui traitent les images à mesure qu'elles sont lues à partir du disque. Sous le modèle de flux de données, vous déclarez la manière dont sont traitées les données quand elles deviennent disponibles, ainsi que les éventuelles dépendances qui existent entre les données. Le runtime gère les dépendances entre les données, ce qui vous évite d'avoir à synchroniser l'accès aux données partagées. De plus, étant donné que le runtime planifie les tâches en fonction de l'arrivée asynchrone des données, le flux de données peut améliorer la réactivité et le débit grâce à une gestion efficace des threads sous-jacents. Vous trouverez un exemple d’utilisation du modèle de programmation de flux de données pour implémenter le traitement d’image dans une application Windows Forms sur la page [Procédure pas à pas : utiliser les flux de données dans une application Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Sources et cibles  
 La bibliothèque de flux de données TPL comprend des *blocs de flux de données*, structures de données qui mettent les données en mémoire tampon et les traitent. La bibliothèque parallèle de tâches définit trois types de blocs de flux de données : les *blocs sources*, les *blocs cibles* et les *blocs propagateurs*. Un bloc source agit comme une source de données et peut donc être lu. Un bloc cible joue le rôle de récepteur de données, il est donc possible d'y écrire. Un bloc propagateur agit à la fois comme un bloc source et un bloc cible, et peut donc faire l'objet d'une lecture et d'une écriture. La bibliothèque parallèle de tâches définit l'interface <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> pour représenter les sources, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> pour représenter les cibles, et <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> pour représenter les propagateurs. <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> hérite des deux <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> et de <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 La bibliothèque de flux de données TPL fournit plusieurs types de blocs de flux de données prédéfinis qui implémentent les interfaces <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> et <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602>. Ces types de blocs de flux de données sont décrits dans ce document dans la section [Types de blocs de flux de données prédéfinis](#predefined_types).  
  
### <a name="connecting-blocks"></a>Connexion des blocs  
 Vous pouvez aussi connecter des blocs de flux de données pour former des *pipelines*, qui sont des séquences linéaires de blocs de flux de données, ou bien des *réseaux*, qui sont des graphiques de blocs de flux de données. Un pipeline est une forme de réseau. Dans un pipeline ou un réseau, les sources propagent des données de manière asynchrone vers les cibles à mesure que les données deviennent disponibles. La méthode <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> lie un bloc de flux de données source à un bloc cible. Une source peut être liée à zéro, une ou plusieurs cibles. Une cible peut être liée à zéro, une ou plusieurs sources. Vous pouvez ajouter des blocs de flux de données à un pipeline ou en supprimer de manière simultanée. Les types de blocs de flux de données prédéfinis gèrent tous les aspects liés à la sécurité des threads pour les liaisons et les annulations de liaison.  
  
 Vous trouverez un exemple de connexion de blocs de flux de données permettant de former un pipeline de base sur la page [Procédure pas à pas : créer un pipeline de flux de données](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md). Vous trouverez un exemple de connexion de blocs de flux de données permettant de former un réseau plus complexe sur la page [Procédure pas à pas : utiliser les flux de données dans une application Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md). Vous trouverez un exemple de dissociation d’une cible et d’une source après que la source a envoyé un message à la cible sur la page [Guide pratique : dissocier des blocs de flux de données](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Filtrage  
 Quand vous appelez la méthode <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> pour lier une source à une cible, vous pouvez fournir un délégué qui détermine si le bloc cible accepte ou rejette les messages en fonction de la valeur de ce message. Ce mécanisme de filtrage permet de garantir qu'un bloc de flux de données recevra uniquement certaines valeurs. Pour la plupart des types de blocs de flux de données prédéfinis, si un bloc source est connecté à plusieurs blocs cibles, quand un bloc cible rejette un message, la source envoie le message à la cible suivante. L'ordre dans lequel une source envoie des messages aux cibles est défini par la source et peut varier en fonction du type de la source. La plupart des types de blocs sources arrêtent d'envoyer un message une fois celui-ci accepté par une cible. La classe <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> est une exception. En effet, celle-ci envoie chaque message à l'ensemble des cibles, même si celles-ci le rejettent. Vous trouverez un exemple d’utilisation du filtrage permettant de traiter uniquement certains messages sur la page [Procédure pas à pas : utiliser les flux de données dans une application Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
>  Étant donné que chaque type de bloc de flux de données source prédéfini garantit la propagation des messages dans l'ordre où ils sont reçus, tous les messages doivent être lus depuis le bloc source avant que celui-ci ne puisse traiter le message suivant. Par conséquent, quand vous utilisez le filtrage pour connecter plusieurs cibles à une source, assurez-vous que chaque message soit reçu par au moins un bloc cible. Sinon, votre application peut se bloquer.  
  
### <a name="message-passing"></a>Transmission de messages  
 Le modèle de programmation de flux de données est lié au concept de *transmission de messages*, durant laquelle les composants indépendants d’un programme communiquent entre eux à l’aide de messages. Une façon de propager des messages entre composants d’application consiste à appeler la <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> et <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> des méthodes pour envoyer des messages aux blocs de flux de données cibles (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> agit de façon synchrone ; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> asynchrone) et le <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, et <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> méthodes pour recevoir des messages à partir de blocs de code source. Vous pouvez combiner ces méthodes à des pipelines ou réseaux de flux de données en envoyant des données d'entrée au nœud principal (bloc cible) et en recevant des données de sortie de la part du nœud terminal du pipeline ou des nœuds terminaux du réseau (un ou plusieurs blocs sources). Vous pouvez également utiliser la méthode <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> pour lire la première des sources fournies qui contient des données et effectuer des actions sur ces données.  
  
 Blocs sources envoient des données aux blocs cibles en appelant le <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType> (méthode). Le bloc cible peut répondre à un message envoyé de trois manières : il peut accepter le message, le refuser ou le différer. Quand la cible accepte le message, la méthode <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> retourne <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>. Quand la cible refuse le message, la méthode <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> retourne <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>. Quand la cible décide de ne plus recevoir de messages de la source, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> renvoie <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>. Les types de blocs sources prédéfinis n'envoient plus de messages aux cibles liées après réception d'une telle valeur et sont automatiquement dissociés de ces cibles.  
  
 Quand un bloc cible diffère le message pour une utilisation ultérieure, la méthode <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> retourne <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>. Un bloc cible qui diffère un message peut appeler ultérieurement la <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> méthode pour tenter de réserver le message envoyé. À ce stade, soit le message est toujours disponible et peut être utilisé par le bloc cible, soit le message a été utilisé par une autre cible. Lorsque le bloc cible ultérieurement nécessite le message ou n’a plus besoin du message, il appelle la <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> (méthode), respectivement. La réservation de messages est généralement utilisée par les types de blocs de flux de données qui fonctionnent en mode non gourmand. Le mode non gourmand est expliqué plus loin dans ce document. Plutôt que de réserver un message différé, un bloc cible peut également utiliser la méthode <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> pour tenter d'utiliser directement le message différé.  
  
### <a name="dataflow-block-completion"></a>Achèvement des blocs de flux de données  
 Les blocs de flux de données prennent également en charge le concept *d’achèvement*. Un bloc de flux de données qui est achevé n'effectue plus aucune tâche. Chaque bloc de flux de données est associé à un <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> objet, appelé un *tâche d’achèvement*, qui représente l’état d’achèvement du bloc. Étant donné que vous pouvez attendre qu'un objet <xref:System.Threading.Tasks.Task> soit terminé, vous pouvez, à l'aide de tâches d'achèvement, attendre l'achèvement d'un ou plusieurs nœuds terminaux d'un réseau de flux de données. L'interface <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> définit la méthode <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> qui informe le bloc de flux de données qu'une requête exige son achèvement, ainsi que la propriété <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> qui retourne la tâche d'achèvement pour le bloc de flux de données. <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> et <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> héritent de l'interface <xref:System.Threading.Tasks.Dataflow.IDataflowBlock>.  
  
 Il existe deux façons de déterminer si un bloc de flux de données s'est terminé sans erreur, si une ou plusieurs erreurs se sont produites ou s'il a été annulé. La première consiste à appeler la <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> méthode sur la tâche d’achèvement dans un `try` - `catch` bloc (`Try` - `Catch` en Visual Basic). Dans l'exemple suivant, un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objet lève une exception <xref:System.ArgumentOutOfRangeException> si sa valeur d'entrée est inférieure à zéro. L'exception <xref:System.AggregateException> est levée quand cet exemple appelle <xref:System.Threading.Tasks.Task.Wait%2A> sur la tâche d'achèvement. <xref:System.ArgumentOutOfRangeException> est accessible via la propriété <xref:System.AggregateException.InnerExceptions%2A> de l'objet <xref:System.AggregateException>.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 Dans cet exemple, une exception n'est pas gérée dans le délégué d'un bloc de flux de données d'exécution. Nous vous recommandons de gérer les exceptions dans le corps des blocs. Toutefois, si vous ne parvenez pas à le faire, le bloc se comportera comme s'il avait été annulé et ne traitera pas les messages entrants.  
  
 Quand un bloc de flux de données est annulé de manière explicite, l'objet <xref:System.AggregateException> contient <xref:System.OperationCanceledException> dans la propriété <xref:System.AggregateException.InnerExceptions%2A>. Pour plus d'informations sur l'annulation de flux de données, consultez la section "Permettre les annulations" plus loin dans ce document.  
  
 La deuxième méthode permettant de déterminer l'état d'achèvement d'un bloc de flux de données est d'utiliser une continuation de la tâche d'achèvement, ou d'utiliser les fonctionnalités de langage asynchrones de C# et de Visual Basic pour attendre la tâche d'achèvement de manière asynchrone. Le délégué que vous fournissez à la méthode <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> prend un objet <xref:System.Threading.Tasks.Task> qui représente la tâche précédente. Dans le cas de la propriété <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A>, le délégué de la continuation prend la tâche d'achèvement. L'exemple suivant ressemble au précédent, mais il utilise également la méthode <xref:System.Threading.Tasks.Task.ContinueWith%2A> pour créer une tâche d'achèvement qui imprime l'état de l'opération globale de flux de données.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 Vous pouvez également utiliser des propriétés telles que <xref:System.Threading.Tasks.Task.IsCanceled%2A> dans le corps de la tâche de continuation pour obtenir des informations supplémentaires sur l'état d'achèvement d'un bloc de flux de données. Pour plus d’informations sur les tâches de continuation et pour savoir en quoi elles se rapportent à l’annulation et à la gestion des erreurs, consultez les pages [Chaînage des tâches à l’aide de tâches de continuation](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md), [Annulation de tâches](../../../docs/standard/parallel-programming/task-cancellation.md), [Gestion des exceptions](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md) et [NIB : Guide pratique : prendre en charge les exceptions levées par des tâches](http://msdn.microsoft.com/en-us/d6c47ec8-9de9-4880-beb3-ff19ae51565d).  
  
 [[retour en haut](#top)]  
  
<a name="predefined_types"></a>   
## <a name="predefined-dataflow-block-types"></a>Types de blocs de flux de données prédéfinis  
 La bibliothèque de flux de données TPL fournit plusieurs types de blocs de flux de données prédéfinis. Ces types sont répartis en trois catégories : *blocs de mise en mémoire tampon*, *blocs d’exécution* et *blocs de regroupement*. Les sections suivantes décrivent les types de blocs qui composent ces catégories.  
  
### <a name="buffering-blocks"></a>Blocs de mise en mémoire tampon  
 Les blocs de mise en mémoire tampon contiennent des données destinées aux consommateurs de données. La bibliothèque de flux de données TPL fournit trois types de blocs de mise en mémoire tampon : <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType> et <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.  
  
#### <a name="bufferblockt"></a>BufferBlock(T)  
 La classe <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> représente une structure de messagerie asynchrone à usage général. Cette classe stocke une file d'attente de messages de type premier entré, premier sorti (FIFO). Plusieurs cibles peuvent lire ces messages et plusieurs sources peuvent y écrire. Quand une cible reçoit un message d'un objet <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>, ce message est supprimé de la file d'attente. Par conséquent, même si un objet <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> peut avoir plusieurs cibles, seule une cible reçoit chaque message. La classe <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> est utile quand vous voulez transmettre plusieurs messages à un autre composant et que ce composant doit recevoir chaque message.  
  
 Dans l'exemple simple qui suit, plusieurs valeurs <xref:System.Int32> sont publiées sur un objet <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>, puis sont lues depuis l'objet.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Pour obtenir un exemple complet qui montre comment écrire et lire des messages dans un <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> d’objets, consultez [Comment : écrire des Messages à et lire les Messages à partir d’un Dataflow Block](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  
 La classe <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> est utile quand vous devez transmettre plusieurs messages à un autre composant, mais que ce composant nécessite uniquement la valeur la plus récente. Cette classe est également utile quand vous voulez diffuser un message vers plusieurs composants.  
  
 Dans l'exemple simple qui suit, une valeur <xref:System.Double> est publiée sur un objet <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, puis est lue plusieurs fois depuis l'objet. Étant donné que les valeurs ne sont pas supprimées des objets <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> après leur lecture, la même valeur est disponible à chaque fois.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Pour obtenir un exemple complet qui montre comment utiliser <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> pour diffuser un message vers plusieurs blocs cibles, consultez [Comment : spécifier un planificateur de tâches dans un Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  
 La classe <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> est similaire à la classe <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, à ceci près qu'il n'est possible d'écrire qu'une seule fois dans un objet <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>. Vous pouvez considérer <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> comme étant similaire au langage c# [readonly](~/docs/csharp/language-reference/keywords/readonly.md) ([ReadOnly](~/docs/visual-basic/language-reference/modifiers/readonly.md) dans [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)]) (mot clé), à ceci près qu’un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objet est immuable après avoir reçu une valeur au lieu de lors de la construction. Comme pour la classe <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, quand une cible reçoit un message d'un objet <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>, le message n'est pas supprimé de l'objet. Par conséquent, plusieurs cibles reçoivent une copie du message. La classe <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> est utile quand vous voulez propager uniquement le premier d'une liste de messages.  
  
 Dans l'exemple simple qui suit, plusieurs valeurs <xref:System.String> sont publiées sur un objet <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>, puis sont lues depuis l'objet. Étant donné qu'il n'est possible d'écrire dans un objet <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> qu'une seule fois, une fois qu'un objet <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> reçoit un message, il rejette les messages suivants.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Pour obtenir un exemple complet qui montre comment utiliser <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> pour recevoir la valeur de la première opération se termine, consultez [Comment : dissocier des blocs de flux de données](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Blocs d'exécution  
 Les blocs d'exécution appellent un délégué fourni par l'utilisateur pour chaque donnée reçue. La bibliothèque de flux de données TPL fournit trois types de blocs d'exécution : <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType> et <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>.  
  
#### <a name="actionblockt"></a>ActionBlock(T)  
 La classe <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> est un bloc cible qui appelle un délégué quand il reçoit des données. Imaginez un objet <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> utilisé comme un délégué qui s'exécute de façon asynchrone quand des données deviennent disponibles. Le délégué que vous fournissez à un objet <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> peut être de type <xref:System.Action> ou `System.Func\<TInput, Task>`. Quand vous utilisez un objet <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> avec <xref:System.Action>, le traitement de chaque élément d'entrée est considéré comme terminé quand le délégué est retourné. Quand vous utilisez un objet <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> avec `System.Func\<TInput, Task>`, le traitement de chaque élément d'entrée n'est considéré comme terminé que quand l'objet <xref:System.Threading.Tasks.Task> retourné est à l'état achevé. À l'aide de ces deux mécanismes, vous pouvez utiliser <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> pour le traitement synchrone et asynchrone de chaque élément d'entrée.  
  
 Dans l'exemple simple qui suit, plusieurs valeurs <xref:System.Int32> sont publiées sur un objet <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>. L'objet <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> imprime ces valeurs dans la console. Cet exemple attribue ensuite au bloc l'état achevé, puis attend que toutes les tâches de flux de données soient terminées.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Pour obtenir des exemples complets qui montrent comment utiliser des délégués avec la <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> de classe, consultez [Comment : effectuer Action lorsqu’un flux de données bloc reçoit des données](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  
 La classe <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> est similaire à la classe <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, à ceci près qu'elle joue à la fois le rôle de source et le rôle de cible. Le délégué que vous passez à un objet <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> renvoie une valeur de type `TOutput`. Le délégué que vous fournissez à un objet <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> peut être de type `System.Func<TInput, TOutput>` ou `System.Func<TInput, Task>`. Quand vous utilisez un objet <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> avec `System.Func\<TInput, TOutput>`, le traitement de chaque élément d'entrée est considéré comme terminé quand le délégué est retourné. Quand vous utilisez un objet <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> utilisé avec `System.Func<TInput, Task<TOutput>>`, le traitement de chaque élément d'entrée n'est considéré comme terminé que quand l'objet <xref:System.Threading.Tasks.Task> retourné est à l'état achevé. Comme pour <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, ces deux mécanismes vous permettent d'utiliser <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> pour le traitement synchrone et asynchrone de chaque élément d'entrée.  
  
 Dans l'exemple simple qui suit, l'objet <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> créé calcule la racine carrée de son entrée. L'objet <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> prend des valeurs <xref:System.Int32> comme entrée et produit des valeurs <xref:System.Double> comme sortie.  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Pour obtenir des exemples complets qui utilise <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> dans un réseau de blocs de flux de données qui effectue le traitement de l’image dans une application Windows Forms, consultez [procédure pas à pas : utilisation de flux de données dans une Application Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  
 La classe <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> est similaire à la classe <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, à ceci près que <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> produit zéro, une ou plusieurs valeurs de sortie pour chaque valeur d'entrée, au lieu d'une seule valeur de sortie pour chaque valeur d'entrée. Le délégué que vous fournissez à un objet <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> peut être de type `System.Func<TInput, IEnumerable<TOutput>>` ou `type System.Func<TInput, Task<IEnumerable<TOutput>>>`. Quand vous utilisez un objet <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> avec `System.Func<TInput, IEnumerable<TOutput>>`, le traitement de chaque élément d'entrée est considéré comme terminé quand le délégué est retourné. Quand vous utilisez un objet <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> avec `System.Func<TInput, Task<IEnumerable<TOutput>>>`, le traitement de chaque élément d'entrée n'est considéré comme terminé que quand l'objet `System.Threading.Tasks.Task<IEnumerable<TOutput>>` retourné est à l'état achevé.  
  
 Dans l'exemple simple qui suit, l'objet <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> créé fractionne les chaînes en séquences de caractères. L'objet <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> prend des valeurs <xref:System.String> comme entrée et produit des valeurs <xref:System.Char> comme sortie.  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Pour obtenir des exemples complets qui utilisent <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> pour produire plusieurs sorties indépendantes pour chaque entrée dans un pipeline de flux de données, consultez [procédure pas à pas : création d’un Pipeline de flux de données](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md).  
  
#### <a name="degree-of-parallelism"></a>Degré de parallélisme  
 Chaque objet <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> et <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> met en mémoire tampon les messages entrants jusqu'à ce que le bloc soit prêt à les traiter. Par défaut, ces classes de traitent les messages un par un, dans l'ordre dans lequel ils sont reçus. Vous pouvez également spécifier le degré de parallélisme permettant aux objets <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> et <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> de traiter plusieurs messages simultanément. Pour plus d'informations sur l'exécution simultanée, consultez la section "Spécification du degré de parallélisme" plus loin dans ce document. Vous trouverez un exemple dans lequel un degré de parallélisme est défini pour permettre à un bloc de flux de données d’exécution de traiter plusieurs messages à la fois sur la page [Guide pratique : spécifier le degré de parallélisme dans un bloc de flux de données](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Récapitulation des types délégués  
 Le tableau suivant récapitule les types délégués que vous pouvez fournir aux objets <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> et <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>. Le tableau indique également si le type délégué fonctionne de façon synchrone ou asynchrone.  
  
|Type|Type délégué synchrone|Type délégué asynchrone|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func\<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func\<TInput, TOutput>`2`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 Vous pouvez également utiliser des expressions lambda quand vous utilisez des types de blocs d'exécution. Vous trouverez un exemple qui montre comment utiliser une expression lambda avec un bloc d’exécution sur la page [Guide pratique : exécuter des actions lorsqu’un bloc de flux de données reçoit des données](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Blocs de regroupement  
 Les blocs de regroupement combinent les données d'une ou plusieurs sources, sous diverses contraintes. La bibliothèque de flux de données TPL fournit trois types de blocs de regroupement : <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> et <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.  
  
#### <a name="batchblockt"></a>BatchBlock(T)  
 La classe <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> combine des jeux de données d'entrée (ou lots), dans des tableaux de données de sortie. Vous spécifiez la taille de chaque lot quand vous créez un objet <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>. Quand l'objet <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> reçoit le nombre spécifié d'éléments d'entrée, il propage de manière asynchrone un tableau contenant ces éléments. Si un objet <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> est à l'état achevé, mais ne contient pas suffisamment d'éléments pour former un lot, il propage un tableau final contenant les éléments d'entrée restants.  
  
 Le <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> classe fonctionne en mode *gourmand* ou *non gourmand* mode. En mode gourmand, qui est le mode par défaut, un objet <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> accepte tous les messages qui lui sont envoyés et propage un tableau après avoir reçu le nombre spécifié d'éléments. En mode non gourmand, un objet <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> diffère tous les messages entrants jusqu'à ce que suffisamment de sources aient envoyé au bloc un nombre de messages permettant de former un lot. Le mode gourmand est généralement plus performant que le mode non gourmand, car il nécessite une charge de traitement moindre. Toutefois, vous pouvez utiliser le mode non gourmand quand vous devez coordonner la consommation de plusieurs sources de façon atomique. Pour spécifier le mode non gourmand, définissez <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> sur `False` dans le paramètre `dataflowBlockOptions` du constructeur <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A>.  
  
 Dans l'exemple simple qui suit, plusieurs valeurs <xref:System.Int32> sont publiées sur un objet <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> qui contient un lot de dix éléments. Pour garantir que toutes les valeurs de <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> soient propagées, cet exemple appelle la méthode <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A>. La méthode <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> définit l'objet <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> sur l'état achevé. L'objet <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> propage donc les éléments restants dans un dernier lot.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Pour obtenir un exemple complet qui utilise <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> pour améliorer l’efficacité des opérations d’insertion de base de données, consultez [procédure pas à pas : utilisation de BatchBlock et de BatchedJoinBlock pour améliorer l’efficacité](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>JoinBlock(T1, T2,...)  
 Les classes <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> et <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> collectent des éléments d'entrée et propagent les objets <xref:System.Tuple%602?displayProperty=nameWithType> ou <xref:System.Tuple%603?displayProperty=nameWithType> qui contiennent ces éléments. Les classes <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> et <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> n'héritent pas de <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Au lieu de cela, elles fournissent les propriétés <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A> et <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A> qui implémentent <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Comme <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> et <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> peuvent fonctionner en mode gourmand ou non gourmand. En mode gourmand, qui est le mode par défaut, un objet <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> ou <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> accepte tous les messages qui lui sont envoyés et propage un tuple chaque fois que l'une de ses cibles reçoit au moins un message. En mode non gourmand, un objet <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> ou <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> diffère tous les messages entrants jusqu'à ce que toutes les cibles aient reçu les données requises pour créer un tuple. À ce stade, le bloc s'engage dans un protocole de validation en deux phases pour récupérer atomiquement tous les éléments requis à partir des sources. Ce report permet à une autre entité de consommer les données pendant ce temps, pour que l'ensemble du système puisse progresser.  
  
 Dans l'exemple simple qui suit, un objet <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> nécessite plusieurs données pour calculer une valeur. Dans cet exemple, l'objet <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> créé nécessite deux valeurs <xref:System.Int32> et une valeur <xref:System.Char> pour effectuer une opération arithmétique.  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Pour obtenir un exemple complet qui utilise <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> objets en mode non gourmand pour partager de manière coopérative une ressource, consultez [Comment : utiliser JoinBlock pour lire des données à partir de plusieurs Sources](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock(T1, T2, ...)  
 Les classes <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> et <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> collectent des lots d'éléments d'entrée et propagent les objets `System.Tuple(IList(T1), IList(T2))` ou `System.Tuple(IList(T1), IList(T2), IList(T3))` qui contiennent ces éléments. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> est un mélange entre <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> et <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>. Vous spécifiez la taille de chaque lot quand vous créez un objet <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> fournit également les propriétés <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> et <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> qui implémentent <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Quand le nombre spécifié d'éléments d'entrée est reçu par l'ensemble des cibles, l'objet <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> propage de manière asynchrone un objet `System.Tuple(IList(T1), IList(T2))` qui contient ces éléments.  
  
 Dans l'exemple simple qui suit, l'objet <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> créé contient des résultats, des valeurs <xref:System.Int32> et des erreurs qui sont des objets <xref:System.Exception>. Dans cet exemple, plusieurs opérations sont effectuées. Les résultats sont écrits dans la propriété <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> et les erreurs dans la propriété <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> de l'objet <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>. Étant donné que le nombre d'opérations ayant réussi et ayant échoué n'est pas connu à l'avance, les objets <xref:System.Collections.Generic.IList%601> permettent à chaque cible de recevoir zéro, une ou plusieurs valeurs.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Pour obtenir un exemple complet qui utilise <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> pour capturer les résultats et toutes les exceptions qui se produisent quand le programme lit à partir d’une base de données, consultez [procédure pas à pas : utilisation de BatchBlock et de BatchedJoinBlock pour améliorer l’efficacité](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
 [[retour en haut](#top)]  
  
<a name="behavior"></a>   
## <a name="configuring-dataflow--block-behavior"></a>Configuration du comportement des blocs de flux de données  
 Vous pouvez activer des options supplémentaires en fournissant un objet <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> au constructeur de types de blocs de flux de données. Ces options permettent de contrôler le comportement, comme celui du planificateur qui gère la tâche sous-jacente et le degré de parallélisme. <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> possède également des types dérivés qui spécifient le comportement spécifique à certains types de blocs de flux de données. Le tableau suivant récapitule les types d'options qui sont associés à chaque type de bloc de flux de données.  
  
|Type de bloc de flux de données|Type <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 Les sections suivantes fournissent des informations supplémentaires sur les types importants d'options de blocs de flux de données qui sont disponibles via les classes <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType> et <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType>.  
  
### <a name="specifying-the-task-scheduler"></a>Spécification du planificateur de tâches  
 Chaque bloc de flux de données prédéfini utilise le mécanisme de planification des tâches TPL pour effectuer des activités, telles que la propagation de données vers une cible, la réception de données à partir d'une source et l'exécution de délégués définis par l'utilisateur quand des données deviennent disponibles. <xref:System.Threading.Tasks.TaskScheduler> est une classe abstraite qui représente un planificateur de tâches qui place des tâches en attente dans des threads. Le planificateur de tâches par défaut, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, utilise la classe <xref:System.Threading.ThreadPool> pour placer des tâches en file d'attente et les exécuter. Vous pouvez remplacer le planificateur de tâches par défaut en définissant la propriété <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> quand vous créez un objet de bloc de flux de données.  
  
 Quand un même planificateur de tâches gère plusieurs blocs de flux de données, il peut appliquer les mêmes stratégies à chacune d'elles. Par exemple, si plusieurs blocs de flux de données sont configurés de manière à cibler le planificateur exclusif du même objet <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair>, toutes les tâches qui sont exécutées dans ces blocs seront sérialisées. De même, si ces blocs sont configurés de manière à cibler le planificateur simultané du même objet <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> et que le planificateur est configuré avec un niveau d'accès concurrentiel maximal, toutes les tâches de ces blocs seront limitées au nombre d'opérations simultanées. Pour obtenir un exemple qui utilise le <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> classe pour permettre les opérations de lecture soient effectuées en parallèle, mais écrire des opérations soit effectuée exclusivement de toutes les autres opérations, consultez [Comment : spécifier un planificateur de tâches dans un Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Pour plus d’informations sur les planificateurs de tâches dans la bibliothèque parallèle de tâches, consultez la rubrique sur la classe <xref:System.Threading.Tasks.TaskScheduler>.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Spécification du degré de parallélisme  
 Par défaut, les trois types de blocs d'exécution fournis par la bibliothèque de flux de données TPL (<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> et <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>) traitent les messages un par un. Ces types de blocs de flux de données traitent également les messages dans l'ordre dans lequel ils sont reçus. Pour permettre aux blocs de flux de données de traiter simultanément les messages, définissez la propriété <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> au moment de créer l'objet de bloc de flux de données.  
  
 La valeur par défaut de <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> est 1, ce qui signifie que le bloc de flux de données traitera les messages un par un. En définissant cette propriété sur une valeur supérieure à 1, vous permettez au bloc de flux de données de traiter plusieurs messages simultanément. Si vous définissez cette propriété sur <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>, vous permettez au planificateur de tâches sous-jacentes de gérer le degré maximal de concurrence.  
  
> [!IMPORTANT]
>  Quand vous spécifiez un degré maximal de parallélisme supérieur à 1, plusieurs messages sont traités simultanément. Il se peut donc que les messages ne soient pas traités dans l'ordre dans lequel ils sont reçus. Toutefois, l'ordre dans lequel les messages sont générés à partir du bloc reste le même.  
  
 Étant donné que la propriété <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> représente le degré maximal de parallélisme, le bloc de flux de données peut s'exécuter avec un degré de parallélisme moindre spécifié par vos soins. Le bloc de flux de données peut utiliser un degré de parallélisme moindre pour satisfaire ses exigences fonctionnelles ou en cas de manque de ressources système disponibles. Un bloc de flux de données n'utilisera jamais un niveau de parallélisme supérieur à celui que vous spécifiez.  
  
 La valeur de la propriété <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> est exclusive à chaque objet de bloc de flux de données. Par exemple, si chacun des quatre objets de blocs de flux de données spécifie la valeur 1 comme degré maximal de parallélisme, les quatre objets de bloc de flux de données peuvent être exécutés en parallèle.  
  
 Vous trouverez un exemple dans lequel est défini le degré maximal de parallélisme permettant à des opérations de longue durée d’être exécutées en parallèle sur la page [Guide pratique : spécifier le degré de parallélisme dans un bloc de flux de données](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Spécification du nombre de messages par tâche  
 Les types de blocs de flux de données prédéfinis utilisent des tâches pour traiter plusieurs éléments d'entrée. Cela aide à réduire le nombre d'objets de tâches requis pour traiter les données, ce qui permet aux applications de s'exécuter plus efficacement. Toutefois, quand les tâches d'un ensemble de blocs de flux de données traitent des données, il est possible que les tâches des autres blocs de flux de données doivent attendre d'être traitées et placer leurs messages dans la file d'attente. Pour un meilleur respect de l'ordre des tâches de flux de données, définissez la propriété <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A>. Quand <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> a la valeur <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>, qui est la valeur par défaut, la tâche utilisée par un bloc de flux de données traite tous les messages disponibles. Quand <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> est défini sur une valeur autre que <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, le bloc de flux de données traite au maximum le nombre défini de messages par objet <xref:System.Threading.Tasks.Task>. Même si la configuration de la propriété <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> peut améliorer le respect de l'ordre des tâches, elle peut aussi entraîner la création par le système de davantage de tâches que nécessaire, réduisant ainsi les performances.  
  
### <a name="enabling-cancellation"></a>Permettre les annulations  
 La bibliothèque parallèle de tâches (TPL) fournit un mécanisme qui permet aux tâches de coordonner l'annulation de manière coopérative. Pour permettre aux blocs de flux de données de participer à ce mécanisme d'annulation, définissez la propriété <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A>. Quand l'objet <xref:System.Threading.CancellationToken> est à l'état annulé, tous les blocs de flux de données qui contrôlent ce jeton terminent l'exécution de l'élément actuel, mais ne démarrent pas le traitement des éléments suivants. De plus, ces blocs de flux de données effacent les messages mis en mémoire tampon, libèrent les connexions aux blocs sources et cibles, et passent à l'état annulé. Lors du passage à l'état annulé, la propriété <xref:System.Threading.Tasks.Task.Status%2A> de la propriété <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> est définie sur <xref:System.Threading.Tasks.TaskStatus.Canceled>, sauf si une exception s'est produite lors du traitement. Dans ce cas, <xref:System.Threading.Tasks.Task.Status%2A> est défini sur <xref:System.Threading.Tasks.TaskStatus.Faulted>.  
  
 Vous trouverez un exemple qui montre comment utiliser l’annulation dans une application Windows Forms sur la page [Guide pratique : annuler un bloc de flux de données](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md). Pour plus d’informations sur les annulations dans la bibliothèque parallèle de tâches, consultez la page [Annulation de tâches](../../../docs/standard/parallel-programming/task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Spécification des comportements gourmand et non gourmand  
 Plusieurs types de blocs de flux de données de regroupement peuvent fonctionner en mode *gourmand* ou en mode *non gourmand*. Par défaut, les types de blocs de flux de données prédéfinis fonctionnent en mode gourmand.  
  
 Pour les types de blocs de regroupement tels que <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, le mode gourmand signifie que le bloc accepte immédiatement les données, même si les données correspondantes avec lesquelles effectuer le regroupement ne sont pas encore disponibles. Le mode non gourmand signifie que le bloc diffère tous les messages entrants jusqu'à ce que chacune de ses cibles ait reçu un message, permettant ainsi le regroupement. Si l'un des messages différés n'est plus disponible, le bloc de regroupement libère tous les messages différés et redémarre le processus. Pour la classe <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, les comportements gourmand et non gourmand sont similaires, à ceci près qu'en mode non gourmand, un objet <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> diffère tous les messages entrants jusqu'à ce que suffisamment de messages soient disponibles dans plusieurs sources distinctes pour former un lot.  
  
 Pour spécifier le mode non gourmand pour un bloc de flux de données, définissez <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> sur `False`. Vous trouverez un exemple qui montre comment utiliser le mode non gourmand pour permettre à plusieurs blocs de regroupement de partager une source de données plus efficacement sur la page [Guide pratique : utiliser JoinBlock pour lire des données issues de plusieurs sources](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
 [[retour en haut](#top)]  
  
<a name="custom"></a>   
## <a name="custom-dataflow-blocks"></a>Blocs de flux de données personnalisés  
 Même si la bibliothèque de flux de données TPL fournit de nombreux types de blocs prédéfinis, vous pouvez créer d'autres types de blocs ayant un comportement personnalisé. Implémentez directement les interfaces <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> ou <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>, ou utilisez la méthode <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> pour créer un bloc complexe qui encapsule le comportement des types de blocs existants. Vous trouverez des exemples qui montrent comment implémenter la fonctionnalité de bloc de flux de données personnalisé sur la page [Procédure pas à pas : créer un type de bloc de flux de données personnalisé](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md).  
  
 [[retour en haut](#top)]  
  
## <a name="related-topics"></a>Rubriques connexes  
  
|Titre|Description|  
|-----------|-----------------|  
|[Guide pratique : écrire des messages dans un bloc de flux de données et les lire](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Montre comment écrire des messages dans un objet <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> et les lire.|  
|[Guide pratique : implémenter un modèle de flux de données producteur-consommateur](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)|Explique comment utiliser le modèle de flux de données pour implémenter un modèle producteur-consommateur, où le producteur envoie des messages à un bloc de flux de données et le consommateur lit les messages de ce bloc.|  
|[Guide pratique : exécuter des actions lorsqu’un bloc de flux de données reçoit des données](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)|Explique comment fournir des délégués aux types de blocs de flux de données d'exécution <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> et <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.|  
|[Procédure pas à pas : créer un pipeline de flux de données](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)|Explique comment créer un pipeline de flux de données qui télécharge du texte à partir du web et effectue des opérations sur ce texte.|  
|[Guide pratique : dissocier des blocs de flux de données](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)|Montre comment utiliser la <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> méthode pour dissocier un bloc cible à partir de sa source après que la source un message à la cible.|  
|[Procédure pas à pas : utiliser les flux de données dans une application Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)|Montre comment créer un réseau de blocs de flux de données qui effectuent un traitement des images dans une application Windows Forms.|  
|[Guide pratique : annuler un bloc de flux de données](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)|Montre comment utiliser l'annulation dans une application Windows Forms.|  
|[Guide pratique : utiliser JoinBlock pour lire des données issues de plusieurs sources](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Explique comment utiliser la classe <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> pour effectuer une opération quand des données sont disponibles dans plusieurs sources, et comment utiliser le mode non gourmand pour permettre à plusieurs blocs de regroupement de partager une source de données plus efficacement.|  
|[Guide pratique : spécifier le degré de parallélisme dans un bloc de flux de données](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Explique comment définir la propriété <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> pour permettre à un bloc de flux de données d'exécution de traiter plusieurs messages à la fois.|  
|[Guide pratique : spécifier un planificateur de tâches dans un bloc de flux de données](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Montre comment associer un planificateur de tâches spécifique quand vous utilisez un flux de données dans votre application.|  
|[Procédure pas à pas : utiliser BatchBlock et BatchedJoinBlock pour améliorer l’efficacité](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Explique comment utiliser la classe <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> pour améliorer l'efficacité des opérations d'insertion de bases de données, et comment utiliser la classe <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> pour capturer les résultats et les exceptions qui se produisent quand le programme lit les données d'une base de données.|  
|[Procédure pas à pas : créer un type de bloc de flux de données personnalisé](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)|Montre deux façons de créer un type de bloc de flux de données qui implémente un comportement personnalisé.|  
|[La bibliothèque parallèle de tâches](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)|Présente la bibliothèque parallèle de tâches (TPL), qui simplifie la programmation parallèle et simultanée dans les applications [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)].|
