---
title: "Fonctionnement de l'accélération dans PLINQ"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
caps.latest.revision: "14"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: c3373cb6a2c535bd7d42eb062e1f9727952f7cfb
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/18/2017
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="b084b-102">Fonctionnement de l'accélération dans PLINQ</span><span class="sxs-lookup"><span data-stu-id="b084b-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="b084b-103">L’objectif principal de PLINQ est permettant d’accélérer l’exécution de LINQ aux requêtes d’objets en exécutant les délégués de requête en parallèle sur les ordinateurs multicœurs.</span><span class="sxs-lookup"><span data-stu-id="b084b-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="b084b-104">PLINQ offre de meilleures performances lorsque le traitement de chaque élément dans une collection source est indépendant, sans aucun état partagé parmi les délégués individuels.</span><span class="sxs-lookup"><span data-stu-id="b084b-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="b084b-105">Ces opérations sont courantes dans LINQ to Objects et PLINQ et sont souvent appelées «*délicieusement parallèles*», car elles se prêtent facilement à la planification sur plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="b084b-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="b084b-106">Toutefois, toutes les requêtes sont constituées entièrement d’opérations délicieusement parallèles ; dans la plupart des cas, une requête concerne certains opérateurs qui soit ne peut pas être parallélisée, ou qui ralentissent l’exécution parallèle.</span><span class="sxs-lookup"><span data-stu-id="b084b-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="b084b-107">Même avec les requêtes qui sont entièrement délicieusement parallèles, PLINQ doit encore partitionner la source de données et planifier le travail sur les threads, et généralement fusionner les résultats lorsque la requête est terminée.</span><span class="sxs-lookup"><span data-stu-id="b084b-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="b084b-108">Toutes ces opérations ajoutent au coût de calcul de la parallélisation ; Ces coûts d’ajout de parallélisation sont appelés *surcharge*.</span><span class="sxs-lookup"><span data-stu-id="b084b-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="b084b-109">Pour optimiser les performances dans une requête PLINQ, vise à optimiser les parties qui sont délicieusement parallèles et de limiter les parties qui nécessitent de surcharge.</span><span class="sxs-lookup"><span data-stu-id="b084b-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="b084b-110">Cet article fournit des informations qui vous aideront à écrire des requêtes PLINQ aussi efficaces que possible tout en produisant des résultats corrects.</span><span class="sxs-lookup"><span data-stu-id="b084b-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="b084b-111">Facteurs qui influent sur les performances des requêtes PLINQ</span><span class="sxs-lookup"><span data-stu-id="b084b-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="b084b-112">Les sections suivantes répertorie certains des facteurs plus importants qu’impact sur les performances de requête parallèle.</span><span class="sxs-lookup"><span data-stu-id="b084b-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="b084b-113">Il s’agit d’instructions générales qui eux-mêmes ne sont pas suffisantes pour prédire les performances des requêtes dans tous les cas.</span><span class="sxs-lookup"><span data-stu-id="b084b-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="b084b-114">Comme toujours, il est important de mesurer les performances réelles des requêtes spécifiques sur les ordinateurs avec une plage de charges et les configurations représentatives.</span><span class="sxs-lookup"><span data-stu-id="b084b-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1.  <span data-ttu-id="b084b-115">Coût de calcul de l’ensemble.</span><span class="sxs-lookup"><span data-stu-id="b084b-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="b084b-116">Pour atteindre l’accélération, une requête PLINQ doit avoir suffisamment de travail délicieusement parallèle pour compenser la surcharge.</span><span class="sxs-lookup"><span data-stu-id="b084b-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="b084b-117">Le travail peut être exprimé comme le coût de calcul de chaque délégué multiplié par le nombre d’éléments dans la collection source.</span><span class="sxs-lookup"><span data-stu-id="b084b-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="b084b-118">En supposant qu’une opération peut être parallélisée, le plus de calculs coûteux il s’agit, plus la possibilité de l’accélération.</span><span class="sxs-lookup"><span data-stu-id="b084b-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="b084b-119">Par exemple, si une fonction accepte une milliseconde, une requête séquentielle plus de 1000 éléments prendra une seconde pour effectuer cette opération, tandis qu’une requête parallèle sur un ordinateur doté de quatre cœurs peut prendre uniquement 250 millisecondes.</span><span class="sxs-lookup"><span data-stu-id="b084b-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="b084b-120">Il en résulte une accélération de 750 millisecondes.</span><span class="sxs-lookup"><span data-stu-id="b084b-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="b084b-121">Si la fonction nécessitait une seconde à s’exécuter pour chaque élément, puis l’accélération serait de 750 secondes.</span><span class="sxs-lookup"><span data-stu-id="b084b-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="b084b-122">Si le délégué est très cher, PLINQ peut offrir une accélération significative avec uniquement quelques éléments de la collection source.</span><span class="sxs-lookup"><span data-stu-id="b084b-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="b084b-123">À l’inverse, petites collections source avec les délégués triviaux ne sont généralement pas bons candidats pour PLINQ.</span><span class="sxs-lookup"><span data-stu-id="b084b-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="b084b-124">Dans l’exemple suivant, queryA est probablement un bon candidat pour PLINQ, en supposant que sa fonction Select implique de nombreuses tâches.</span><span class="sxs-lookup"><span data-stu-id="b084b-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="b084b-125">queryB n’est probablement pas un bon candidat, car il n’existe pas de suffisamment de travail dans l’instruction Select, et la surcharge de parallélisation compensera la plupart ou la totalité de l’accélération.</span><span class="sxs-lookup"><span data-stu-id="b084b-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2.  <span data-ttu-id="b084b-126">Le nombre de cœurs logiques sur le système (degré de parallélisme).</span><span class="sxs-lookup"><span data-stu-id="b084b-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="b084b-127">Ce point est un corollaire évident de la section précédente, les requêtes qui sont délicieusement parallèles s’exécuter plus rapidement sur les ordinateurs avec plusieurs cœurs, car le travail peut être divisé entre davantage de threads simultanés.</span><span class="sxs-lookup"><span data-stu-id="b084b-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="b084b-128">La quantité globale de l’accélération varie selon le pourcentage de l’ensemble de la requête est redémarrée.</span><span class="sxs-lookup"><span data-stu-id="b084b-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="b084b-129">Toutefois, ne supposez pas que toutes les requêtes s’exécuteront deux fois plus rapide sur un ordinateur de huit cœurs comme un ordinateur de quatre principaux.</span><span class="sxs-lookup"><span data-stu-id="b084b-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="b084b-130">Lors du paramétrage des requêtes pour des performances optimales, il est important de mesurer les résultats réels sur les ordinateurs avec différents nombres de cœurs.</span><span class="sxs-lookup"><span data-stu-id="b084b-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="b084b-131">Ce point est lié au point #1 : jeux de données volumineux est nécessaires pour tirer parti des ressources de calcul supérieures.</span><span class="sxs-lookup"><span data-stu-id="b084b-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3.  <span data-ttu-id="b084b-132">Le nombre et le type d’opérations.</span><span class="sxs-lookup"><span data-stu-id="b084b-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="b084b-133">PLINQ fournit l’opérateur AsOrdered pour les situations dans lesquelles il est nécessaire de conserver l’ordre des éléments dans la séquence source.</span><span class="sxs-lookup"><span data-stu-id="b084b-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="b084b-134">Il existe un coût associé à la commande, mais ce coût est généralement modeste.</span><span class="sxs-lookup"><span data-stu-id="b084b-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="b084b-135">Opérations GroupBy et Join entraînent également une surcharge.</span><span class="sxs-lookup"><span data-stu-id="b084b-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="b084b-136">PLINQ offre de meilleures performances lorsqu’elle est autorisée à traiter les éléments de la collection source dans n’importe quel ordre et les passer à l’opérateur suivant dès qu’ils sont prêts.</span><span class="sxs-lookup"><span data-stu-id="b084b-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="b084b-137">Pour plus d’informations, consultez [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md) (Conservation de l’ordre dans PLINQ).</span><span class="sxs-lookup"><span data-stu-id="b084b-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4.  <span data-ttu-id="b084b-138">Le formulaire de l’exécution des requêtes.</span><span class="sxs-lookup"><span data-stu-id="b084b-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="b084b-139">Si vous stockez les résultats d’une requête en appelant ToArray ou ToList, les résultats de tous les threads parallèles doivent être fusionnés dans la structure de données unique.</span><span class="sxs-lookup"><span data-stu-id="b084b-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="b084b-140">Cela implique un coût de calcul inévitable.</span><span class="sxs-lookup"><span data-stu-id="b084b-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="b084b-141">De même, si vous itérez les résultats à l’aide d’une boucle foreach (For Each en Visual Basic), les résultats à partir de threads de travail doivent être sérialisés sur le thread de l’énumérateur.</span><span class="sxs-lookup"><span data-stu-id="b084b-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="b084b-142">Mais si vous souhaitez simplement effectuer une action en fonction du résultat de chaque thread, vous pouvez utiliser la méthode ForAll pour exécuter ce travail sur plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="b084b-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5.  <span data-ttu-id="b084b-143">Le type des options de fusion.</span><span class="sxs-lookup"><span data-stu-id="b084b-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="b084b-144">PLINQ peut être configuré pour sa sortie en mémoire tampon et de produire des segments ou à la fois une fois que le jeu de résultats complet est généré, ou aux résultats individuels de flux de données qu’ils sont produits.</span><span class="sxs-lookup"><span data-stu-id="b084b-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="b084b-145">Le premier résultat est le temps d’exécution réduit et les derniers résultats de la latence entre les éléments rapportés.</span><span class="sxs-lookup"><span data-stu-id="b084b-145">The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="b084b-146">Alors que les options de fusion n’ont pas toujours un impact considérable sur les performances globales de requête, elles peuvent affecter les performances perçues car elles contrôlent la durée pendant laquelle un utilisateur doit attendre à voir les résultats.</span><span class="sxs-lookup"><span data-stu-id="b084b-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="b084b-147">Pour plus d’informations, consultez l’article [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md) (Options de fusion de PLINQ).</span><span class="sxs-lookup"><span data-stu-id="b084b-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6.  <span data-ttu-id="b084b-148">Le type de partitionnement.</span><span class="sxs-lookup"><span data-stu-id="b084b-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="b084b-149">Dans certains cas, une requête PLINQ sur une collection source indexable peut entraîner une charge de travail déséquilibrée.</span><span class="sxs-lookup"><span data-stu-id="b084b-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="b084b-150">Lorsque cela se produit, vous pourrez peut-être augmenter les performances des requêtes en créant un partitionneur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="b084b-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="b084b-151">Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et la bibliothèque parallèle de tâches (TPL)](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="b084b-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="b084b-152">Lorsque PLINQ choisit le Mode séquentiel</span><span class="sxs-lookup"><span data-stu-id="b084b-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="b084b-153">PLINQ essaiera toujours exécuter une requête au moins aussi rapide que la requête s’exécute de manière séquentielle.</span><span class="sxs-lookup"><span data-stu-id="b084b-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="b084b-154">Bien que PLINQ ne pas la sollicitation en coûteux les délégués de l’utilisateur sont ou si la taille la source d’entrée, il recherche certaines requêtes « formes ».</span><span class="sxs-lookup"><span data-stu-id="b084b-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="b084b-155">Plus précisément, il recherche des opérateurs de requête ou des combinaisons d’opérateurs qui provoquent généralement une requête à exécuter plus lentement en mode parallèle.</span><span class="sxs-lookup"><span data-stu-id="b084b-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="b084b-156">Lorsqu’il recherche des formes, PLINQ par défaut revient au mode séquentiel.</span><span class="sxs-lookup"><span data-stu-id="b084b-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="b084b-157">Toutefois, après avoir mesuré les performances d’une requête spécifique, vous pouvez déterminer qu’elle s’exécute plus rapidement en mode parallèle.</span><span class="sxs-lookup"><span data-stu-id="b084b-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="b084b-158">Dans ce cas, vous pouvez utiliser la <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> indicateur la <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> méthode pour indiquer à PLINQ de paralléliser la requête.</span><span class="sxs-lookup"><span data-stu-id="b084b-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="b084b-159">Pour plus d’informations, consultez [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md) (Guide pratique pour spécifier le mode d’exécution dans PLINQ).</span><span class="sxs-lookup"><span data-stu-id="b084b-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="b084b-160">La liste suivante décrit les formes de requêtes PLINQ par défaut s’exécute en mode séquentiel :</span><span class="sxs-lookup"><span data-stu-id="b084b-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
-   <span data-ttu-id="b084b-161">Requêtes qui contiennent une instruction Select, Where indexée, SelectMany indexée ou ElementAt après un opérateur de tri ou de filtrage qui a supprimé ou réorganisé les indices d’origine.</span><span class="sxs-lookup"><span data-stu-id="b084b-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
-   <span data-ttu-id="b084b-162">Requêtes qui contiennent un SkipWhile opérateur Take, TakeWhile, ignorer et où les index de la séquence source ne sont pas dans l’ordre d’origine.</span><span class="sxs-lookup"><span data-stu-id="b084b-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
-   <span data-ttu-id="b084b-163">Requêtes qui contiennent Zip ou SequenceEquals, sauf si une des sources de données a un index ordonné à l’origine et la source de données indexable (autrement dit, un tableau ou un IList(T)).</span><span class="sxs-lookup"><span data-stu-id="b084b-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
-   <span data-ttu-id="b084b-164">Requêtes qui contiennent Concat, sauf si elle est appliquée aux sources de données indexables.</span><span class="sxs-lookup"><span data-stu-id="b084b-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
-   <span data-ttu-id="b084b-165">Requêtes qui contiennent Reverse, sauf si appliqué à une source de données indexable.</span><span class="sxs-lookup"><span data-stu-id="b084b-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b084b-166">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="b084b-166">See Also</span></span>  
 [<span data-ttu-id="b084b-167">Parallel LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="b084b-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
