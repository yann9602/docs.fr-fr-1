---
title: "Stockage local des threads : champs statiques et emplacements de données relatifs à un thread"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- threading [.NET Framework], local storage
- threading [.NET Framework], thread-relative static fields
- local thread storage
- TLS
ms.assetid: c633a4dc-a790-4ed1-96b5-f72bd968b284
caps.latest.revision: "13"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 39dd80d378171563f2aadadaa146278e8a417d32
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/21/2017
---
# <a name="thread-local-storage-thread-relative-static-fields-and-data-slots"></a><span data-ttu-id="fc854-102">Stockage local des threads : champs statiques et emplacements de données relatifs à un thread</span><span class="sxs-lookup"><span data-stu-id="fc854-102">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span>
<span data-ttu-id="fc854-103">Vous pouvez utiliser managé stockage local des threads (TLS) pour stocker des données qui est unique dans un domaine d’application et de thread.</span><span class="sxs-lookup"><span data-stu-id="fc854-103">You can use managed thread local storage (TLS) to store data that is unique to a thread and application domain.</span></span> <span data-ttu-id="fc854-104">Le .NET Framework fournit deux façons d’utiliser le TLS managé : emplacements de données et les champs statiques relatifs à un thread.</span><span class="sxs-lookup"><span data-stu-id="fc854-104">The .NET Framework provides two ways to use managed TLS: thread-relative static fields and data slots.</span></span>  
  
-   <span data-ttu-id="fc854-105">Utilisez les champs statiques relatifs à un thread (relatifs à un thread `Shared` champs en Visual Basic) si vous pouvez anticiper vos besoins précis au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="fc854-105">Use thread-relative static fields (thread-relative `Shared` fields in Visual Basic) if you can anticipate your exact needs at compile time.</span></span> <span data-ttu-id="fc854-106">Les champs statiques relatifs à un thread offrent les meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="fc854-106">Thread-relative static fields provide the best performance.</span></span> <span data-ttu-id="fc854-107">Ils vous fournissent également les avantages de la vérification de type au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="fc854-107">They also give you the benefits of compile-time type checking.</span></span>  
  
-   <span data-ttu-id="fc854-108">Utilisez les emplacements de données lorsque vos besoins réels peuvent être détectées uniquement au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="fc854-108">Use data slots when your actual requirements might be discovered only at run time.</span></span> <span data-ttu-id="fc854-109">Les emplacements de données sont plus lents et plus difficiles à utiliser que les champs statiques relatifs à un thread et les données sont stockées en tant que type <xref:System.Object>, de sorte que vous devez effectuer un cast en type correct avant de l’utiliser.</span><span class="sxs-lookup"><span data-stu-id="fc854-109">Data slots are slower and more awkward to use than thread-relative static fields, and data is stored as type <xref:System.Object>, so you must cast it to the correct type before you use it.</span></span>  
  
 <span data-ttu-id="fc854-110">Dans C++ non managé, vous utilisez `TlsAlloc` pour allouer dynamiquement des emplacements et `__declspec(thread)` pour déclarer qu’une variable doit être allouée dans le stockage relatifs à un thread.</span><span class="sxs-lookup"><span data-stu-id="fc854-110">In unmanaged C++, you use `TlsAlloc` to allocate slots dynamically and `__declspec(thread)` to declare that a variable should be allocated in thread-relative storage.</span></span> <span data-ttu-id="fc854-111">Emplacements de données et les champs statiques relatifs à un thread fournissent la version managée de ce comportement.</span><span class="sxs-lookup"><span data-stu-id="fc854-111">Thread-relative static fields and data slots provide the managed version of this behavior.</span></span>  
  
 <span data-ttu-id="fc854-112">Dans le [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], vous pouvez utiliser la <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> classe pour créer des objets locaux de thread initialisés tardivement lorsque l’objet est tout d’abord consommé.</span><span class="sxs-lookup"><span data-stu-id="fc854-112">In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> class to create thread-local objects that are initialized lazily when the object is first consumed.</span></span> <span data-ttu-id="fc854-113">Pour plus d’informations, consultez [Initialisation tardive](../../../docs/framework/performance/lazy-initialization.md).</span><span class="sxs-lookup"><span data-stu-id="fc854-113">For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="uniqueness-of-data-in-managed-tls"></a><span data-ttu-id="fc854-114">Unicité des données dans TLS managé</span><span class="sxs-lookup"><span data-stu-id="fc854-114">Uniqueness of Data in Managed TLS</span></span>  
 <span data-ttu-id="fc854-115">Si vous utilisez les champs statiques relatifs à un thread ou des emplacements de données, les données dans TLS managé sont uniques à la combinaison du domaine d’application et de thread.</span><span class="sxs-lookup"><span data-stu-id="fc854-115">Whether you use thread-relative static fields or data slots, data in managed TLS is unique to the combination of thread and application domain.</span></span>  
  
-   <span data-ttu-id="fc854-116">Au sein d’un domaine d’application, un thread ne peut pas modifier les données à partir d’un autre thread, même lorsque les deux threads utilisent le même champ ou un emplacement.</span><span class="sxs-lookup"><span data-stu-id="fc854-116">Within an application domain, one thread cannot modify data from another thread, even when both threads use the same field or slot.</span></span>  
  
-   <span data-ttu-id="fc854-117">Lorsqu’un thread accède au même champ ou emplacement à partir de plusieurs domaines d’application, une valeur séparée est maintenue dans chaque domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="fc854-117">When a thread accesses the same field or slot from multiple application domains, a separate value is maintained in each application domain.</span></span>  
  
 <span data-ttu-id="fc854-118">Par exemple, si un thread définit la valeur d’un champ static relatifs à un thread, passe à un autre domaine d’application, puis récupère la valeur du champ, la valeur récupérée dans le deuxième domaine d’application est différente de la valeur dans le premier domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="fc854-118">For example, if a thread sets the value of a thread-relative static field, enters another application domain, and then retrieves the value of the field, the value retrieved in the second application domain differs from the value in the first application domain.</span></span> <span data-ttu-id="fc854-119">Définition d’une nouvelle valeur pour le champ dans le deuxième domaine d’application n’affecte pas la valeur du champ dans le premier domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="fc854-119">Setting a new value for the field in the second application domain does not affect the field's value in the first application domain.</span></span>  
  
 <span data-ttu-id="fc854-120">De même, lorsqu’un thread obtient le même emplacement de données nommé dans deux domaines d’application différents, les données dans le premier domaine d’application restent indépendantes des données dans le deuxième domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="fc854-120">Similarly, when a thread gets the same named data slot in two different application domains, the data in the first application domain remains independent of the data in the second application domain.</span></span>  
  
## <a name="thread-relative-static-fields"></a><span data-ttu-id="fc854-121">Champs statiques relatifs à un thread</span><span class="sxs-lookup"><span data-stu-id="fc854-121">Thread-Relative Static Fields</span></span>  
 <span data-ttu-id="fc854-122">Si vous savez qu’un élément de données est toujours unique à un thread et une combinaison de domaines d’application, appliquez le <xref:System.ThreadStaticAttribute> d’attribut dans le champ statique.</span><span class="sxs-lookup"><span data-stu-id="fc854-122">If you know that a piece of data is always unique to a thread and application-domain combination, apply the <xref:System.ThreadStaticAttribute> attribute to the static field.</span></span> <span data-ttu-id="fc854-123">Utilisez le champ comme vous utiliseriez tout autre champ statique.</span><span class="sxs-lookup"><span data-stu-id="fc854-123">Use the field as you would use any other static field.</span></span> <span data-ttu-id="fc854-124">Les données dans le champ sont uniques à chaque thread qui l’utilise.</span><span class="sxs-lookup"><span data-stu-id="fc854-124">The data in the field is unique to each thread that uses it.</span></span>  
  
 <span data-ttu-id="fc854-125">Les champs statiques relatifs à un thread offrent de meilleures performances que les emplacements de données et ont l’avantage de la vérification de type au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="fc854-125">Thread-relative static fields provide better performance than data slots and have the benefit of compile-time type checking.</span></span>  
  
 <span data-ttu-id="fc854-126">N’oubliez pas que tout code de constructeur de classe s’exécutera sur le premier thread dans le premier contexte qui accède au champ.</span><span class="sxs-lookup"><span data-stu-id="fc854-126">Be aware that any class constructor code will run on the first thread in the first context that accesses the field.</span></span> <span data-ttu-id="fc854-127">Dans tous les autres threads ou contextes dans le même domaine d’application, les champs sont initialisés à `null` (`Nothing` en Visual Basic) si elles sont des types référence ou à leur valeur par défaut les valeurs si elles sont des types valeur.</span><span class="sxs-lookup"><span data-stu-id="fc854-127">In all other threads or contexts in the same application domain, the fields will be initialized to `null` (`Nothing` in Visual Basic) if they are reference types, or to their default values if they are value types.</span></span> <span data-ttu-id="fc854-128">Par conséquent, vous fiez pas à des constructeurs de classe pour initialiser les champs statiques relatifs à un thread.</span><span class="sxs-lookup"><span data-stu-id="fc854-128">Therefore, you should not rely on class constructors to initialize thread-relative static fields.</span></span> <span data-ttu-id="fc854-129">Au lieu de cela, évitez d’initialiser les champs statiques relatifs à un thread et supposez qu’ils sont initialisés à `null` (`Nothing`) ou à leurs valeurs par défaut.</span><span class="sxs-lookup"><span data-stu-id="fc854-129">Instead, avoid initializing thread-relative static fields and assume that they are initialized to `null` (`Nothing`) or to their default values.</span></span>  
  
## <a name="data-slots"></a><span data-ttu-id="fc854-130">Emplacements de données</span><span class="sxs-lookup"><span data-stu-id="fc854-130">Data Slots</span></span>  
 <span data-ttu-id="fc854-131">Le .NET Framework fournit les emplacements de données dynamiques qui sont uniques à une combinaison de thread et le domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="fc854-131">The .NET Framework provides dynamic data slots that are unique to a combination of thread and application-domain.</span></span> <span data-ttu-id="fc854-132">Il existe deux types d’emplacements de données : emplacements nommés et les emplacements sans nom.</span><span class="sxs-lookup"><span data-stu-id="fc854-132">There are two types of data slots: named slots and unnamed slots.</span></span> <span data-ttu-id="fc854-133">Les deux sont implémentés à l’aide de la <xref:System.LocalDataStoreSlot> structure.</span><span class="sxs-lookup"><span data-stu-id="fc854-133">Both are implemented by using the <xref:System.LocalDataStoreSlot> structure.</span></span>  
  
-   <span data-ttu-id="fc854-134">Pour créer un emplacement de données, utilisez la <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> ou <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="fc854-134">To create a named data slot, use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="fc854-135">Pour obtenir une référence à un emplacement nommé existant, passez son nom à la <xref:System.Threading.Thread.GetNamedDataSlot%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="fc854-135">To get a reference to an existing named slot, pass its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method.</span></span>  
  
-   <span data-ttu-id="fc854-136">Pour créer un emplacement de données sans nom, utilisez le <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="fc854-136">To create an unnamed data slot, use the <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="fc854-137">Pour les nommés et sans nom emplacements, utilisez le <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> et <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> méthodes pour définir et récupérer les informations contenues dans l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="fc854-137">For both named and unnamed slots, use the <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> methods to set and retrieve the information in the slot.</span></span> <span data-ttu-id="fc854-138">Il s’agit des méthodes statiques qui agissent toujours sur les données pour le thread qui les exécute actuellement.</span><span class="sxs-lookup"><span data-stu-id="fc854-138">These are static methods that always act on the data for the thread that is currently executing them.</span></span>  
  
 <span data-ttu-id="fc854-139">Les emplacements nommés peuvent être pratiques, car vous pouvez récupérer l’emplacement lorsque vous en avez besoin en passant son nom à la <xref:System.Threading.Thread.GetNamedDataSlot%2A> méthode, au lieu de conserver une référence à un emplacement sans nom.</span><span class="sxs-lookup"><span data-stu-id="fc854-139">Named slots can be convenient, because you can retrieve the slot when you need it by passing its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method, instead of maintaining a reference to an unnamed slot.</span></span> <span data-ttu-id="fc854-140">Toutefois, si un autre composant utilise le même nom pour son stockage relatifs à un thread et un thread exécute du code à partir de votre composant et l’autre composant, les deux composants peuvent endommager les données de l’autre.</span><span class="sxs-lookup"><span data-stu-id="fc854-140">However, if another component uses the same name for its thread-relative storage and a thread executes code from both your component and the other component, the two components might corrupt each other's data.</span></span> <span data-ttu-id="fc854-141">(Ce scénario suppose que les deux composants sont exécutent dans le même domaine d’application, et qu’ils ne sont pas conçus pour partager les mêmes données.)</span><span class="sxs-lookup"><span data-stu-id="fc854-141">(This scenario assumes that both components are running in the same application domain, and that they are not designed to share the same data.)</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="fc854-142">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="fc854-142">See Also</span></span>  
 <xref:System.ContextStaticAttribute>  
 <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType>  
 <xref:System.ThreadStaticAttribute>  
 <xref:System.Runtime.Remoting.Messaging.CallContext>  
 [<span data-ttu-id="fc854-143">Thread</span><span class="sxs-lookup"><span data-stu-id="fc854-143">Threading</span></span>](../../../docs/standard/threading/index.md)
